'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreHttp = require('@azure/core-http');
var tslib = require('tslib');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
var abortController = require('@azure/abort-controller');
var os = require('os');
var crypto = require('crypto');
require('@azure/core-paging');
var stream = require('stream');
var events = require('events');
var fs = require('fs');
var util = require('util');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
var AccountSASPermissions = /** @class */ (function () {
    function AccountSASPermissions() {
        /**
         * Permission to read resources and list queues and tables granted.
         */
        this.read = false;
        /**
         * Permission to write resources granted.
         */
        this.write = false;
        /**
         * Permission to delete blobs and files granted.
         */
        this.delete = false;
        /**
         * Permission to list blob containers, blobs, shares, directories, and files granted.
         */
        this.list = false;
        /**
         * Permission to add messages, table entities, and append to blobs granted.
         */
        this.add = false;
        /**
         * Permission to create blobs and files granted.
         */
        this.create = false;
        /**
         * Permissions to update messages and table entities granted.
         */
        this.update = false;
        /**
         * Permission to get and delete messages granted.
         */
        this.process = false;
    }
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @param permissions -
     */
    AccountSASPermissions.parse = function (permissions) {
        var accountSASPermissions = new AccountSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var c = permissions_1[_i];
            switch (c) {
                case "r":
                    accountSASPermissions.read = true;
                    break;
                case "w":
                    accountSASPermissions.write = true;
                    break;
                case "d":
                    accountSASPermissions.delete = true;
                    break;
                case "l":
                    accountSASPermissions.list = true;
                    break;
                case "a":
                    accountSASPermissions.add = true;
                    break;
                case "c":
                    accountSASPermissions.create = true;
                    break;
                case "u":
                    accountSASPermissions.update = true;
                    break;
                case "p":
                    accountSASPermissions.process = true;
                    break;
                default:
                    throw new RangeError("Invalid permission character: " + c);
            }
        }
        return accountSASPermissions;
    };
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     */
    AccountSASPermissions.prototype.toString = function () {
        // The order of the characters should be as specified here to ensure correctness:
        // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
        // Use a string array instead of string concatenating += operator for performance
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.update) {
            permissions.push("u");
        }
        if (this.process) {
            permissions.push("p");
        }
        return permissions.join("");
    };
    return AccountSASPermissions;
}());

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 */
var AccountSASResourceTypes = /** @class */ (function () {
    function AccountSASResourceTypes() {
        /**
         * Permission to access service level APIs granted.
         */
        this.service = false;
        /**
         * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
         */
        this.container = false;
        /**
         * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
         */
        this.object = false;
    }
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @param resourceTypes -
     */
    AccountSASResourceTypes.parse = function (resourceTypes) {
        var accountSASResourceTypes = new AccountSASResourceTypes();
        for (var _i = 0, resourceTypes_1 = resourceTypes; _i < resourceTypes_1.length; _i++) {
            var c = resourceTypes_1[_i];
            switch (c) {
                case "s":
                    accountSASResourceTypes.service = true;
                    break;
                case "c":
                    accountSASResourceTypes.container = true;
                    break;
                case "o":
                    accountSASResourceTypes.object = true;
                    break;
                default:
                    throw new RangeError("Invalid resource type: " + c);
            }
        }
        return accountSASResourceTypes;
    };
    /**
     * Converts the given resource types to a string.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     */
    AccountSASResourceTypes.prototype.toString = function () {
        var resourceTypes = [];
        if (this.service) {
            resourceTypes.push("s");
        }
        if (this.container) {
            resourceTypes.push("c");
        }
        if (this.object) {
            resourceTypes.push("o");
        }
        return resourceTypes.join("");
    };
    return AccountSASResourceTypes;
}());

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 */
var AccountSASServices = /** @class */ (function () {
    function AccountSASServices() {
        /**
         * Permission to access blob resources granted.
         */
        this.blob = false;
        /**
         * Permission to access file resources granted.
         */
        this.file = false;
        /**
         * Permission to access queue resources granted.
         */
        this.queue = false;
        /**
         * Permission to access table resources granted.
         */
        this.table = false;
    }
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @param services -
     */
    AccountSASServices.parse = function (services) {
        var accountSASServices = new AccountSASServices();
        for (var _i = 0, services_1 = services; _i < services_1.length; _i++) {
            var c = services_1[_i];
            switch (c) {
                case "b":
                    accountSASServices.blob = true;
                    break;
                case "f":
                    accountSASServices.file = true;
                    break;
                case "q":
                    accountSASServices.queue = true;
                    break;
                case "t":
                    accountSASServices.table = true;
                    break;
                default:
                    throw new RangeError("Invalid service character: " + c);
            }
        }
        return accountSASServices;
    };
    /**
     * Converts the given services to a string.
     *
     */
    AccountSASServices.prototype.toString = function () {
        var services = [];
        if (this.blob) {
            services.push("b");
        }
        if (this.table) {
            services.push("t");
        }
        if (this.queue) {
            services.push("q");
        }
        if (this.file) {
            services.push("f");
        }
        return services.join("");
    };
    return AccountSASServices;
}());

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Generate SasIPRange format string. For example:
 *
 * "8.8.8.8" or "1.1.1.1-255.255.255.255"
 *
 * @param ipRange - A range of IP addresses.
 * @returns string representation of the IP range.
 */
function ipRangeToString(ipRange) {
    return ipRange.end ? ipRange.start + "-" + ipRange.end : ipRange.start;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var SDK_VERSION = "12.6.0";
var SERVICE_VERSION = "2020-08-04";
var FILE_MAX_SIZE_BYTES = 4 * 1024 * 1024 * 1024 * 1024; // 4TB
var FILE_RANGE_MAX_SIZE_BYTES = 4 * 1024 * 1024; // 4MB
var DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
var DEFAULT_HIGH_LEVEL_CONCURRENCY = 5;
var URLConstants = {
    Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SHARE_SNAPSHOT: "sharesnapshot",
        SIGNATURE: "sig",
        TIMEOUT: "timeout"
    }
};
var HeaderConstants = {
    AUTHORIZATION: "authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "content-encoding",
    CONTENT_LANGUAGE: "content-language",
    CONTENT_LENGTH: "content-length",
    CONTENT_MD5: "content-md5",
    CONTENT_TYPE: "content-type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date"
};
var StorageFileLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "x-ms-cache-control",
    "x-ms-content-disposition",
    "x-ms-content-encoding",
    "x-ms-content-language",
    "x-ms-content-length",
    "x-ms-content-md5",
    "x-ms-content-type",
    "x-ms-file-attributes",
    "x-ms-file-change-time",
    "x-ms-file-creation-time",
    "x-ms-file-id",
    "x-ms-file-last-write-time",
    "x-ms-file-parent-id",
    "x-ms-handle-id",
    "x-ms-number-of-handles-closed",
    "x-ms-recursive",
    "x-ms-share-quota",
    "x-ms-type",
    "x-ms-write"
];
var StorageFileLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "copyid",
    "restype"
];

// Copyright (c) Microsoft Corporation.
/**
 * Reserved URL characters must be properly escaped for Storage services like Blob or File.
 *
 * ## URL encode and escape strategy for JS SDKs
 *
 * When customers pass a URL string into XXXClient classes constructor, the URL string may already be URL encoded or not.
 * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL
 * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XXXClient constructors.
 *
 * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.
 *
 * This is what legacy V2 SDK does, simple and works for most of the cases.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%253A" and send to server. A blob named "b%3A" will be created.
 *
 * But this strategy will make it not possible to create a blob with "?" in it's name. Because when customer URL string is
 * "http://account.blob.core.windows.net/con/blob?name", the "?name" will be treated as URL paramter instead of blob name.
 * If customer URL string is "http://account.blob.core.windows.net/con/blob%3Fname", a blob named "blob%3Fname" will be created.
 * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.
 * We cannot accept a SDK cannot create a blob name with "?". So we implement strategy two:
 *
 * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.
 *
 * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will escape ":" like "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%3A" to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%253A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%253A" to server. A blob named "b%3A" will be created.
 *
 * This strategy gives us flexibility to create with any special characters. But "%" will be treated as a special characters, if the URL string
 * is not encoded, there shouldn't a "%" in the URL string, otherwise the URL is not a valid URL.
 * If customer needs to create a blob with "%" in it's blob name, use "%25" insead of "%". Just like above 3rd sample.
 * And following URL strings are invalid:
 * - "http://account.blob.core.windows.net/con/b%"
 * - "http://account.blob.core.windows.net/con/b%2"
 * - "http://account.blob.core.windows.net/con/b%G"
 *
 * Another special character is "?", use "%2F" to represent a blob name with "?" in a URL string.
 *
 * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `ContainerClient.getBlobClient(blobName)`
 *
 * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata
 *
 * @param url -
 */
function escapeURLPath(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var path = urlParsed.getPath();
    path = path || "/";
    path = escape(path);
    urlParsed.setPath(path);
    return urlParsed.toString();
}
function getValueInConnString(connectionString, argument) {
    var elements = connectionString.split(";");
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (element.trim().startsWith(argument)) {
            return element.trim().match(argument + "=(.*)")[1];
        }
    }
    return "";
}
/**
 * Extracts the parts of an Azure Storage account connection string.
 *
 * @param connectionString - Connection string.
 * @returns String key value pairs of the storage account's url and credentials.
 */
function extractConnectionStringParts(connectionString) {
    // Matching FileEndpoint in the Account connection string
    var fileEndpoint = getValueInConnString(connectionString, "FileEndpoint");
    // Slicing off '/' at the end if exists
    // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)
    fileEndpoint = fileEndpoint.endsWith("/") ? fileEndpoint.slice(0, -1) : fileEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 &&
        connectionString.search("AccountKey=") !== -1) {
        // Account connection string
        var defaultEndpointsProtocol = "";
        var accountName = "";
        var accountKey = Buffer.from("accountKey", "base64");
        var endpointSuffix = "";
        // Get account name and key
        accountName = getValueInConnString(connectionString, "AccountName");
        accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
        if (!fileEndpoint) {
            // FileEndpoint is not present in the Account connection string
            // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`
            defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
            var protocol = defaultEndpointsProtocol.toLowerCase();
            if (protocol !== "https" && protocol !== "http") {
                throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
            }
            endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
            if (!endpointSuffix) {
                throw new Error("Invalid EndpointSuffix in the provided Connection String");
            }
            fileEndpoint = defaultEndpointsProtocol + "://" + accountName + ".file." + endpointSuffix;
        }
        if (!accountName) {
            throw new Error("Invalid AccountName in the provided Connection String");
        }
        else if (accountKey.length === 0) {
            throw new Error("Invalid AccountKey in the provided Connection String");
        }
        return {
            kind: "AccountConnString",
            url: fileEndpoint,
            accountName: accountName,
            accountKey: accountKey
        };
    }
    else {
        // SAS connection string
        var accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
        var accountName = getAccountNameFromUrl(fileEndpoint);
        if (!fileEndpoint) {
            throw new Error("Invalid FileEndpoint in the provided SAS Connection String");
        }
        else if (!accountSas) {
            throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
        }
        return { kind: "SASConnString", url: fileEndpoint, accountName: accountName, accountSas: accountSas };
    }
}
/**
 * Internal escape method implemented Strategy Two mentioned in escapeURL() description.
 *
 * @param text -
 */
function escape(text) {
    return encodeURIComponent(text)
        .replace(/%2F/g, "/") // Don't escape for "/"
        .replace(/'/g, "%27") // Escape for "'"
        .replace(/\+/g, "%20")
        .replace(/%25/g, "%"); // Revert encoded "%"
}
/**
 * Append a string to URL path. Will remove duplicated "/" in front of the string
 * when URL path ends with a "/".
 *
 * @param url - Source URL string
 * @param name - String to be appended to URL
 * @returns An updated URL string
 */
function appendToURLPath(url, name) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var path = urlParsed.getPath();
    path = path ? (path.endsWith("/") ? "" + path + name : path + "/" + name) : name;
    urlParsed.setPath(path);
    return urlParsed.toString();
}
/**
 * Append a string to URL query.
 *
 * @param url - Source URL string.
 * @param queryParts - String to be appended to the URL query.
 * @returns An updated URL string.
 */
function appendToURLQuery(url, queryParts) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    var query = urlParsed.getQuery();
    if (query) {
        query += "&" + queryParts;
    }
    else {
        query = queryParts;
    }
    urlParsed.setQuery(query);
    return urlParsed.toString();
}
/**
 * Set URL parameter name and value. If name exists in URL parameters, old value
 * will be replaced by name key. If not provide value, the parameter will be deleted.
 *
 * @param url - Source URL string
 * @param name - Parameter name
 * @param value - Parameter value
 * @returns An updated URL string
 */
function setURLParameter(url, name, value) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    urlParsed.setQueryParameter(name, value);
    return urlParsed.toString();
}
/**
 * Get URL path from an URL string.
 *
 * @param url - Source URL string
 */
function getURLPath(url) {
    var urlParsed = coreHttp.URLBuilder.parse(url);
    return urlParsed.getPath();
}
/**
 * Get URL query key value pairs from an URL string.
 *
 * @param url -
 */
function getURLQueries(url) {
    var queryString = coreHttp.URLBuilder.parse(url).getQuery();
    if (!queryString) {
        return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substr(1) : queryString;
    var querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter(function (value) {
        var indexOfEqual = value.indexOf("=");
        var lastIndexOfEqual = value.lastIndexOf("=");
        return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual;
    });
    var queries = {};
    for (var _i = 0, querySubStrings_1 = querySubStrings; _i < querySubStrings_1.length; _i++) {
        var querySubString = querySubStrings_1[_i];
        var splitResults = querySubString.split("=");
        var key = splitResults[0];
        var value = splitResults[1];
        queries[key] = value;
    }
    return queries;
}
/**
 * Rounds a date off to seconds.
 *
 * @param date -
 * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;
 *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.
 * @returns Date string in ISO8061 format, with or without 7 milliseconds component
 */
function truncatedISO8061Date(date, withMilliseconds) {
    if (withMilliseconds === void 0) { withMilliseconds = true; }
    // Date.toISOString() will return like "2018-10-29T06:34:36.139Z"
    var dateString = date.toISOString();
    return withMilliseconds
        ? dateString.substring(0, dateString.length - 1) + "0000" + "Z"
        : dateString.substring(0, dateString.length - 5) + "Z";
}
/**
 * Delay specified time interval.
 *
 * @param timeInMs -
 * @param aborter -
 * @param abortError -
 */
function delay(timeInMs, aborter, abortError) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var timeout;
                    var abortHandler = function () {
                        if (timeout !== undefined) {
                            clearTimeout(timeout);
                        }
                        reject(abortError);
                    };
                    var resolveHandler = function () {
                        if (aborter !== undefined) {
                            aborter.removeEventListener("abort", abortHandler);
                        }
                        resolve();
                    };
                    timeout = setTimeout(resolveHandler, timeInMs);
                    if (aborter !== undefined) {
                        aborter.addEventListener("abort", abortHandler);
                    }
                })];
        });
    });
}
/**
 * Extracts account name from the url
 * @param url - url to extract the account name from
 * @returns with the account name
 */
function getAccountNameFromUrl(url) {
    var parsedUrl = coreHttp.URLBuilder.parse(url);
    var accountName;
    try {
        if (parsedUrl.getHost().split(".")[1] === "file") {
            // `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`;
            // Slicing off '/' at the end if exists
            url = url.endsWith("/") ? url.slice(0, -1) : url;
            accountName = parsedUrl.getHost().split(".")[0];
        }
        else if (isIpEndpointStyle(parsedUrl)) {
            // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/
            // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/
            // .getPath() -> /devstoreaccount1/
            accountName = parsedUrl.getPath().split("/")[1];
        }
        else {
            // Custom domain case: "https://customdomain.com/containername/blob".
            accountName = "";
        }
        return accountName;
    }
    catch (error) {
        throw new Error("Unable to extract accountName with provided information.");
    }
}
function isIpEndpointStyle(parsedUrl) {
    if (parsedUrl.getHost() == undefined) {
        return false;
    }
    var host = parsedUrl.getHost() + (parsedUrl.getPort() == undefined ? "" : ":" + parsedUrl.getPort());
    // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.
    // Case 2: localhost(:port), use broad regex to match port part.
    // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.
    // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.
    return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host);
}
function getShareNameAndPathFromUrl(url) {
    //  URL may look like the following
    // "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory/file";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory";
    // "https://myaccount.file.core.windows.net/myshare?sasString";
    // "https://myaccount.file.core.windows.net/myshare";
    // IPv4/IPv6 address hosts, Endpoints - `http://187.24.0.1:1000/devstoreaccount1/mydirectory/file`
    // http://localhost:1000/devstoreaccount1/mydirectory/file
    // mydirectory can consist of multiple directories - dir1/dir2/dir3
    var shareName;
    var path;
    var baseName;
    try {
        var parsedUrl = coreHttp.URLBuilder.parse(url);
        if (parsedUrl.getHost().split(".")[1] === "file") {
            // "https://myaccount.file.core.windows.net/myshare/mydirectory/file";
            // .getPath() -> /myshare/mydirectory/file
            var pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
            shareName = pathComponents[1];
            path = pathComponents[3];
        }
        else if (isIpEndpointStyle(parsedUrl)) {
            // IPv4/IPv6 address hosts... Example - http://187.24.0.1:1000/devstoreaccount1/mydirectory/file
            // Single word domain without a [dot] in the endpoint... Example - http://localhost:1000/devstoreaccount1/mydirectory/file
            // .getPath() -> /devstoreaccount1/mydirectory/file
            var pathComponents = parsedUrl.getPath().match("/([^/]*)/([^/]*)(/(.*))?");
            shareName = pathComponents[2];
            path = pathComponents[4];
        }
        else {
            // "https://customdomain.com/myshare/mydirectory/file";
            // .getPath() -> /myshare/mydirectory/file
            var pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
            shareName = pathComponents[1];
            path = pathComponents[3];
        }
        // decode the encoded shareName and filePath - to get all the special characters that might be present in it
        shareName = decodeURIComponent(shareName);
        path = decodeURIComponent(path);
        // Cast to string is required as TypeScript cannot infer that split() always returns
        // an array with length >= 1
        baseName = path.split("/").pop();
        if (!shareName) {
            throw new Error("Provided shareName is invalid.");
        }
        else {
            return { baseName: baseName, shareName: shareName, path: path };
        }
    }
    catch (error) {
        throw new Error("Unable to extract shareName and filePath/directoryPath with provided information.");
    }
}

// Copyright (c) Microsoft Corporation.
(function (SASProtocol) {
    /**
     * Protocol that allows HTTPS only
     */
    SASProtocol["Https"] = "https";
    /**
     * Protocol that allows both HTTPS and HTTP
     */
    SASProtocol["HttpsAndHttp"] = "https,http";
})(exports.SASProtocol || (exports.SASProtocol = {}));
/**
 * Represents the components that make up an Azure Storage SAS' query parameters. This type is not constructed directly
 * by the user; it is only generated by the {@link AccountSASSignatureValues} and {@link FileSASSignatureValues}
 * types. Once generated, it can be encoded into a {@code String} and appended to a URL directly (though caution should
 * be taken here in case there are existing query parameters, which might affect the appropriate means of appending
 * these query parameters).
 *
 * NOTE: Instances of this class are immutable.
 */
var SASQueryParameters = /** @class */ (function () {
    /**
     * Creates an instance of SASQueryParameters.
     *
     * @param version - Representing the storage version
     * @param signature - Representing the signature for the SAS token
     * @param permissions - Representing the storage permissions
     * @param services - Representing the storage services being accessed (only for Account SAS)
     * @param resourceTypes - Representing the storage resource types being accessed (only for Account SAS)
     * @param protocol - Representing the allowed HTTP protocol(s)
     * @param startsOn - Representing the start time for this SAS token
     * @param expiresOn - Representing the expiry time for this SAS token
     * @param ipRange - Representing the range of valid IP addresses for this SAS token
     * @param identifier - Representing the signed identifier (only for Service SAS)
     * @param resource - Representing the storage container or blob (only for Service SAS)
     * @param cacheControl - Representing the cache-control header (only for Blob/File Service SAS)
     * @param contentDisposition - Representing the content-disposition header (only for Blob/File Service SAS)
     * @param contentEncoding - Representing the content-encoding header (only for Blob/File Service SAS)
     * @param contentLanguage - Representing the content-language header (only for Blob/File Service SAS)
     * @param contentType - Representing the content-type header (only for Blob/File Service SAS)
     */
    function SASQueryParameters(version, signature, permissions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType) {
        this.version = version;
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn;
        this.permissions = permissions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.identifier = identifier;
        this.resource = resource;
        this.signature = signature;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
    }
    Object.defineProperty(SASQueryParameters.prototype, "ipRange", {
        /**
         * Optional. IP range allowed for this SAS.
         *
         * @readonly
         */
        get: function () {
            if (this.ipRangeInner) {
                return {
                    end: this.ipRangeInner.end,
                    start: this.ipRangeInner.start
                };
            }
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     */
    SASQueryParameters.prototype.toString = function () {
        var params = [
            "sv",
            "ss",
            "srt",
            "spr",
            "st",
            "se",
            "sip",
            "si",
            "sr",
            "sp",
            "sig",
            "rscc",
            "rscd",
            "rsce",
            "rscl",
            "rsct"
        ];
        var queries = [];
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            switch (param) {
                case "sv":
                    this.tryAppendQueryParameter(queries, param, this.version);
                    break;
                case "ss":
                    this.tryAppendQueryParameter(queries, param, this.services);
                    break;
                case "srt":
                    this.tryAppendQueryParameter(queries, param, this.resourceTypes);
                    break;
                case "spr":
                    this.tryAppendQueryParameter(queries, param, this.protocol);
                    break;
                case "st":
                    this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : undefined);
                    break;
                case "se":
                    this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : undefined);
                    break;
                case "sip":
                    this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
                    break;
                case "si":
                    this.tryAppendQueryParameter(queries, param, this.identifier);
                    break;
                case "sr":
                    this.tryAppendQueryParameter(queries, param, this.resource);
                    break;
                case "sp":
                    this.tryAppendQueryParameter(queries, param, this.permissions);
                    break;
                case "sig":
                    this.tryAppendQueryParameter(queries, param, this.signature);
                    break;
                case "rscc":
                    this.tryAppendQueryParameter(queries, param, this.cacheControl);
                    break;
                case "rscd":
                    this.tryAppendQueryParameter(queries, param, this.contentDisposition);
                    break;
                case "rsce":
                    this.tryAppendQueryParameter(queries, param, this.contentEncoding);
                    break;
                case "rscl":
                    this.tryAppendQueryParameter(queries, param, this.contentLanguage);
                    break;
                case "rsct":
                    this.tryAppendQueryParameter(queries, param, this.contentType);
                    break;
            }
        }
        return queries.join("&");
    };
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @param queries -
     * @param key -
     * @param value -
     */
    SASQueryParameters.prototype.tryAppendQueryParameter = function (queries, key, value) {
        if (!value) {
            return;
        }
        key = encodeURIComponent(key);
        value = encodeURIComponent(value);
        if (key.length > 0 && value.length > 0) {
            queries.push(key + "=" + value);
        }
    };
    return SASQueryParameters;
}());

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Generates a {@link SASQueryParameters} object which contains all SAS query parameters needed to make an actual
 * REST request.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 *
 * @param sharedKeyCredential -
 */
function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    var version = accountSASSignatureValues.version
        ? accountSASSignatureValues.version
        : SERVICE_VERSION;
    var parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString()).toString();
    var parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    var parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    var stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn
            ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false)
            : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        "" // Account SAS requires an additional newline character
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, parsedPermissions, parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a file. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
var FileSASPermissions = /** @class */ (function () {
    function FileSASPermissions() {
        /**
         * Specifies Read access granted.
         */
        this.read = false;
        /**
         * Specifies Create access granted.
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         */
        this.delete = false;
    }
    /**
     * Creates a FileSASPermissions from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    FileSASPermissions.parse = function (permissions) {
        var fileSASPermissions = new FileSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var char = permissions_1[_i];
            switch (char) {
                case "r":
                    fileSASPermissions.read = true;
                    break;
                case "c":
                    fileSASPermissions.create = true;
                    break;
                case "w":
                    fileSASPermissions.write = true;
                    break;
                case "d":
                    fileSASPermissions.delete = true;
                    break;
                default:
                    throw new RangeError("Invalid permission: " + char);
            }
        }
        return fileSASPermissions;
    };
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns A string which represents the FileSASPermissions
     */
    FileSASPermissions.prototype.toString = function () {
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        return permissions.join("");
    };
    return FileSASPermissions;
}());

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a share.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
var ShareSASPermissions = /** @class */ (function () {
    function ShareSASPermissions() {
        /**
         * Specifies Read access granted.
         */
        this.read = false;
        /**
         * Specifies Create access granted.
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         */
        this.delete = false;
        /**
         * Specifies List access granted.
         */
        this.list = false;
    }
    /**
     * Creates an {@link ShareSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    ShareSASPermissions.parse = function (permissions) {
        var shareSASPermissions = new ShareSASPermissions();
        for (var _i = 0, permissions_1 = permissions; _i < permissions_1.length; _i++) {
            var char = permissions_1[_i];
            switch (char) {
                case "r":
                    shareSASPermissions.read = true;
                    break;
                case "c":
                    shareSASPermissions.create = true;
                    break;
                case "w":
                    shareSASPermissions.write = true;
                    break;
                case "d":
                    shareSASPermissions.delete = true;
                    break;
                case "l":
                    shareSASPermissions.list = true;
                    break;
                default:
                    throw new RangeError("Invalid permission " + char);
            }
        }
        return shareSASPermissions;
    };
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     */
    ShareSASPermissions.prototype.toString = function () {
        var permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        return permissions.join("");
    };
    return ShareSASPermissions;
}());

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param fileSASSignatureValues -
 * @param sharedKeyCredential -
 */
function generateFileSASQueryParameters(fileSASSignatureValues, sharedKeyCredential) {
    if (!fileSASSignatureValues.identifier &&
        !(fileSASSignatureValues.permissions && fileSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for File SAS generation when 'identifier' is not provided.");
    }
    var version = fileSASSignatureValues.version ? fileSASSignatureValues.version : SERVICE_VERSION;
    var resource = "s";
    if (fileSASSignatureValues.filePath) {
        resource = "f";
    }
    var verifiedPermissions;
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (fileSASSignatureValues.permissions) {
        if (fileSASSignatureValues.filePath) {
            verifiedPermissions = FileSASPermissions.parse(fileSASSignatureValues.permissions.toString()).toString();
        }
        else {
            verifiedPermissions = ShareSASPermissions.parse(fileSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    var stringToSign = [
        verifiedPermissions,
        fileSASSignatureValues.startsOn
            ? truncatedISO8061Date(fileSASSignatureValues.startsOn, false)
            : "",
        fileSASSignatureValues.expiresOn
            ? truncatedISO8061Date(fileSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, fileSASSignatureValues.shareName, fileSASSignatureValues.filePath),
        fileSASSignatureValues.identifier,
        fileSASSignatureValues.ipRange ? ipRangeToString(fileSASSignatureValues.ipRange) : "",
        fileSASSignatureValues.protocol,
        version,
        fileSASSignatureValues.cacheControl,
        fileSASSignatureValues.contentDisposition,
        fileSASSignatureValues.contentEncoding,
        fileSASSignatureValues.contentLanguage,
        fileSASSignatureValues.contentType
    ].join("\n");
    var signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, fileSASSignatureValues.protocol, fileSASSignatureValues.startsOn, fileSASSignatureValues.expiresOn, fileSASSignatureValues.ipRange, fileSASSignatureValues.identifier, resource, fileSASSignatureValues.cacheControl, fileSASSignatureValues.contentDisposition, fileSASSignatureValues.contentEncoding, fileSASSignatureValues.contentLanguage, fileSASSignatureValues.contentType);
}
function getCanonicalName(accountName, shareName, filePath) {
    // Share: "/file/account/sharename"
    // File:  "/file/account/sharename/filename"
    // File:  "/file/account/sharename/directoryname/filename"
    var elements = ["/file/" + accountName + "/" + shareName];
    if (filePath) {
        elements.push("/" + filePath);
    }
    return elements.join("");
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var FileServiceProperties = {
    serializedName: "FileServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
        name: "Composite",
        className: "FileServiceProperties",
        modelProperties: {
            hourMetrics: {
                serializedName: "HourMetrics",
                xmlName: "HourMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            minuteMetrics: {
                serializedName: "MinuteMetrics",
                xmlName: "MinuteMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            cors: {
                serializedName: "Cors",
                xmlName: "Cors",
                xmlIsWrapped: true,
                xmlElementName: "CorsRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsRule"
                        }
                    }
                }
            },
            protocol: {
                serializedName: "Protocol",
                xmlName: "ProtocolSettings",
                type: {
                    name: "Composite",
                    className: "ShareProtocolSettings"
                }
            }
        }
    }
};
var Metrics = {
    serializedName: "Metrics",
    type: {
        name: "Composite",
        className: "Metrics",
        modelProperties: {
            version: {
                serializedName: "Version",
                required: true,
                xmlName: "Version",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "Enabled",
                required: true,
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            includeAPIs: {
                serializedName: "IncludeAPIs",
                xmlName: "IncludeAPIs",
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                serializedName: "RetentionPolicy",
                xmlName: "RetentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicy"
                }
            }
        }
    }
};
var RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
        name: "Composite",
        className: "RetentionPolicy",
        modelProperties: {
            enabled: {
                serializedName: "Enabled",
                required: true,
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            days: {
                constraints: {
                    InclusiveMaximum: 365,
                    InclusiveMinimum: 1
                },
                serializedName: "Days",
                xmlName: "Days",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var CorsRule = {
    serializedName: "CorsRule",
    type: {
        name: "Composite",
        className: "CorsRule",
        modelProperties: {
            allowedOrigins: {
                serializedName: "AllowedOrigins",
                required: true,
                xmlName: "AllowedOrigins",
                type: {
                    name: "String"
                }
            },
            allowedMethods: {
                serializedName: "AllowedMethods",
                required: true,
                xmlName: "AllowedMethods",
                type: {
                    name: "String"
                }
            },
            allowedHeaders: {
                serializedName: "AllowedHeaders",
                required: true,
                xmlName: "AllowedHeaders",
                type: {
                    name: "String"
                }
            },
            exposedHeaders: {
                serializedName: "ExposedHeaders",
                required: true,
                xmlName: "ExposedHeaders",
                type: {
                    name: "String"
                }
            },
            maxAgeInSeconds: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "MaxAgeInSeconds",
                required: true,
                xmlName: "MaxAgeInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var ShareProtocolSettings = {
    serializedName: "ShareProtocolSettings",
    xmlName: "ProtocolSettings",
    type: {
        name: "Composite",
        className: "ShareProtocolSettings",
        modelProperties: {
            smb: {
                serializedName: "Smb",
                xmlName: "SMB",
                type: {
                    name: "Composite",
                    className: "ShareSmbSettings"
                }
            }
        }
    }
};
var ShareSmbSettings = {
    serializedName: "ShareSmbSettings",
    xmlName: "SMB",
    type: {
        name: "Composite",
        className: "ShareSmbSettings",
        modelProperties: {
            multichannel: {
                serializedName: "Multichannel",
                xmlName: "Multichannel",
                type: {
                    name: "Composite",
                    className: "SmbMultichannel"
                }
            }
        }
    }
};
var SmbMultichannel = {
    serializedName: "SmbMultichannel",
    xmlName: "Multichannel",
    type: {
        name: "Composite",
        className: "SmbMultichannel",
        modelProperties: {
            enabled: {
                serializedName: "Enabled",
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var StorageError = {
    serializedName: "StorageError",
    type: {
        name: "Composite",
        className: "StorageError",
        modelProperties: {
            message: {
                serializedName: "Message",
                xmlName: "Message",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "Code",
                xmlName: "Code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ListSharesResponse = {
    serializedName: "ListSharesResponse",
    xmlName: "EnumerationResults",
    type: {
        name: "Composite",
        className: "ListSharesResponse",
        modelProperties: {
            serviceEndpoint: {
                serializedName: "ServiceEndpoint",
                required: true,
                xmlName: "ServiceEndpoint",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "Prefix",
                xmlName: "Prefix",
                type: {
                    name: "String"
                }
            },
            marker: {
                serializedName: "Marker",
                xmlName: "Marker",
                type: {
                    name: "String"
                }
            },
            maxResults: {
                serializedName: "MaxResults",
                xmlName: "MaxResults",
                type: {
                    name: "Number"
                }
            },
            shareItems: {
                serializedName: "ShareItems",
                xmlName: "Shares",
                xmlIsWrapped: true,
                xmlElementName: "Share",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ShareItemInternal"
                        }
                    }
                }
            },
            continuationToken: {
                serializedName: "NextMarker",
                required: true,
                xmlName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareItemInternal = {
    serializedName: "ShareItemInternal",
    xmlName: "Share",
    type: {
        name: "Composite",
        className: "ShareItemInternal",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                xmlName: "Name",
                type: {
                    name: "String"
                }
            },
            snapshot: {
                serializedName: "Snapshot",
                xmlName: "Snapshot",
                type: {
                    name: "String"
                }
            },
            deleted: {
                serializedName: "Deleted",
                xmlName: "Deleted",
                type: {
                    name: "Boolean"
                }
            },
            version: {
                serializedName: "Version",
                xmlName: "Version",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "Properties",
                xmlName: "Properties",
                type: {
                    name: "Composite",
                    className: "SharePropertiesInternal"
                }
            },
            metadata: {
                serializedName: "Metadata",
                xmlName: "Metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
var SharePropertiesInternal = {
    serializedName: "SharePropertiesInternal",
    type: {
        name: "Composite",
        className: "SharePropertiesInternal",
        modelProperties: {
            lastModified: {
                serializedName: "Last-Modified",
                required: true,
                xmlName: "Last-Modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "Etag",
                required: true,
                xmlName: "Etag",
                type: {
                    name: "String"
                }
            },
            quota: {
                serializedName: "Quota",
                required: true,
                xmlName: "Quota",
                type: {
                    name: "Number"
                }
            },
            provisionedIops: {
                serializedName: "ProvisionedIops",
                xmlName: "ProvisionedIops",
                type: {
                    name: "Number"
                }
            },
            provisionedIngressMBps: {
                serializedName: "ProvisionedIngressMBps",
                xmlName: "ProvisionedIngressMBps",
                type: {
                    name: "Number"
                }
            },
            provisionedEgressMBps: {
                serializedName: "ProvisionedEgressMBps",
                xmlName: "ProvisionedEgressMBps",
                type: {
                    name: "Number"
                }
            },
            nextAllowedQuotaDowngradeTime: {
                serializedName: "NextAllowedQuotaDowngradeTime",
                xmlName: "NextAllowedQuotaDowngradeTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            deletedTime: {
                serializedName: "DeletedTime",
                xmlName: "DeletedTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            remainingRetentionDays: {
                serializedName: "RemainingRetentionDays",
                xmlName: "RemainingRetentionDays",
                type: {
                    name: "Number"
                }
            },
            accessTier: {
                serializedName: "AccessTier",
                xmlName: "AccessTier",
                type: {
                    name: "String"
                }
            },
            accessTierChangeTime: {
                serializedName: "AccessTierChangeTime",
                xmlName: "AccessTierChangeTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            accessTierTransitionState: {
                serializedName: "AccessTierTransitionState",
                xmlName: "AccessTierTransitionState",
                type: {
                    name: "String"
                }
            },
            leaseStatus: {
                serializedName: "LeaseStatus",
                xmlName: "LeaseStatus",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            leaseState: {
                serializedName: "LeaseState",
                xmlName: "LeaseState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseDuration: {
                serializedName: "LeaseDuration",
                xmlName: "LeaseDuration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            enabledProtocols: {
                serializedName: "EnabledProtocols",
                xmlName: "EnabledProtocols",
                type: {
                    name: "String"
                }
            },
            rootSquash: {
                serializedName: "RootSquash",
                xmlName: "RootSquash",
                type: {
                    name: "Enum",
                    allowedValues: ["NoRootSquash", "RootSquash", "AllSquash"]
                }
            }
        }
    }
};
var SharePermission = {
    serializedName: "SharePermission",
    type: {
        name: "Composite",
        className: "SharePermission",
        modelProperties: {
            permission: {
                serializedName: "permission",
                required: true,
                xmlName: "permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SignedIdentifier = {
    serializedName: "SignedIdentifier",
    type: {
        name: "Composite",
        className: "SignedIdentifier",
        modelProperties: {
            id: {
                serializedName: "Id",
                required: true,
                xmlName: "Id",
                type: {
                    name: "String"
                }
            },
            accessPolicy: {
                serializedName: "AccessPolicy",
                xmlName: "AccessPolicy",
                type: {
                    name: "Composite",
                    className: "AccessPolicy"
                }
            }
        }
    }
};
var AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
        name: "Composite",
        className: "AccessPolicy",
        modelProperties: {
            startsOn: {
                serializedName: "Start",
                xmlName: "Start",
                type: {
                    name: "String"
                }
            },
            expiresOn: {
                serializedName: "Expiry",
                xmlName: "Expiry",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "Permission",
                xmlName: "Permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareStats = {
    serializedName: "ShareStats",
    type: {
        name: "Composite",
        className: "ShareStats",
        modelProperties: {
            shareUsageBytes: {
                serializedName: "ShareUsageBytes",
                required: true,
                xmlName: "ShareUsageBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var ListFilesAndDirectoriesSegmentResponse = {
    serializedName: "ListFilesAndDirectoriesSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
        name: "Composite",
        className: "ListFilesAndDirectoriesSegmentResponse",
        modelProperties: {
            serviceEndpoint: {
                serializedName: "ServiceEndpoint",
                required: true,
                xmlName: "ServiceEndpoint",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            shareName: {
                serializedName: "ShareName",
                required: true,
                xmlName: "ShareName",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            shareSnapshot: {
                serializedName: "ShareSnapshot",
                xmlName: "ShareSnapshot",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            directoryPath: {
                serializedName: "DirectoryPath",
                required: true,
                xmlName: "DirectoryPath",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "Prefix",
                required: true,
                xmlName: "Prefix",
                type: {
                    name: "String"
                }
            },
            marker: {
                serializedName: "Marker",
                xmlName: "Marker",
                type: {
                    name: "String"
                }
            },
            maxResults: {
                serializedName: "MaxResults",
                xmlName: "MaxResults",
                type: {
                    name: "Number"
                }
            },
            segment: {
                serializedName: "Segment",
                xmlName: "Entries",
                type: {
                    name: "Composite",
                    className: "FilesAndDirectoriesListSegment"
                }
            },
            continuationToken: {
                serializedName: "NextMarker",
                required: true,
                xmlName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FilesAndDirectoriesListSegment = {
    serializedName: "FilesAndDirectoriesListSegment",
    xmlName: "Entries",
    type: {
        name: "Composite",
        className: "FilesAndDirectoriesListSegment",
        modelProperties: {
            directoryItems: {
                serializedName: "DirectoryItems",
                required: true,
                xmlName: "DirectoryItems",
                xmlElementName: "Directory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DirectoryItem"
                        }
                    }
                }
            },
            fileItems: {
                serializedName: "FileItems",
                required: true,
                xmlName: "FileItems",
                xmlElementName: "File",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileItem"
                        }
                    }
                }
            }
        }
    }
};
var DirectoryItem = {
    serializedName: "DirectoryItem",
    xmlName: "Directory",
    type: {
        name: "Composite",
        className: "DirectoryItem",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                xmlName: "Name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileItem = {
    serializedName: "FileItem",
    xmlName: "File",
    type: {
        name: "Composite",
        className: "FileItem",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                xmlName: "Name",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "Properties",
                xmlName: "Properties",
                type: {
                    name: "Composite",
                    className: "FileProperty"
                }
            }
        }
    }
};
var FileProperty = {
    serializedName: "FileProperty",
    type: {
        name: "Composite",
        className: "FileProperty",
        modelProperties: {
            contentLength: {
                serializedName: "Content-Length",
                required: true,
                xmlName: "Content-Length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var ListHandlesResponse = {
    serializedName: "ListHandlesResponse",
    xmlName: "EnumerationResults",
    type: {
        name: "Composite",
        className: "ListHandlesResponse",
        modelProperties: {
            handleList: {
                serializedName: "HandleList",
                xmlName: "Entries",
                xmlIsWrapped: true,
                xmlElementName: "Handle",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandleItem"
                        }
                    }
                }
            },
            continuationToken: {
                serializedName: "NextMarker",
                required: true,
                xmlName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var HandleItem = {
    serializedName: "HandleItem",
    xmlName: "Handle",
    type: {
        name: "Composite",
        className: "HandleItem",
        modelProperties: {
            handleId: {
                serializedName: "HandleId",
                required: true,
                xmlName: "HandleId",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "Path",
                required: true,
                xmlName: "Path",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "FileId",
                required: true,
                xmlName: "FileId",
                type: {
                    name: "String"
                }
            },
            parentId: {
                serializedName: "ParentId",
                xmlName: "ParentId",
                type: {
                    name: "String"
                }
            },
            sessionId: {
                serializedName: "SessionId",
                required: true,
                xmlName: "SessionId",
                type: {
                    name: "String"
                }
            },
            clientIp: {
                serializedName: "ClientIp",
                required: true,
                xmlName: "ClientIp",
                type: {
                    name: "String"
                }
            },
            openTime: {
                serializedName: "OpenTime",
                required: true,
                xmlName: "OpenTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            lastReconnectTime: {
                serializedName: "LastReconnectTime",
                xmlName: "LastReconnectTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareFileRangeList = {
    serializedName: "ShareFileRangeList",
    type: {
        name: "Composite",
        className: "ShareFileRangeList",
        modelProperties: {
            ranges: {
                serializedName: "Ranges",
                xmlName: "Ranges",
                xmlElementName: "Range",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileRange"
                        }
                    }
                }
            },
            clearRanges: {
                serializedName: "ClearRanges",
                xmlName: "ClearRanges",
                xmlElementName: "ClearRange",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClearRange"
                        }
                    }
                }
            }
        }
    }
};
var FileRange = {
    serializedName: "FileRange",
    xmlName: "Range",
    type: {
        name: "Composite",
        className: "FileRange",
        modelProperties: {
            start: {
                serializedName: "Start",
                required: true,
                xmlName: "Start",
                type: {
                    name: "Number"
                }
            },
            end: {
                serializedName: "End",
                required: true,
                xmlName: "End",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
        name: "Composite",
        className: "ClearRange",
        modelProperties: {
            start: {
                serializedName: "Start",
                required: true,
                xmlName: "Start",
                type: {
                    name: "Number"
                }
            },
            end: {
                serializedName: "End",
                required: true,
                xmlName: "End",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceListSharesSegmentHeaders = {
    serializedName: "Service_listSharesSegmentHeaders",
    type: {
        name: "Composite",
        className: "ServiceListSharesSegmentHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ServiceListSharesSegmentExceptionHeaders = {
    serializedName: "Service_listSharesSegmentExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceListSharesSegmentExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreateHeaders = {
    serializedName: "Share_createHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreateExceptionHeaders = {
    serializedName: "Share_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetPropertiesHeaders = {
    serializedName: "Share_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPropertiesHeaders",
        modelProperties: {
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            quota: {
                serializedName: "x-ms-share-quota",
                xmlName: "x-ms-share-quota",
                type: {
                    name: "Number"
                }
            },
            provisionedIops: {
                serializedName: "x-ms-share-provisioned-iops",
                xmlName: "x-ms-share-provisioned-iops",
                type: {
                    name: "Number"
                }
            },
            provisionedIngressMBps: {
                serializedName: "x-ms-share-provisioned-ingress-mbps",
                xmlName: "x-ms-share-provisioned-ingress-mbps",
                type: {
                    name: "Number"
                }
            },
            provisionedEgressMBps: {
                serializedName: "x-ms-share-provisioned-egress-mbps",
                xmlName: "x-ms-share-provisioned-egress-mbps",
                type: {
                    name: "Number"
                }
            },
            nextAllowedQuotaDowngradeTime: {
                serializedName: "x-ms-share-next-allowed-quota-downgrade-time",
                xmlName: "x-ms-share-next-allowed-quota-downgrade-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                xmlName: "x-ms-lease-state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                xmlName: "x-ms-lease-status",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            accessTier: {
                serializedName: "x-ms-access-tier",
                xmlName: "x-ms-access-tier",
                type: {
                    name: "String"
                }
            },
            accessTierChangeTime: {
                serializedName: "x-ms-access-tier-change-time",
                xmlName: "x-ms-access-tier-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            accessTierTransitionState: {
                serializedName: "x-ms-access-tier-transition-state",
                xmlName: "x-ms-access-tier-transition-state",
                type: {
                    name: "String"
                }
            },
            enabledProtocols: {
                serializedName: "x-ms-enabled-protocols",
                xmlName: "x-ms-enabled-protocols",
                type: {
                    name: "String"
                }
            },
            rootSquash: {
                serializedName: "x-ms-root-squash",
                xmlName: "x-ms-root-squash",
                type: {
                    name: "Enum",
                    allowedValues: ["NoRootSquash", "RootSquash", "AllSquash"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetPropertiesExceptionHeaders = {
    serializedName: "Share_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareDeleteHeaders = {
    serializedName: "Share_deleteHeaders",
    type: {
        name: "Composite",
        className: "ShareDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareDeleteExceptionHeaders = {
    serializedName: "Share_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareAcquireLeaseHeaders = {
    serializedName: "Share_acquireLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareAcquireLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareAcquireLeaseExceptionHeaders = {
    serializedName: "Share_acquireLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareAcquireLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareReleaseLeaseHeaders = {
    serializedName: "Share_releaseLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareReleaseLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareReleaseLeaseExceptionHeaders = {
    serializedName: "Share_releaseLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareReleaseLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareChangeLeaseHeaders = {
    serializedName: "Share_changeLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareChangeLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareChangeLeaseExceptionHeaders = {
    serializedName: "Share_changeLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareChangeLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareRenewLeaseHeaders = {
    serializedName: "Share_renewLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareRenewLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareRenewLeaseExceptionHeaders = {
    serializedName: "Share_renewLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareRenewLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareBreakLeaseHeaders = {
    serializedName: "Share_breakLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareBreakLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseTimeInSeconds: {
                serializedName: "x-ms-lease-time",
                xmlName: "x-ms-lease-time",
                type: {
                    name: "Number"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareBreakLeaseExceptionHeaders = {
    serializedName: "Share_breakLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareBreakLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreateSnapshotHeaders = {
    serializedName: "Share_createSnapshotHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateSnapshotHeaders",
        modelProperties: {
            snapshot: {
                serializedName: "x-ms-snapshot",
                xmlName: "x-ms-snapshot",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreateSnapshotExceptionHeaders = {
    serializedName: "Share_createSnapshotExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateSnapshotExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreatePermissionHeaders = {
    serializedName: "Share_createPermissionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreatePermissionHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareCreatePermissionExceptionHeaders = {
    serializedName: "Share_createPermissionExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreatePermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetPermissionHeaders = {
    serializedName: "Share_getPermissionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPermissionHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetPermissionExceptionHeaders = {
    serializedName: "Share_getPermissionExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetPropertiesHeaders = {
    serializedName: "Share_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ShareSetPropertiesHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetPropertiesExceptionHeaders = {
    serializedName: "Share_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareSetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetMetadataHeaders = {
    serializedName: "Share_setMetadataHeaders",
    type: {
        name: "Composite",
        className: "ShareSetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetMetadataExceptionHeaders = {
    serializedName: "Share_setMetadataExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareSetMetadataExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetAccessPolicyHeaders = {
    serializedName: "Share_getAccessPolicyHeaders",
    type: {
        name: "Composite",
        className: "ShareGetAccessPolicyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetAccessPolicyExceptionHeaders = {
    serializedName: "Share_getAccessPolicyExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetAccessPolicyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetAccessPolicyHeaders = {
    serializedName: "Share_setAccessPolicyHeaders",
    type: {
        name: "Composite",
        className: "ShareSetAccessPolicyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareSetAccessPolicyExceptionHeaders = {
    serializedName: "Share_setAccessPolicyExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareSetAccessPolicyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetStatisticsHeaders = {
    serializedName: "Share_getStatisticsHeaders",
    type: {
        name: "Composite",
        className: "ShareGetStatisticsHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareGetStatisticsExceptionHeaders = {
    serializedName: "Share_getStatisticsExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetStatisticsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var ShareRestoreHeaders = {
    serializedName: "Share_restoreHeaders",
    type: {
        name: "Composite",
        className: "ShareRestoreHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var ShareRestoreExceptionHeaders = {
    serializedName: "Share_restoreExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareRestoreExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryCreateHeaders = {
    serializedName: "Directory_createHeaders",
    type: {
        name: "Composite",
        className: "DirectoryCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryCreateExceptionHeaders = {
    serializedName: "Directory_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryGetPropertiesHeaders = {
    serializedName: "Directory_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "DirectoryGetPropertiesHeaders",
        modelProperties: {
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                xmlName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryGetPropertiesExceptionHeaders = {
    serializedName: "Directory_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryDeleteHeaders = {
    serializedName: "Directory_deleteHeaders",
    type: {
        name: "Composite",
        className: "DirectoryDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryDeleteExceptionHeaders = {
    serializedName: "Directory_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectorySetPropertiesHeaders = {
    serializedName: "Directory_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetPropertiesHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectorySetPropertiesExceptionHeaders = {
    serializedName: "Directory_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectorySetMetadataHeaders = {
    serializedName: "Directory_setMetadataHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectorySetMetadataExceptionHeaders = {
    serializedName: "Directory_setMetadataExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetMetadataExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryListFilesAndDirectoriesSegmentHeaders = {
    serializedName: "Directory_listFilesAndDirectoriesSegmentHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListFilesAndDirectoriesSegmentHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryListFilesAndDirectoriesSegmentExceptionHeaders = {
    serializedName: "Directory_listFilesAndDirectoriesSegmentExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListFilesAndDirectoriesSegmentExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryListHandlesHeaders = {
    serializedName: "Directory_listHandlesHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListHandlesHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryListHandlesExceptionHeaders = {
    serializedName: "Directory_listHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryForceCloseHandlesHeaders = {
    serializedName: "Directory_forceCloseHandlesHeaders",
    type: {
        name: "Composite",
        className: "DirectoryForceCloseHandlesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            marker: {
                serializedName: "x-ms-marker",
                xmlName: "x-ms-marker",
                type: {
                    name: "String"
                }
            },
            numberOfHandlesClosed: {
                serializedName: "x-ms-number-of-handles-closed",
                xmlName: "x-ms-number-of-handles-closed",
                type: {
                    name: "Number"
                }
            },
            numberOfHandlesFailedToClose: {
                serializedName: "x-ms-number-of-handles-failed",
                xmlName: "x-ms-number-of-handles-failed",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DirectoryForceCloseHandlesExceptionHeaders = {
    serializedName: "Directory_forceCloseHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryForceCloseHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileCreateHeaders = {
    serializedName: "File_createHeaders",
    type: {
        name: "Composite",
        className: "FileCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileCreateExceptionHeaders = {
    serializedName: "File_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileDownloadHeaders = {
    serializedName: "File_downloadHeaders",
    type: {
        name: "Composite",
        className: "FileDownloadHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            contentLength: {
                serializedName: "content-length",
                xmlName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentRange: {
                serializedName: "content-range",
                xmlName: "content-range",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                xmlName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                xmlName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                xmlName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                xmlName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                xmlName: "content-language",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            acceptRanges: {
                serializedName: "accept-ranges",
                xmlName: "accept-ranges",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyCompletedOn: {
                serializedName: "x-ms-copy-completion-time",
                xmlName: "x-ms-copy-completion-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyStatusDescription: {
                serializedName: "x-ms-copy-status-description",
                xmlName: "x-ms-copy-status-description",
                type: {
                    name: "String"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                xmlName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyProgress: {
                serializedName: "x-ms-copy-progress",
                xmlName: "x-ms-copy-progress",
                type: {
                    name: "String"
                }
            },
            copySource: {
                serializedName: "x-ms-copy-source",
                xmlName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                xmlName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: ["pending", "success", "aborted", "failed"]
                }
            },
            fileContentMD5: {
                serializedName: "x-ms-content-md5",
                xmlName: "x-ms-content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                xmlName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                xmlName: "x-ms-lease-state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                xmlName: "x-ms-lease-status",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileDownloadExceptionHeaders = {
    serializedName: "File_downloadExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileDownloadExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileGetPropertiesHeaders = {
    serializedName: "File_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "FileGetPropertiesHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            fileType: {
                serializedName: "x-ms-type",
                xmlName: "x-ms-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                xmlName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                xmlName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                xmlName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                xmlName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                xmlName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                xmlName: "content-language",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyCompletedOn: {
                serializedName: "x-ms-copy-completion-time",
                xmlName: "x-ms-copy-completion-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyStatusDescription: {
                serializedName: "x-ms-copy-status-description",
                xmlName: "x-ms-copy-status-description",
                type: {
                    name: "String"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                xmlName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyProgress: {
                serializedName: "x-ms-copy-progress",
                xmlName: "x-ms-copy-progress",
                type: {
                    name: "String"
                }
            },
            copySource: {
                serializedName: "x-ms-copy-source",
                xmlName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                xmlName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: ["pending", "success", "aborted", "failed"]
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                xmlName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                xmlName: "x-ms-lease-state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                xmlName: "x-ms-lease-status",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileGetPropertiesExceptionHeaders = {
    serializedName: "File_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileDeleteHeaders = {
    serializedName: "File_deleteHeaders",
    type: {
        name: "Composite",
        className: "FileDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileDeleteExceptionHeaders = {
    serializedName: "File_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSetHttpHeadersHeaders = {
    serializedName: "File_setHttpHeadersHeaders",
    type: {
        name: "Composite",
        className: "FileSetHttpHeadersHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSetHttpHeadersExceptionHeaders = {
    serializedName: "File_setHttpHeadersExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileSetHttpHeadersExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSetMetadataHeaders = {
    serializedName: "File_setMetadataHeaders",
    type: {
        name: "Composite",
        className: "FileSetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileSetMetadataExceptionHeaders = {
    serializedName: "File_setMetadataExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileSetMetadataExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileAcquireLeaseHeaders = {
    serializedName: "File_acquireLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileAcquireLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var FileAcquireLeaseExceptionHeaders = {
    serializedName: "File_acquireLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileAcquireLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileReleaseLeaseHeaders = {
    serializedName: "File_releaseLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileReleaseLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var FileReleaseLeaseExceptionHeaders = {
    serializedName: "File_releaseLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileReleaseLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileChangeLeaseHeaders = {
    serializedName: "File_changeLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileChangeLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var FileChangeLeaseExceptionHeaders = {
    serializedName: "File_changeLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileChangeLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileBreakLeaseHeaders = {
    serializedName: "File_breakLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileBreakLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
var FileBreakLeaseExceptionHeaders = {
    serializedName: "File_breakLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileBreakLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileUploadRangeHeaders = {
    serializedName: "File_uploadRangeHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                xmlName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileUploadRangeExceptionHeaders = {
    serializedName: "File_uploadRangeExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileUploadRangeFromURLHeaders = {
    serializedName: "File_uploadRangeFromURLHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeFromURLHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            xMsContentCrc64: {
                serializedName: "x-ms-content-crc64",
                xmlName: "x-ms-content-crc64",
                type: {
                    name: "ByteArray"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileUploadRangeFromURLExceptionHeaders = {
    serializedName: "File_uploadRangeFromURLExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeFromURLExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileGetRangeListHeaders = {
    serializedName: "File_getRangeListHeaders",
    type: {
        name: "Composite",
        className: "FileGetRangeListHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            fileContentLength: {
                serializedName: "x-ms-content-length",
                xmlName: "x-ms-content-length",
                type: {
                    name: "Number"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileGetRangeListExceptionHeaders = {
    serializedName: "File_getRangeListExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileGetRangeListExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileStartCopyHeaders = {
    serializedName: "File_startCopyHeaders",
    type: {
        name: "Composite",
        className: "FileStartCopyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                xmlName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                xmlName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: ["pending", "success", "aborted", "failed"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileStartCopyExceptionHeaders = {
    serializedName: "File_startCopyExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileStartCopyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileAbortCopyHeaders = {
    serializedName: "File_abortCopyHeaders",
    type: {
        name: "Composite",
        className: "FileAbortCopyHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileAbortCopyExceptionHeaders = {
    serializedName: "File_abortCopyExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileAbortCopyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileListHandlesHeaders = {
    serializedName: "File_listHandlesHeaders",
    type: {
        name: "Composite",
        className: "FileListHandlesHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileListHandlesExceptionHeaders = {
    serializedName: "File_listHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileListHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileForceCloseHandlesHeaders = {
    serializedName: "File_forceCloseHandlesHeaders",
    type: {
        name: "Composite",
        className: "FileForceCloseHandlesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            marker: {
                serializedName: "x-ms-marker",
                xmlName: "x-ms-marker",
                type: {
                    name: "String"
                }
            },
            numberOfHandlesClosed: {
                serializedName: "x-ms-number-of-handles-closed",
                xmlName: "x-ms-number-of-handles-closed",
                type: {
                    name: "Number"
                }
            },
            numberOfHandlesFailedToClose: {
                serializedName: "x-ms-number-of-handles-failed",
                xmlName: "x-ms-number-of-handles-failed",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var FileForceCloseHandlesExceptionHeaders = {
    serializedName: "File_forceCloseHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileForceCloseHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FileServiceProperties: FileServiceProperties,
    Metrics: Metrics,
    RetentionPolicy: RetentionPolicy,
    CorsRule: CorsRule,
    ShareProtocolSettings: ShareProtocolSettings,
    ShareSmbSettings: ShareSmbSettings,
    SmbMultichannel: SmbMultichannel,
    StorageError: StorageError,
    ListSharesResponse: ListSharesResponse,
    ShareItemInternal: ShareItemInternal,
    SharePropertiesInternal: SharePropertiesInternal,
    SharePermission: SharePermission,
    SignedIdentifier: SignedIdentifier,
    AccessPolicy: AccessPolicy,
    ShareStats: ShareStats,
    ListFilesAndDirectoriesSegmentResponse: ListFilesAndDirectoriesSegmentResponse,
    FilesAndDirectoriesListSegment: FilesAndDirectoriesListSegment,
    DirectoryItem: DirectoryItem,
    FileItem: FileItem,
    FileProperty: FileProperty,
    ListHandlesResponse: ListHandlesResponse,
    HandleItem: HandleItem,
    ShareFileRangeList: ShareFileRangeList,
    FileRange: FileRange,
    ClearRange: ClearRange,
    ServiceSetPropertiesHeaders: ServiceSetPropertiesHeaders,
    ServiceSetPropertiesExceptionHeaders: ServiceSetPropertiesExceptionHeaders,
    ServiceGetPropertiesHeaders: ServiceGetPropertiesHeaders,
    ServiceGetPropertiesExceptionHeaders: ServiceGetPropertiesExceptionHeaders,
    ServiceListSharesSegmentHeaders: ServiceListSharesSegmentHeaders,
    ServiceListSharesSegmentExceptionHeaders: ServiceListSharesSegmentExceptionHeaders,
    ShareCreateHeaders: ShareCreateHeaders,
    ShareCreateExceptionHeaders: ShareCreateExceptionHeaders,
    ShareGetPropertiesHeaders: ShareGetPropertiesHeaders,
    ShareGetPropertiesExceptionHeaders: ShareGetPropertiesExceptionHeaders,
    ShareDeleteHeaders: ShareDeleteHeaders,
    ShareDeleteExceptionHeaders: ShareDeleteExceptionHeaders,
    ShareAcquireLeaseHeaders: ShareAcquireLeaseHeaders,
    ShareAcquireLeaseExceptionHeaders: ShareAcquireLeaseExceptionHeaders,
    ShareReleaseLeaseHeaders: ShareReleaseLeaseHeaders,
    ShareReleaseLeaseExceptionHeaders: ShareReleaseLeaseExceptionHeaders,
    ShareChangeLeaseHeaders: ShareChangeLeaseHeaders,
    ShareChangeLeaseExceptionHeaders: ShareChangeLeaseExceptionHeaders,
    ShareRenewLeaseHeaders: ShareRenewLeaseHeaders,
    ShareRenewLeaseExceptionHeaders: ShareRenewLeaseExceptionHeaders,
    ShareBreakLeaseHeaders: ShareBreakLeaseHeaders,
    ShareBreakLeaseExceptionHeaders: ShareBreakLeaseExceptionHeaders,
    ShareCreateSnapshotHeaders: ShareCreateSnapshotHeaders,
    ShareCreateSnapshotExceptionHeaders: ShareCreateSnapshotExceptionHeaders,
    ShareCreatePermissionHeaders: ShareCreatePermissionHeaders,
    ShareCreatePermissionExceptionHeaders: ShareCreatePermissionExceptionHeaders,
    ShareGetPermissionHeaders: ShareGetPermissionHeaders,
    ShareGetPermissionExceptionHeaders: ShareGetPermissionExceptionHeaders,
    ShareSetPropertiesHeaders: ShareSetPropertiesHeaders,
    ShareSetPropertiesExceptionHeaders: ShareSetPropertiesExceptionHeaders,
    ShareSetMetadataHeaders: ShareSetMetadataHeaders,
    ShareSetMetadataExceptionHeaders: ShareSetMetadataExceptionHeaders,
    ShareGetAccessPolicyHeaders: ShareGetAccessPolicyHeaders,
    ShareGetAccessPolicyExceptionHeaders: ShareGetAccessPolicyExceptionHeaders,
    ShareSetAccessPolicyHeaders: ShareSetAccessPolicyHeaders,
    ShareSetAccessPolicyExceptionHeaders: ShareSetAccessPolicyExceptionHeaders,
    ShareGetStatisticsHeaders: ShareGetStatisticsHeaders,
    ShareGetStatisticsExceptionHeaders: ShareGetStatisticsExceptionHeaders,
    ShareRestoreHeaders: ShareRestoreHeaders,
    ShareRestoreExceptionHeaders: ShareRestoreExceptionHeaders,
    DirectoryCreateHeaders: DirectoryCreateHeaders,
    DirectoryCreateExceptionHeaders: DirectoryCreateExceptionHeaders,
    DirectoryGetPropertiesHeaders: DirectoryGetPropertiesHeaders,
    DirectoryGetPropertiesExceptionHeaders: DirectoryGetPropertiesExceptionHeaders,
    DirectoryDeleteHeaders: DirectoryDeleteHeaders,
    DirectoryDeleteExceptionHeaders: DirectoryDeleteExceptionHeaders,
    DirectorySetPropertiesHeaders: DirectorySetPropertiesHeaders,
    DirectorySetPropertiesExceptionHeaders: DirectorySetPropertiesExceptionHeaders,
    DirectorySetMetadataHeaders: DirectorySetMetadataHeaders,
    DirectorySetMetadataExceptionHeaders: DirectorySetMetadataExceptionHeaders,
    DirectoryListFilesAndDirectoriesSegmentHeaders: DirectoryListFilesAndDirectoriesSegmentHeaders,
    DirectoryListFilesAndDirectoriesSegmentExceptionHeaders: DirectoryListFilesAndDirectoriesSegmentExceptionHeaders,
    DirectoryListHandlesHeaders: DirectoryListHandlesHeaders,
    DirectoryListHandlesExceptionHeaders: DirectoryListHandlesExceptionHeaders,
    DirectoryForceCloseHandlesHeaders: DirectoryForceCloseHandlesHeaders,
    DirectoryForceCloseHandlesExceptionHeaders: DirectoryForceCloseHandlesExceptionHeaders,
    FileCreateHeaders: FileCreateHeaders,
    FileCreateExceptionHeaders: FileCreateExceptionHeaders,
    FileDownloadHeaders: FileDownloadHeaders,
    FileDownloadExceptionHeaders: FileDownloadExceptionHeaders,
    FileGetPropertiesHeaders: FileGetPropertiesHeaders,
    FileGetPropertiesExceptionHeaders: FileGetPropertiesExceptionHeaders,
    FileDeleteHeaders: FileDeleteHeaders,
    FileDeleteExceptionHeaders: FileDeleteExceptionHeaders,
    FileSetHttpHeadersHeaders: FileSetHttpHeadersHeaders,
    FileSetHttpHeadersExceptionHeaders: FileSetHttpHeadersExceptionHeaders,
    FileSetMetadataHeaders: FileSetMetadataHeaders,
    FileSetMetadataExceptionHeaders: FileSetMetadataExceptionHeaders,
    FileAcquireLeaseHeaders: FileAcquireLeaseHeaders,
    FileAcquireLeaseExceptionHeaders: FileAcquireLeaseExceptionHeaders,
    FileReleaseLeaseHeaders: FileReleaseLeaseHeaders,
    FileReleaseLeaseExceptionHeaders: FileReleaseLeaseExceptionHeaders,
    FileChangeLeaseHeaders: FileChangeLeaseHeaders,
    FileChangeLeaseExceptionHeaders: FileChangeLeaseExceptionHeaders,
    FileBreakLeaseHeaders: FileBreakLeaseHeaders,
    FileBreakLeaseExceptionHeaders: FileBreakLeaseExceptionHeaders,
    FileUploadRangeHeaders: FileUploadRangeHeaders,
    FileUploadRangeExceptionHeaders: FileUploadRangeExceptionHeaders,
    FileUploadRangeFromURLHeaders: FileUploadRangeFromURLHeaders,
    FileUploadRangeFromURLExceptionHeaders: FileUploadRangeFromURLExceptionHeaders,
    FileGetRangeListHeaders: FileGetRangeListHeaders,
    FileGetRangeListExceptionHeaders: FileGetRangeListExceptionHeaders,
    FileStartCopyHeaders: FileStartCopyHeaders,
    FileStartCopyExceptionHeaders: FileStartCopyExceptionHeaders,
    FileAbortCopyHeaders: FileAbortCopyHeaders,
    FileAbortCopyExceptionHeaders: FileAbortCopyExceptionHeaders,
    FileListHandlesHeaders: FileListHandlesHeaders,
    FileListHandlesExceptionHeaders: FileListHandlesExceptionHeaders,
    FileForceCloseHandlesHeaders: FileForceCloseHandlesHeaders,
    FileForceCloseHandlesExceptionHeaders: FileForceCloseHandlesExceptionHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
var properties = {
    parameterPath: "properties",
    mapper: FileServiceProperties
};
var accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
var url = {
    parameterPath: "url",
    mapper: {
        serializedName: "url",
        required: true,
        xmlName: "url",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
var restype = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "service",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
var comp = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "properties",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "timeout",
        xmlName: "timeout",
        type: {
            name: "Number"
        }
    }
};
var version = {
    parameterPath: "version",
    mapper: {
        defaultValue: "2020-06-12",
        isConstant: true,
        serializedName: "x-ms-version",
        type: {
            name: "String"
        }
    }
};
var accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
var comp1 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "list",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
        serializedName: "prefix",
        xmlName: "prefix",
        type: {
            name: "String"
        }
    }
};
var marker = {
    parameterPath: ["options", "marker"],
    mapper: {
        serializedName: "marker",
        xmlName: "marker",
        type: {
            name: "String"
        }
    }
};
var maxResults = {
    parameterPath: ["options", "maxResults"],
    mapper: {
        constraints: {
            InclusiveMinimum: 1
        },
        serializedName: "maxresults",
        xmlName: "maxresults",
        type: {
            name: "Number"
        }
    }
};
var include = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "include",
        xmlName: "include",
        xmlElementName: "ListSharesIncludeType",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Enum",
                    allowedValues: ["snapshots", "metadata", "deleted"]
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
var restype1 = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "share",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
var metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
        serializedName: "x-ms-meta",
        xmlName: "x-ms-meta",
        type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
        },
        headerCollectionPrefix: "x-ms-meta-"
    }
};
var quota = {
    parameterPath: ["options", "quota"],
    mapper: {
        constraints: {
            InclusiveMinimum: 1
        },
        serializedName: "x-ms-share-quota",
        xmlName: "x-ms-share-quota",
        type: {
            name: "Number"
        }
    }
};
var accessTier = {
    parameterPath: ["options", "accessTier"],
    mapper: {
        serializedName: "x-ms-access-tier",
        xmlName: "x-ms-access-tier",
        type: {
            name: "Enum",
            allowedValues: ["TransactionOptimized", "Hot", "Cool"]
        }
    }
};
var enabledProtocols = {
    parameterPath: ["options", "enabledProtocols"],
    mapper: {
        serializedName: "x-ms-enabled-protocols",
        xmlName: "x-ms-enabled-protocols",
        type: {
            name: "String"
        }
    }
};
var rootSquash = {
    parameterPath: ["options", "rootSquash"],
    mapper: {
        serializedName: "x-ms-root-squash",
        xmlName: "x-ms-root-squash",
        type: {
            name: "Enum",
            allowedValues: ["NoRootSquash", "RootSquash", "AllSquash"]
        }
    }
};
var shareSnapshot = {
    parameterPath: ["options", "shareSnapshot"],
    mapper: {
        serializedName: "sharesnapshot",
        xmlName: "sharesnapshot",
        type: {
            name: "String"
        }
    }
};
var leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
            name: "String"
        }
    }
};
var deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
        serializedName: "x-ms-delete-snapshots",
        xmlName: "x-ms-delete-snapshots",
        type: {
            name: "Enum",
            allowedValues: ["include", "include-leased"]
        }
    }
};
var comp2 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "lease",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var action = {
    parameterPath: "action",
    mapper: {
        defaultValue: "acquire",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
var duration = {
    parameterPath: ["options", "duration"],
    mapper: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
            name: "Number"
        }
    }
};
var proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
        serializedName: "x-ms-proposed-lease-id",
        xmlName: "x-ms-proposed-lease-id",
        type: {
            name: "String"
        }
    }
};
var requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
            name: "String"
        }
    }
};
var action1 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "release",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
var leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
        serializedName: "x-ms-lease-id",
        required: true,
        xmlName: "x-ms-lease-id",
        type: {
            name: "String"
        }
    }
};
var action2 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "change",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
var action3 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "renew",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
var action4 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "break",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
var breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
        serializedName: "x-ms-lease-break-period",
        xmlName: "x-ms-lease-break-period",
        type: {
            name: "Number"
        }
    }
};
var comp3 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "snapshot",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var sharePermission = {
    parameterPath: "sharePermission",
    mapper: SharePermission
};
var comp4 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "filepermission",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
var filePermissionKey = {
    parameterPath: "filePermissionKey",
    mapper: {
        serializedName: "x-ms-file-permission-key",
        required: true,
        xmlName: "x-ms-file-permission-key",
        type: {
            name: "String"
        }
    }
};
var comp5 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "metadata",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var comp6 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "acl",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var shareAcl = {
    parameterPath: ["options", "shareAcl"],
    mapper: {
        serializedName: "shareAcl",
        xmlName: "SignedIdentifiers",
        xmlIsWrapped: true,
        xmlElementName: "SignedIdentifier",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "SignedIdentifier"
                }
            }
        }
    }
};
var comp7 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "stats",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var comp8 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "undelete",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var deletedShareName = {
    parameterPath: ["options", "deletedShareName"],
    mapper: {
        serializedName: "x-ms-deleted-share-name",
        xmlName: "x-ms-deleted-share-name",
        type: {
            name: "String"
        }
    }
};
var deletedShareVersion = {
    parameterPath: ["options", "deletedShareVersion"],
    mapper: {
        serializedName: "x-ms-deleted-share-version",
        xmlName: "x-ms-deleted-share-version",
        type: {
            name: "String"
        }
    }
};
var restype2 = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "directory",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
var filePermission = {
    parameterPath: ["options", "filePermission"],
    mapper: {
        serializedName: "x-ms-file-permission",
        xmlName: "x-ms-file-permission",
        type: {
            name: "String"
        }
    }
};
var filePermissionKey1 = {
    parameterPath: ["options", "filePermissionKey"],
    mapper: {
        serializedName: "x-ms-file-permission-key",
        xmlName: "x-ms-file-permission-key",
        type: {
            name: "String"
        }
    }
};
var fileAttributes = {
    parameterPath: "fileAttributes",
    mapper: {
        serializedName: "x-ms-file-attributes",
        required: true,
        xmlName: "x-ms-file-attributes",
        type: {
            name: "String"
        }
    }
};
var fileCreatedOn = {
    parameterPath: "fileCreatedOn",
    mapper: {
        serializedName: "x-ms-file-creation-time",
        required: true,
        xmlName: "x-ms-file-creation-time",
        type: {
            name: "String"
        }
    }
};
var fileLastWriteOn = {
    parameterPath: "fileLastWriteOn",
    mapper: {
        serializedName: "x-ms-file-last-write-time",
        required: true,
        xmlName: "x-ms-file-last-write-time",
        type: {
            name: "String"
        }
    }
};
var comp9 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "listhandles",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var recursive = {
    parameterPath: ["options", "recursive"],
    mapper: {
        serializedName: "x-ms-recursive",
        xmlName: "x-ms-recursive",
        type: {
            name: "Boolean"
        }
    }
};
var comp10 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "forceclosehandles",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var handleId = {
    parameterPath: "handleId",
    mapper: {
        serializedName: "x-ms-handle-id",
        required: true,
        xmlName: "x-ms-handle-id",
        type: {
            name: "String"
        }
    }
};
var fileContentLength = {
    parameterPath: "fileContentLength",
    mapper: {
        serializedName: "x-ms-content-length",
        required: true,
        xmlName: "x-ms-content-length",
        type: {
            name: "Number"
        }
    }
};
var fileTypeConstant = {
    parameterPath: "fileTypeConstant",
    mapper: {
        defaultValue: "file",
        isConstant: true,
        serializedName: "x-ms-type",
        type: {
            name: "String"
        }
    }
};
var fileContentType = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentType"],
    mapper: {
        serializedName: "x-ms-content-type",
        xmlName: "x-ms-content-type",
        type: {
            name: "String"
        }
    }
};
var fileContentEncoding = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentEncoding"],
    mapper: {
        serializedName: "x-ms-content-encoding",
        xmlName: "x-ms-content-encoding",
        type: {
            name: "String"
        }
    }
};
var fileContentLanguage = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentLanguage"],
    mapper: {
        serializedName: "x-ms-content-language",
        xmlName: "x-ms-content-language",
        type: {
            name: "String"
        }
    }
};
var fileCacheControl = {
    parameterPath: ["options", "fileHttpHeaders", "fileCacheControl"],
    mapper: {
        serializedName: "x-ms-cache-control",
        xmlName: "x-ms-cache-control",
        type: {
            name: "String"
        }
    }
};
var fileContentMD5 = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentMD5"],
    mapper: {
        serializedName: "x-ms-content-md5",
        xmlName: "x-ms-content-md5",
        type: {
            name: "ByteArray"
        }
    }
};
var fileContentDisposition = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentDisposition"],
    mapper: {
        serializedName: "x-ms-content-disposition",
        xmlName: "x-ms-content-disposition",
        type: {
            name: "String"
        }
    }
};
var range = {
    parameterPath: ["options", "range"],
    mapper: {
        serializedName: "x-ms-range",
        xmlName: "x-ms-range",
        type: {
            name: "String"
        }
    }
};
var rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
        serializedName: "x-ms-range-get-content-md5",
        xmlName: "x-ms-range-get-content-md5",
        type: {
            name: "Boolean"
        }
    }
};
var fileContentLength1 = {
    parameterPath: ["options", "fileContentLength"],
    mapper: {
        serializedName: "x-ms-content-length",
        xmlName: "x-ms-content-length",
        type: {
            name: "Number"
        }
    }
};
var contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
var body = {
    parameterPath: ["options", "body"],
    mapper: {
        serializedName: "body",
        xmlName: "body",
        type: {
            name: "Stream"
        }
    }
};
var accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
var comp11 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "range",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var range1 = {
    parameterPath: "range",
    mapper: {
        serializedName: "x-ms-range",
        required: true,
        xmlName: "x-ms-range",
        type: {
            name: "String"
        }
    }
};
var fileRangeWrite = {
    parameterPath: "fileRangeWrite",
    mapper: {
        defaultValue: "update",
        serializedName: "x-ms-write",
        required: true,
        xmlName: "x-ms-write",
        type: {
            name: "Enum",
            allowedValues: ["update", "clear"]
        }
    }
};
var contentLength = {
    parameterPath: "contentLength",
    mapper: {
        serializedName: "Content-Length",
        required: true,
        xmlName: "Content-Length",
        type: {
            name: "Number"
        }
    }
};
var contentMD5 = {
    parameterPath: ["options", "contentMD5"],
    mapper: {
        serializedName: "Content-MD5",
        xmlName: "Content-MD5",
        type: {
            name: "ByteArray"
        }
    }
};
var copySource = {
    parameterPath: "copySource",
    mapper: {
        serializedName: "x-ms-copy-source",
        required: true,
        xmlName: "x-ms-copy-source",
        type: {
            name: "String"
        }
    }
};
var sourceRange = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
        serializedName: "x-ms-source-range",
        xmlName: "x-ms-source-range",
        type: {
            name: "String"
        }
    }
};
var fileRangeWriteFromUrl = {
    parameterPath: "fileRangeWriteFromUrl",
    mapper: {
        defaultValue: "update",
        isConstant: true,
        serializedName: "x-ms-write",
        type: {
            name: "String"
        }
    }
};
var sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
        serializedName: "x-ms-source-content-crc64",
        xmlName: "x-ms-source-content-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
var sourceIfMatchCrc64 = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfMatchCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-if-match-crc64",
        xmlName: "x-ms-source-if-match-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
var sourceIfNoneMatchCrc64 = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfNoneMatchCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-if-none-match-crc64",
        xmlName: "x-ms-source-if-none-match-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
var comp12 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "rangelist",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var prevsharesnapshot = {
    parameterPath: ["options", "prevsharesnapshot"],
    mapper: {
        serializedName: "prevsharesnapshot",
        xmlName: "prevsharesnapshot",
        type: {
            name: "String"
        }
    }
};
var filePermissionCopyMode = {
    parameterPath: ["options", "copyFileSmbInfo", "filePermissionCopyMode"],
    mapper: {
        serializedName: "x-ms-file-permission-copy-mode",
        xmlName: "x-ms-file-permission-copy-mode",
        type: {
            name: "Enum",
            allowedValues: ["source", "override"]
        }
    }
};
var ignoreReadOnly = {
    parameterPath: ["options", "copyFileSmbInfo", "ignoreReadOnly"],
    mapper: {
        serializedName: "x-ms-file-copy-ignore-read-only",
        xmlName: "x-ms-file-copy-ignore-read-only",
        type: {
            name: "Boolean"
        }
    }
};
var fileAttributes1 = {
    parameterPath: ["options", "copyFileSmbInfo", "fileAttributes"],
    mapper: {
        serializedName: "x-ms-file-attributes",
        xmlName: "x-ms-file-attributes",
        type: {
            name: "String"
        }
    }
};
var fileCreationTime = {
    parameterPath: ["options", "copyFileSmbInfo", "fileCreationTime"],
    mapper: {
        serializedName: "x-ms-file-creation-time",
        xmlName: "x-ms-file-creation-time",
        type: {
            name: "String"
        }
    }
};
var fileLastWriteTime = {
    parameterPath: ["options", "copyFileSmbInfo", "fileLastWriteTime"],
    mapper: {
        serializedName: "x-ms-file-last-write-time",
        xmlName: "x-ms-file-last-write-time",
        type: {
            name: "String"
        }
    }
};
var setArchiveAttribute = {
    parameterPath: ["options", "copyFileSmbInfo", "setArchiveAttribute"],
    mapper: {
        serializedName: "x-ms-file-copy-set-archive",
        xmlName: "x-ms-file-copy-set-archive",
        type: {
            name: "Boolean"
        }
    }
};
var comp13 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "copy",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
var copyId = {
    parameterPath: "copyId",
    mapper: {
        serializedName: "copyid",
        required: true,
        xmlName: "copyid",
        type: {
            name: "String"
        }
    }
};
var copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
        defaultValue: "abort",
        isConstant: true,
        serializedName: "x-ms-copy-action",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Service. */
var Service = /** @class */ (function () {
    /**
     * Initialize a new instance of the class Service class.
     * @param client Reference to the service client
     */
    function Service(client) {
        this.client = client;
    }
    /**
     * Sets properties for a storage account's File service endpoint, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     * @param properties The StorageService properties.
     * @param options The options parameters.
     */
    Service.prototype.setProperties = function (properties, options) {
        var operationArguments = {
            properties: properties,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec);
    };
    /**
     * Gets the properties of a storage account's File service, including properties for Storage Analytics
     * metrics and CORS (Cross-Origin Resource Sharing) rules.
     * @param options The options parameters.
     */
    Service.prototype.getProperties = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec);
    };
    /**
     * The List Shares Segment operation returns a list of the shares and share snapshots under the
     * specified account.
     * @param options The options parameters.
     */
    Service.prototype.listSharesSegment = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listSharesSegmentOperationSpec);
    };
    return Service;
}());
// Operation Specifications
var xmlSerializer = new coreHttp.Serializer(Mappers, /* isXml */ true);
var setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: ServiceSetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceSetPropertiesExceptionHeaders
        }
    },
    requestBody: properties,
    queryParameters: [
        restype,
        comp,
        timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
        contentType,
        accept,
        version
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
};
var getPropertiesOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileServiceProperties,
            headersMapper: ServiceGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        restype,
        comp,
        timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer
};
var listSharesSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSharesResponse,
            headersMapper: ServiceListSharesSegmentHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceListSharesSegmentExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp1,
        prefix,
        marker,
        maxResults,
        include
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Share. */
var Share = /** @class */ (function () {
    /**
     * Initialize a new instance of the class Share class.
     * @param client Reference to the service client
     */
    function Share(client) {
        this.client = client;
    }
    /**
     * Creates a new share under the specified account. If the share with the same name already exists, the
     * operation fails.
     * @param options The options parameters.
     */
    Share.prototype.create = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec);
    };
    /**
     * Returns all user-defined metadata and system properties for the specified share or share snapshot.
     * The data returned does not include the share's list of files.
     * @param options The options parameters.
     */
    Share.prototype.getProperties = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec$1);
    };
    /**
     * Operation marks the specified share or share snapshot for deletion. The share or share snapshot and
     * any files contained within it are later deleted during garbage collection.
     * @param options The options parameters.
     */
    Share.prototype.delete = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec);
    };
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param options The options parameters.
     */
    Share.prototype.acquireLease = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, acquireLeaseOperationSpec);
    };
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    Share.prototype.releaseLease = function (leaseId, options) {
        var operationArguments = {
            leaseId: leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, releaseLeaseOperationSpec);
    };
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    Share.prototype.changeLease = function (leaseId, options) {
        var operationArguments = {
            leaseId: leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, changeLeaseOperationSpec);
    };
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    Share.prototype.renewLease = function (leaseId, options) {
        var operationArguments = {
            leaseId: leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, renewLeaseOperationSpec);
    };
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param options The options parameters.
     */
    Share.prototype.breakLease = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, breakLeaseOperationSpec);
    };
    /**
     * Creates a read-only snapshot of a share.
     * @param options The options parameters.
     */
    Share.prototype.createSnapshot = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createSnapshotOperationSpec);
    };
    /**
     * Create a permission (a security descriptor).
     * @param sharePermission A permission (a security descriptor) at the share level.
     * @param options The options parameters.
     */
    Share.prototype.createPermission = function (sharePermission, options) {
        var operationArguments = {
            sharePermission: sharePermission,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createPermissionOperationSpec);
    };
    /**
     * Returns the permission (security descriptor) for a given key
     * @param filePermissionKey Key of the permission to be set for the directory/file.
     * @param options The options parameters.
     */
    Share.prototype.getPermission = function (filePermissionKey, options) {
        var operationArguments = {
            filePermissionKey: filePermissionKey,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPermissionOperationSpec);
    };
    /**
     * Sets properties for the specified share.
     * @param options The options parameters.
     */
    Share.prototype.setProperties = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec$1);
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     * @param options The options parameters.
     */
    Share.prototype.setMetadata = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec);
    };
    /**
     * Returns information about stored access policies specified on the share.
     * @param options The options parameters.
     */
    Share.prototype.getAccessPolicy = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getAccessPolicyOperationSpec);
    };
    /**
     * Sets a stored access policy for use with shared access signatures.
     * @param options The options parameters.
     */
    Share.prototype.setAccessPolicy = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setAccessPolicyOperationSpec);
    };
    /**
     * Retrieves statistics related to the share.
     * @param options The options parameters.
     */
    Share.prototype.getStatistics = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getStatisticsOperationSpec);
    };
    /**
     * Restores a previously deleted Share.
     * @param options The options parameters.
     */
    Share.prototype.restore = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, restoreOperationSpec);
    };
    return Share;
}());
// Operation Specifications
var xmlSerializer$1 = new coreHttp.Serializer(Mappers, /* isXml */ true);
var serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
var createOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreateExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, restype1],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        quota,
        accessTier,
        enabledProtocols,
        rootSquash
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var getPropertiesOperationSpec$1 = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            headersMapper: ShareGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var deleteOperationSpec = {
    path: "/{shareName}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: ShareDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareDeleteExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var acquireLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareAcquireLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareAcquireLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        action,
        duration,
        proposedLeaseId,
        requestId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var releaseLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareReleaseLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareReleaseLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        action1,
        leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var changeLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareChangeLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareChangeLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        proposedLeaseId,
        requestId,
        leaseId1,
        action2
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var renewLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareRenewLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareRenewLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        leaseId1,
        action3
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var breakLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: ShareBreakLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareBreakLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        requestId,
        action4,
        breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var createSnapshotOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareCreateSnapshotHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreateSnapshotExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp3
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var createPermissionOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareCreatePermissionHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreatePermissionExceptionHeaders
        }
    },
    requestBody: sharePermission,
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp4
    ],
    urlParameters: [url],
    headerParameters: [
        contentType,
        accept,
        version
    ],
    isXML: false,
    contentType: "application/xml; charset=utf-8",
    serializer: xmlSerializer$1
};
var getPermissionOperationSpec = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharePermission,
            headersMapper: ShareGetPermissionHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetPermissionExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp4
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept2,
        filePermissionKey
    ],
    serializer: serializer
};
var setPropertiesOperationSpec$1 = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareSetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        comp,
        timeoutInSeconds,
        restype1
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        quota,
        accessTier,
        rootSquash,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var setMetadataOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareSetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetMetadataExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp5
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var getAccessPolicyOperationSpec = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "SignedIdentifier" }
                    }
                },
                serializedName: "SignedIdentifiers",
                xmlName: "SignedIdentifiers",
                xmlIsWrapped: true,
                xmlElementName: "SignedIdentifier"
            },
            headersMapper: ShareGetAccessPolicyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetAccessPolicyExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp6
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var setAccessPolicyOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareSetAccessPolicyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetAccessPolicyExceptionHeaders
        }
    },
    requestBody: shareAcl,
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp6
    ],
    urlParameters: [url],
    headerParameters: [
        contentType,
        accept,
        version,
        leaseId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$1
};
var getStatisticsOperationSpec = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ShareStats,
            headersMapper: ShareGetStatisticsHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetStatisticsExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp7
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
var restoreOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareRestoreHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareRestoreExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp8
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        deletedShareName,
        deletedShareVersion
    ],
    isXML: true,
    serializer: xmlSerializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Directory. */
var Directory = /** @class */ (function () {
    /**
     * Initialize a new instance of the class Directory class.
     * @param client Reference to the service client
     */
    function Directory(client) {
        this.client = client;
    }
    /**
     * Creates a new directory under the specified share or parent directory.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       Archive for file and Directory for directory. None can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    Directory.prototype.create = function (fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        var operationArguments = {
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$1);
    };
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @param options The options parameters.
     */
    Directory.prototype.getProperties = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec$2);
    };
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @param options The options parameters.
     */
    Directory.prototype.delete = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$1);
    };
    /**
     * Sets properties on the directory.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       Archive for file and Directory for directory. None can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    Directory.prototype.setProperties = function (fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        var operationArguments = {
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec$2);
    };
    /**
     * Updates user defined metadata for the specified directory.
     * @param options The options parameters.
     */
    Directory.prototype.setMetadata = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec$1);
    };
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the contents
     * only for a single level of the directory hierarchy.
     * @param options The options parameters.
     */
    Directory.prototype.listFilesAndDirectoriesSegment = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listFilesAndDirectoriesSegmentOperationSpec);
    };
    /**
     * Lists handles for directory.
     * @param options The options parameters.
     */
    Directory.prototype.listHandles = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listHandlesOperationSpec);
    };
    /**
     * Closes all handles open for given directory.
     * @param handleId Specifies handle ID opened on the file or directory to be closed. Asterisk (*) is
     *                 a wildcard that specifies all handles.
     * @param options The options parameters.
     */
    Directory.prototype.forceCloseHandles = function (handleId, options) {
        var operationArguments = {
            handleId: handleId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, forceCloseHandlesOperationSpec);
    };
    return Directory;
}());
// Operation Specifications
var xmlSerializer$2 = new coreHttp.Serializer(Mappers, /* isXml */ true);
var createOperationSpec$1 = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: DirectoryCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryCreateExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
var getPropertiesOperationSpec$2 = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            headersMapper: DirectoryGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        shareSnapshot,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$2
};
var deleteOperationSpec$1 = {
    path: "/{shareName}/{directory}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: DirectoryDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryDeleteExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$2
};
var setPropertiesOperationSpec$2 = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: DirectorySetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectorySetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        comp,
        timeoutInSeconds,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
var setMetadataOperationSpec$1 = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: DirectorySetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectorySetMetadataExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp5,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
var listFilesAndDirectoriesSegmentOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListFilesAndDirectoriesSegmentResponse,
            headersMapper: DirectoryListFilesAndDirectoriesSegmentHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryListFilesAndDirectoriesSegmentExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp1,
        prefix,
        marker,
        maxResults,
        shareSnapshot,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$2
};
var listHandlesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHandlesResponse,
            headersMapper: DirectoryListHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryListHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        maxResults,
        shareSnapshot,
        comp9
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        recursive
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
var forceCloseHandlesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: DirectoryForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryForceCloseHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        shareSnapshot,
        comp10
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        recursive,
        handleId
    ],
    isXML: true,
    serializer: xmlSerializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a File. */
var File = /** @class */ (function () {
    /**
     * Initialize a new instance of the class File class.
     * @param client Reference to the service client
     */
    function File(client) {
        this.client = client;
    }
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @param fileContentLength Specifies the maximum size for the file, up to 4 TB.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       Archive for file and Directory for directory. None can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    File.prototype.create = function (fileContentLength, fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        var operationArguments = {
            fileContentLength: fileContentLength,
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$2);
    };
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     * @param options The options parameters.
     */
    File.prototype.download = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, downloadOperationSpec);
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties for the file. It
     * does not return the content of the file.
     * @param options The options parameters.
     */
    File.prototype.getProperties = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec$3);
    };
    /**
     * removes the file from the storage account.
     * @param options The options parameters.
     */
    File.prototype.delete = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$2);
    };
    /**
     * Sets HTTP headers on the file.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       Archive for file and Directory for directory. None can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    File.prototype.setHttpHeaders = function (fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        var operationArguments = {
            fileAttributes: fileAttributes,
            fileCreatedOn: fileCreatedOn,
            fileLastWriteOn: fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setHttpHeadersOperationSpec);
    };
    /**
     * Updates user-defined metadata for the specified file.
     * @param options The options parameters.
     */
    File.prototype.setMetadata = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec$2);
    };
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param options The options parameters.
     */
    File.prototype.acquireLease = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, acquireLeaseOperationSpec$1);
    };
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    File.prototype.releaseLease = function (leaseId, options) {
        var operationArguments = {
            leaseId: leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, releaseLeaseOperationSpec$1);
    };
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    File.prototype.changeLease = function (leaseId, options) {
        var operationArguments = {
            leaseId: leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, changeLeaseOperationSpec$1);
    };
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param options The options parameters.
     */
    File.prototype.breakLease = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, breakLeaseOperationSpec$1);
    };
    /**
     * Upload a range of bytes to a file.
     * @param range Specifies the range of bytes to be written. Both the start and end of the range must be
     *              specified. For an update operation, the range can be up to 4 MB in size. For a clear operation, the
     *              range can be up to the value of the file's full size. The File service accepts only a single byte
     *              range for the Range and 'x-ms-range' headers, and the byte range must be specified in the following
     *              format: bytes=startByte-endByte.
     * @param fileRangeWrite Specify one of the following options: - Update: Writes the bytes specified by
     *                       the request body into the specified range. The Range and Content-Length headers must match to
     *                       perform the update. - Clear: Clears the specified range and releases the space used in storage for
     *                       that range. To clear a range, set the Content-Length header to zero, and set the Range header to a
     *                       value that indicates the range to clear, up to maximum file size.
     * @param contentLength Specifies the number of bytes being transmitted in the request body. When the
     *                      x-ms-write header is set to clear, the value of this header must be set to zero.
     * @param options The options parameters.
     */
    File.prototype.uploadRange = function (range, fileRangeWrite, contentLength, options) {
        var operationArguments = {
            range: range,
            fileRangeWrite: fileRangeWrite,
            contentLength: contentLength,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, uploadRangeOperationSpec);
    };
    /**
     * Upload a range of bytes to a file where the contents are read from a URL.
     * @param range Writes data to the specified byte range in the file.
     * @param copySource Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file
     *                   to another file within the same storage account, you may use Shared Key to authenticate the source
     *                   file. If you are copying a file from another storage account, or if you are copying a blob from the
     *                   same storage account or another storage account, then you must authenticate the source file or blob
     *                   using a shared access signature. If the source is a public blob, no authentication is required to
     *                   perform the copy operation. A file in a share snapshot can also be specified as a copy source.
     * @param contentLength Specifies the number of bytes being transmitted in the request body. When the
     *                      x-ms-write header is set to clear, the value of this header must be set to zero.
     * @param options The options parameters.
     */
    File.prototype.uploadRangeFromURL = function (range, copySource, contentLength, options) {
        var operationArguments = {
            range: range,
            copySource: copySource,
            contentLength: contentLength,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, uploadRangeFromURLOperationSpec);
    };
    /**
     * Returns the list of valid ranges for a file.
     * @param options The options parameters.
     */
    File.prototype.getRangeList = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getRangeListOperationSpec);
    };
    /**
     * Copies a blob or file to a destination file within the storage account.
     * @param copySource Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file
     *                   to another file within the same storage account, you may use Shared Key to authenticate the source
     *                   file. If you are copying a file from another storage account, or if you are copying a blob from the
     *                   same storage account or another storage account, then you must authenticate the source file or blob
     *                   using a shared access signature. If the source is a public blob, no authentication is required to
     *                   perform the copy operation. A file in a share snapshot can also be specified as a copy source.
     * @param options The options parameters.
     */
    File.prototype.startCopy = function (copySource, options) {
        var operationArguments = {
            copySource: copySource,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, startCopyOperationSpec);
    };
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy File
     *               operation.
     * @param options The options parameters.
     */
    File.prototype.abortCopy = function (copyId, options) {
        var operationArguments = {
            copyId: copyId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, abortCopyOperationSpec);
    };
    /**
     * Lists handles for file
     * @param options The options parameters.
     */
    File.prototype.listHandles = function (options) {
        var operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listHandlesOperationSpec$1);
    };
    /**
     * Closes all handles open for given file
     * @param handleId Specifies handle ID opened on the file or directory to be closed. Asterisk (*) is
     *                 a wildcard that specifies all handles.
     * @param options The options parameters.
     */
    File.prototype.forceCloseHandles = function (handleId, options) {
        var operationArguments = {
            handleId: handleId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, forceCloseHandlesOperationSpec$1);
    };
    return File;
}());
// Operation Specifications
var xmlSerializer$3 = new coreHttp.Serializer(Mappers, /* isXml */ true);
var createOperationSpec$2 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileCreateExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn,
        fileContentLength,
        fileTypeConstant,
        fileContentType,
        fileContentEncoding,
        fileContentLanguage,
        fileCacheControl,
        fileContentMD5,
        fileContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var downloadOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: FileDownloadHeaders
        },
        206: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: FileDownloadHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileDownloadExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        range,
        rangeGetContentMD5
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var getPropertiesOperationSpec$3 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: FileGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, shareSnapshot],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var deleteOperationSpec$2 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: FileDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileDeleteExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var setHttpHeadersOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileSetHttpHeadersHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSetHttpHeadersExceptionHeaders
        }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn,
        fileContentType,
        fileContentEncoding,
        fileContentLanguage,
        fileCacheControl,
        fileContentMD5,
        fileContentDisposition,
        fileContentLength1
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var setMetadataOperationSpec$2 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileSetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSetMetadataExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp5],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var acquireLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileAcquireLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileAcquireLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        action,
        duration,
        proposedLeaseId,
        requestId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var releaseLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileReleaseLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileReleaseLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        action1,
        leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var changeLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileChangeLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileChangeLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        proposedLeaseId,
        requestId,
        leaseId1,
        action2
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var breakLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: FileBreakLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileBreakLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        requestId,
        action4
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var uploadRangeOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileUploadRangeHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileUploadRangeExceptionHeaders
        }
    },
    requestBody: body,
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
        version,
        leaseId,
        contentType1,
        accept3,
        range1,
        fileRangeWrite,
        contentLength,
        contentMD5
    ],
    contentType: "application/octet-stream",
    isXML: true,
    serializer: xmlSerializer$3
};
var uploadRangeFromURLOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileUploadRangeFromURLHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileUploadRangeFromURLExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        range1,
        contentLength,
        copySource,
        sourceRange,
        fileRangeWriteFromUrl,
        sourceContentCrc64,
        sourceIfMatchCrc64,
        sourceIfNoneMatchCrc64
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var getRangeListOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ShareFileRangeList,
            headersMapper: FileGetRangeListHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileGetRangeListExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        shareSnapshot,
        comp12,
        prevsharesnapshot
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        range
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var startCopyOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: FileStartCopyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileStartCopyExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId,
        filePermission,
        filePermissionKey1,
        copySource,
        filePermissionCopyMode,
        ignoreReadOnly,
        fileAttributes1,
        fileCreationTime,
        fileLastWriteTime,
        setArchiveAttribute
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var abortCopyOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        204: {
            headersMapper: FileAbortCopyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileAbortCopyExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp13,
        copyId
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
var listHandlesOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHandlesResponse,
            headersMapper: FileListHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileListHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        maxResults,
        shareSnapshot,
        comp9
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$3
};
var forceCloseHandlesOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileForceCloseHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        shareSnapshot,
        comp10
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        handleId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 */
var logger = logger$1.createClientLogger("storage-file-share");

// Copyright (c) Microsoft Corporation.
/**
 * StorageBrowserPolicy will handle differences between Node.js and browser runtime, including:
 *
 * 1. Browsers cache GET/HEAD requests by adding conditional headers such as 'IF_MODIFIED_SINCE'.
 * StorageBrowserPolicy is a policy used to add a timestamp query to GET/HEAD request URL
 * thus avoid the browser cache.
 *
 * 2. Remove cookie header for security
 *
 * 3. Remove content-length header to avoid browsers warning
 */
var StorageBrowserPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageBrowserPolicy, _super);
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param nextPolicy -
     * @param options -
     */
    function StorageBrowserPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    StorageBrowserPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                {
                    return [2 /*return*/, this._nextPolicy.sendRequest(request)];
                }
            });
        });
    };
    return StorageBrowserPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * StorageBrowserPolicyFactory is a factory class helping generating BrowserPolicy objects.
 */
var StorageBrowserPolicyFactory = /** @class */ (function () {
    function StorageBrowserPolicyFactory() {
    }
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param nextPolicy -
     * @param options -
     */
    StorageBrowserPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new StorageBrowserPolicy(nextPolicy, options);
    };
    return StorageBrowserPolicyFactory;
}());

// Copyright (c) Microsoft Corporation.
(function (StorageRetryPolicyType) {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    /**
     * Linear retry. Retry time delay grows linearly.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
})(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
// Default values of RetryOptions
var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    tryTimeoutInMs: undefined // Use server side default timeout strategy
};
var RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * Retry policy with exponential retry and linear retry implemented.
 */
var StorageRetryPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageRetryPolicy, _super);
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param retryOptions -
     */
    function StorageRetryPolicy(nextPolicy, options, retryOptions) {
        if (retryOptions === void 0) { retryOptions = DEFAULT_RETRY_OPTIONS; }
        var _this = _super.call(this, nextPolicy, options) || this;
        // Initialize retry options
        _this.retryOptions = {
            retryPolicyType: retryOptions.retryPolicyType
                ? retryOptions.retryPolicyType
                : DEFAULT_RETRY_OPTIONS.retryPolicyType,
            maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1
                ? Math.floor(retryOptions.maxTries)
                : DEFAULT_RETRY_OPTIONS.maxTries,
            tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0
                ? retryOptions.tryTimeoutInMs
                : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
            retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0
                ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs
                    ? retryOptions.maxRetryDelayInMs
                    : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs)
                : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
            maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0
                ? retryOptions.maxRetryDelayInMs
                : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs
        };
        return _this;
    }
    /**
     * Sends request.
     *
     * @param request -
     */
    StorageRetryPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, this.attemptSendRequest(request, false, 1)];
            });
        });
    };
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @param request -
     * @param response -
     * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     */
    StorageRetryPolicy.prototype.attemptSendRequest = function (request, secondaryHas404, attempt) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var newRequest, isPrimaryRetry, response, err_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newRequest = request.clone();
                        isPrimaryRetry = true;
                        // Set the server-side timeout query parameter "timeout=[seconds]"
                        if (this.retryOptions.tryTimeoutInMs) {
                            newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        logger.info("RetryPolicy: =====> Try=" + attempt + " " + (isPrimaryRetry ? "Primary" : "Secondary"));
                        return [4 /*yield*/, this._nextPolicy.sendRequest(newRequest)];
                    case 2:
                        response = _a.sent();
                        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
                            return [2 /*return*/, response];
                        }
                        secondaryHas404 = secondaryHas404 || (!isPrimaryRetry && response.status === 404);
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        logger.error("RetryPolicy: Caught error, message: " + err_1.message + ", code: " + err_1.code);
                        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err_1)) {
                            throw err_1;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [4 /*yield*/, this.delay(isPrimaryRetry, attempt, request.abortSignal)];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, this.attemptSendRequest(request, secondaryHas404, ++attempt)];
                    case 6: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param response -
     * @param err -
     */
    StorageRetryPolicy.prototype.shouldRetry = function (isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
            logger.info("RetryPolicy: Attempt(s) " + attempt + " >= maxTries " + this.retryOptions
                .maxTries + ", no further try.");
            return false;
        }
        // Handle network failures, you may need to customize the list when you implement
        // your own http client
        var retriableErrors = [
            "ETIMEDOUT",
            "ESOCKETTIMEDOUT",
            "ECONNREFUSED",
            "ECONNRESET",
            "ENOENT",
            "ENOTFOUND",
            "TIMEOUT",
            "EPIPE",
            "REQUEST_SEND_ERROR" // For default xhr based http client provided in ms-rest-js
        ];
        if (err) {
            for (var _i = 0, retriableErrors_1 = retriableErrors; _i < retriableErrors_1.length; _i++) {
                var retriableError = retriableErrors_1[_i];
                if (err.name.toUpperCase().includes(retriableError) ||
                    err.message.toUpperCase().includes(retriableError) ||
                    (err.code && err.code.toString().toUpperCase() === retriableError)) {
                    logger.info("RetryPolicy: Network error " + retriableError + " found, will retry.");
                    return true;
                }
            }
        }
        // If attempt was against the secondary & it returned a StatusNotFound (404), then
        // the resource was not found. This may be due to replication delay. So, in this
        // case, we'll never try the secondary again for this operation.
        if (response || err) {
            var statusCode = response ? response.status : err ? err.statusCode : 0;
            if (!isPrimaryRetry && statusCode === 404) {
                logger.info("RetryPolicy: Secondary access with 404, will retry.");
                return true;
            }
            // Server internal error or server timeout
            if (statusCode === 503 || statusCode === 500) {
                logger.info("RetryPolicy: Will retry for status code " + statusCode + ".");
                return true;
            }
        }
        if ((err === null || err === void 0 ? void 0 : err.code) === "PARSE_ERROR" && (err === null || err === void 0 ? void 0 : err.message.startsWith("Error \"Error: Unclosed root tag"))) {
            logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
        }
        return false;
    };
    /**
     * Delay a calculated time between retries.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param abortSignal -
     */
    StorageRetryPolicy.prototype.delay = function (isPrimaryRetry, attempt, abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var delayTimeInMs;
            return tslib.__generator(this, function (_a) {
                delayTimeInMs = 0;
                if (isPrimaryRetry) {
                    switch (this.retryOptions.retryPolicyType) {
                        case exports.StorageRetryPolicyType.EXPONENTIAL:
                            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                            break;
                        case exports.StorageRetryPolicyType.FIXED:
                            delayTimeInMs = this.retryOptions.retryDelayInMs;
                            break;
                    }
                }
                else {
                    delayTimeInMs = Math.random() * 1000;
                }
                logger.info("RetryPolicy: Delay for " + delayTimeInMs + "ms");
                return [2 /*return*/, delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR)];
            });
        });
    };
    return StorageRetryPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * StorageRetryPolicyFactory is a factory class helping generating StorageRetryPolicy objects.
 */
var StorageRetryPolicyFactory = /** @class */ (function () {
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param retryOptions -
     */
    function StorageRetryPolicyFactory(retryOptions) {
        this.retryOptions = retryOptions;
    }
    /**
     * Creates a StorageRetryPolicy object.
     * @param nextPolicy -
     * @param options -
     */
    StorageRetryPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    };
    return StorageRetryPolicyFactory;
}());

// Copyright (c) Microsoft Corporation.
/**
 * TelemetryPolicy is a policy used to tag user-agent header for every requests.
 */
var TelemetryPolicy = /** @class */ (function (_super) {
    tslib.__extends(TelemetryPolicy, _super);
    /**
     * Creates an instance of TelemetryPolicy.
     * @param nextPolicy -
     * @param options -
     * @param telemetry -
     */
    function TelemetryPolicy(nextPolicy, options, telemetry) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.telemetry = telemetry;
        return _this;
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    TelemetryPolicy.prototype.sendRequest = function (request) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                {
                    if (!request.headers) {
                        request.headers = new coreHttp.HttpHeaders();
                    }
                    if (!request.headers.get(HeaderConstants.USER_AGENT)) {
                        request.headers.set(HeaderConstants.USER_AGENT, this.telemetry);
                    }
                }
                return [2 /*return*/, this._nextPolicy.sendRequest(request)];
            });
        });
    };
    return TelemetryPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * TelemetryPolicyFactory is a factory class helping generating {@link TelemetryPolicy} objects.
 */
var TelemetryPolicyFactory = /** @class */ (function () {
    /**
     * Creates an instance of TelemetryPolicyFactory.
     * @param telemetry -
     */
    function TelemetryPolicyFactory(telemetry) {
        var userAgentInfo = [];
        {
            if (telemetry) {
                var telemetryString = telemetry.userAgentPrefix || "";
                if (telemetryString.length > 0 && userAgentInfo.indexOf(telemetryString) === -1) {
                    userAgentInfo.push(telemetryString);
                }
            }
            // e.g. azsdk-js-storagefile/11.0.0
            var libInfo = "azsdk-js-storagefile/" + SDK_VERSION;
            if (userAgentInfo.indexOf(libInfo) === -1) {
                userAgentInfo.push(libInfo);
            }
            // e.g. (NODE-VERSION 4.9.1; Windows_NT 10.0.16299)
            var runtimeInfo = "(NODE-VERSION " + process.version + "; " + os.type() + " " + os.release() + ")";
            if (userAgentInfo.indexOf(runtimeInfo) === -1) {
                userAgentInfo.push(runtimeInfo);
            }
        }
        this.telemetryString = userAgentInfo.join(" ");
    }
    /**
     * Creates a {@link RequestPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    TelemetryPolicyFactory.prototype.create = function (nextPolicy, options) {
        return new TelemetryPolicy(nextPolicy, options, this.telemetryString);
    };
    return TelemetryPolicyFactory;
}());

// Copyright (c) Microsoft Corporation.
var _defaultHttpClient = new coreHttp.DefaultHttpClient();
function getCachedDefaultHttpClient() {
    return _defaultHttpClient;
}

// Copyright (c) Microsoft Corporation.
/**
 * Credential policy used to sign HTTP(S) requests before sending. This is an
 * abstract class.
 */
var CredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(CredentialPolicy, _super);
    function CredentialPolicy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    CredentialPolicy.prototype.sendRequest = function (request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
    };
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @param request -
     */
    CredentialPolicy.prototype.signRequest = function (request) {
        // Child classes must override this method with request signing. This method
        // will be executed in sendRequest().
        return request;
    };
    return CredentialPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * AnonymousCredentialPolicy is used with HTTP(S) requests that read public resources
 * or for use with Shared Access Signatures (SAS).
 */
var AnonymousCredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(AnonymousCredentialPolicy, _super);
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     */
    function AnonymousCredentialPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    return AnonymousCredentialPolicy;
}(CredentialPolicy));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 */
var Credential = /** @class */ (function () {
    function Credential() {
    }
    /**
     * Creates a RequestPolicy object.
     *
     * @param _nextPolicy -
     * @param _options -
     */
    Credential.prototype.create = function (
    // tslint:disable-next-line:variable-name
    _nextPolicy, 
    // tslint:disable-next-line:variable-name
    _options) {
        throw new Error("Method should be implemented in children classes.");
    };
    return Credential;
}());

// Copyright (c) Microsoft Corporation.
/**
 * AnonymousCredential provides a credentialPolicyCreator member used to create
 * {@link AnonymousCredentialPolicy} objects. AnonymousCredentialPolicy is used with
 * HTTP(S) requests that read public resources or for use with Shared Access
 * Signatures (SAS).
 */
var AnonymousCredential = /** @class */ (function (_super) {
    tslib.__extends(AnonymousCredential, _super);
    function AnonymousCredential() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    AnonymousCredential.prototype.create = function (nextPolicy, options) {
        return new AnonymousCredentialPolicy(nextPolicy, options);
    };
    return AnonymousCredential;
}(Credential));

// Copyright (c) Microsoft Corporation.
/**
 * A Pipeline class containing HTTP request policies.
 * You can create a default Pipeline by calling {@link newPipeline}.
 * Or you can create a Pipeline with your own policies by the constructor of Pipeline.
 *
 * Refer to {@link newPipeline} and provided policies as reference before
 * implementing your customized Pipeline.
 */
var Pipeline = /** @class */ (function () {
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param factories -
     * @param options -
     */
    function Pipeline(factories, options) {
        if (options === void 0) { options = {}; }
        this.factories = factories;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        this.options = tslib.__assign(tslib.__assign({}, options), { httpClient: options.httpClient || getCachedDefaultHttpClient() });
    }
    /**
     * Transfer Pipeline object to ServiceClientOptions object which required by
     * ServiceClient constructor.
     *
     * @returns The ServiceClientOptions object from this Pipeline.
     */
    Pipeline.prototype.toServiceClientOptions = function () {
        return {
            httpClient: this.options.httpClient,
            requestPolicyFactories: this.factories
        };
    };
    return Pipeline;
}());
/**
 * Creates a new {@link Pipeline} object with {@link Credential} provided.
 *
 * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential.
 * @param pipelineOptions - Optional. Options.
 * @returns A new Pipeline object.
 */
function newPipeline(credential, pipelineOptions) {
    if (pipelineOptions === void 0) { pipelineOptions = {}; }
    if (credential === undefined) {
        credential = new AnonymousCredential();
    }
    // Order is important. Closer to the API at the top & closer to the network at the bottom.
    // The credential's policy factory must appear close to the wire so it can sign any
    // changes made by other factories (like UniqueRequestIDPolicyFactory)
    var telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);
    var factories = [
        coreHttp.tracingPolicy({ userAgent: telemetryPolicy.telemetryString }),
        coreHttp.keepAlivePolicy(pipelineOptions.keepAliveOptions),
        telemetryPolicy,
        coreHttp.generateClientRequestIdPolicy(),
        new StorageBrowserPolicyFactory(),
        new StorageRetryPolicyFactory(pipelineOptions.retryOptions),
        coreHttp.deserializationPolicy(),
        coreHttp.logPolicy({
            logger: logger.info,
            allowedHeaderNames: StorageFileLoggingAllowedHeaderNames,
            allowedQueryParameters: StorageFileLoggingAllowedQueryParameters
        })
    ];
    {
        // policies only available in Node.js runtime, not in browsers
        factories.push(coreHttp.proxyPolicy(pipelineOptions.proxyOptions));
        factories.push(coreHttp.disableResponseDecompressionPolicy());
    }
    factories.push(credential);
    return new Pipeline(factories, pipelineOptions);
}

// Copyright (c) Microsoft Corporation.
/**
 * StorageSharedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 */
var StorageSharedKeyCredentialPolicy = /** @class */ (function (_super) {
    tslib.__extends(StorageSharedKeyCredentialPolicy, _super);
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     * @param factory -
     */
    function StorageSharedKeyCredentialPolicy(nextPolicy, options, factory) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.factory = factory;
        return _this;
    }
    /**
     * Signs request.
     *
     * @param request -
     */
    StorageSharedKeyCredentialPolicy.prototype.signRequest = function (request) {
        request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
        if (request.body && typeof request.body === "string" && request.body.length > 0) {
            request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        var stringToSign = [
            request.method.toUpperCase(),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
            this.getHeaderValueToSign(request, HeaderConstants.DATE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.RANGE)
        ].join("\n") +
            "\n" +
            this.getCanonicalizedHeadersString(request) +
            this.getCanonicalizedResourceString(request);
        var signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(HeaderConstants.AUTHORIZATION, "SharedKey " + this.factory.accountName + ":" + signature);
        // console.log(`[URL]:${request.url}`);
        // console.log(`[HEADERS]:${request.headers.toString()}`);
        // console.log(`[STRING TO SIGN]:${JSON.stringify(stringToSign)}`);
        // console.log(`[KEY]: ${request.headers.get(HeaderConstants.AUTHORIZATION)}`);
        return request;
    };
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @param request -
     * @param headerName -
     */
    StorageSharedKeyCredentialPolicy.prototype.getHeaderValueToSign = function (request, headerName) {
        var value = request.headers.get(headerName);
        if (!value) {
            return "";
        }
        // When using version 2015-02-21 or later, if Content-Length is zero, then
        // set the Content-Length part of the StringToSign to an empty string.
        // https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
        if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
            return "";
        }
        return value;
    };
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @param request -
     */
    StorageSharedKeyCredentialPolicy.prototype.getCanonicalizedHeadersString = function (request) {
        var headersArray = request.headers.headersArray().filter(function (value) {
            return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
        });
        headersArray.sort(function (a, b) {
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        // Remove duplicate headers
        headersArray = headersArray.filter(function (value, index, array) {
            if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
                return false;
            }
            return true;
        });
        var canonicalizedHeadersStringToSign = "";
        headersArray.forEach(function (header) {
            canonicalizedHeadersStringToSign += header.name
                .toLowerCase()
                .trimRight() + ":" + header.value.trimLeft() + "\n";
        });
        return canonicalizedHeadersStringToSign;
    };
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @param request -
     */
    StorageSharedKeyCredentialPolicy.prototype.getCanonicalizedResourceString = function (request) {
        var path = getURLPath(request.url) || "/";
        var canonicalizedResourceString = "";
        canonicalizedResourceString += "/" + this.factory.accountName + path;
        var queries = getURLQueries(request.url);
        var lowercaseQueries = {};
        if (queries) {
            var queryKeys = [];
            for (var key in queries) {
                if (queries.hasOwnProperty(key)) {
                    var lowercaseKey = key.toLowerCase();
                    lowercaseQueries[lowercaseKey] = queries[key];
                    queryKeys.push(lowercaseKey);
                }
            }
            queryKeys.sort();
            for (var _i = 0, queryKeys_1 = queryKeys; _i < queryKeys_1.length; _i++) {
                var key = queryKeys_1[_i];
                canonicalizedResourceString += "\n" + key + ":" + decodeURIComponent(lowercaseQueries[key]);
            }
        }
        return canonicalizedResourceString;
    };
    return StorageSharedKeyCredentialPolicy;
}(CredentialPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * StorageSharedKeyCredential for account key authorization of Azure Storage service.
 */
var StorageSharedKeyCredential = /** @class */ (function (_super) {
    tslib.__extends(StorageSharedKeyCredential, _super);
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param accountName -
     * @param accountKey -
     */
    function StorageSharedKeyCredential(accountName, accountKey) {
        var _this = _super.call(this) || this;
        _this.accountName = accountName;
        _this.accountKey = Buffer.from(accountKey, "base64");
        return _this;
    }
    /**
     * Creates a {@link StorageSharedKeyCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    StorageSharedKeyCredential.prototype.create = function (nextPolicy, options) {
        return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    };
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */
    StorageSharedKeyCredential.prototype.computeHMACSHA256 = function (stringToSign) {
        return crypto.createHmac("sha256", this.accountKey)
            .update(stringToSign, "utf8")
            .digest("base64");
    };
    return StorageSharedKeyCredential;
}(Credential));

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
var createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.Storage.File",
    namespace: "Microsoft.Storage"
});
/**
 * @internal
 *
 * Adapt the tracing options from OperationOptions to what they need to be for
 * RequestOptionsBase (when we update to later OpenTelemetry versions this is now
 * two separate fields, not just one).
 */
function convertTracingToRequestOptionsBase(options) {
    var _a, _b;
    return {
        spanOptions: (_a = options === null || options === void 0 ? void 0 : options.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions,
        tracingContext: (_b = options === null || options === void 0 ? void 0 : options.tracingOptions) === null || _b === void 0 ? void 0 : _b.tracingContext
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var packageName = "azure-storage-file-share";
var packageVersion = "12.6.0";
var StorageClientContext = /** @class */ (function (_super) {
    tslib.__extends(StorageClientContext, _super);
    /**
     * Initializes a new instance of the StorageClientContext class.
     * @param url The URL of the service account, share, directory or file that is the target of the
     *            desired operation.
     * @param options The parameter options
     */
    function StorageClientContext(url, options) {
        var _this = this;
        if (url === undefined) {
            throw new Error("'url' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, undefined, options) || this;
        _this.requestContentType = "application/json; charset=utf-8";
        _this.baseUri = options.endpoint || "{url}";
        // Parameter assignments
        _this.url = url;
        // Assigning values to Constant parameters
        _this.version = options.version || "2020-08-04";
        _this.fileRangeWriteFromUrl = options.fileRangeWriteFromUrl || "update";
        return _this;
    }
    return StorageClientContext;
}(coreHttp.ServiceClient));

// Copyright (c) Microsoft Corporation.
/**
 * A StorageClient represents a base client class for ServiceClient, ContainerClient and etc.
 */
var StorageClient = /** @class */ (function () {
    /**
     * Creates an instance of StorageClient.
     * @param url -
     * @param pipeline -
     */
    function StorageClient(url, pipeline) {
        // URL should be encoded and only once, protocol layer shouldn't encode URL again
        this.url = escapeURLPath(url);
        this.accountName = getAccountNameFromUrl(url);
        this.pipeline = pipeline;
        this.storageClientContext = new StorageClientContext(this.url, tslib.__assign({ version: SERVICE_VERSION }, pipeline.toServiceClientOptions()));
        // Remove the default content-type in generated code of StorageClientContext
        var storageClientContext = this.storageClientContext;
        if (storageClientContext.requestContentType) {
            storageClientContext.requestContentType = undefined;
        }
        // Retrieve credential from the pipeline.
        this.credential = new AnonymousCredential();
        for (var _i = 0, _a = this.pipeline.factories; _i < _a.length; _i++) {
            var factory = _a[_i];
            if ((coreHttp.isNode && factory instanceof StorageSharedKeyCredential) ||
                factory instanceof AnonymousCredential) {
                this.credential = factory;
                break;
            }
        }
    }
    return StorageClient;
}());

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This is a helper class to construct a string representing the NTFS attributes to a file or directory.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file#file-system-attributes
 */
var FileSystemAttributes = /** @class */ (function () {
    function FileSystemAttributes() {
        /**
         * Specifies a directory or file that is read-only.
         */
        this.readonly = false;
        /**
         * Specifies a directory or file is hidden.
         */
        this.hidden = false;
        /**
         * Specifies a directory or file that the operating system uses a part of, or uses exclusively.
         */
        this.system = false;
        /**
         * Specifies a directory or file that does not have other attributes set. This attribute is valid only when used alone.
         */
        this.none = false;
        /**
         * Specifies the handle identifies a directory.
         */
        this.directory = false;
        /**
         * Specifies a directory or file is an archive. Applications typically use this attribute to mark files for backup or removal.
         */
        this.archive = false;
        /**
         * Specifies if a file is temporary.
         */
        this.temporary = false;
        /**
         * Specifies the data of a directory or file is not available immediately.
         * This file system attribute is presented primarily to provide compatibility with Windows - Azure Files does not support with offline storage options.
         */
        this.offline = false;
        /**
         * Specifies the directory or file is not to be indexed by the content indexing service.
         */
        this.notContentIndexed = false;
        /**
         * Specifies the user data stream not to be read by the background data integrity scanner.
         * This file system attribute is presented primarily to provide compatibility with Windows.
         * Applicable to directory or file.
         */
        this.noScrubData = false;
    }
    /**
     * Creates a FileSystemAttributes from the specified attributes string. This method will throw an
     * Error if it encounters a string that does not correspond to a valid attributes.
     *
     * @param fileAttributes - The value of header x-ms-file-attributes.
     */
    FileSystemAttributes.parse = function (fileAttributes) {
        if (!fileAttributes) {
            throw new RangeError("Invalid fileAttributes: '" + fileAttributes + "'.");
        }
        var fileSystemAttributes = new FileSystemAttributes();
        var attributes = fileAttributes.trim().split("|");
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var str = attributes_1[_i];
            str = str.trim();
            switch (str) {
                case "ReadOnly":
                    fileSystemAttributes.readonly = true;
                    break;
                case "Hidden":
                    fileSystemAttributes.hidden = true;
                    break;
                case "System":
                    fileSystemAttributes.system = true;
                    break;
                case "None":
                    fileSystemAttributes.none = true;
                    break;
                case "Temporary":
                    fileSystemAttributes.temporary = true;
                    break;
                case "Offline":
                    fileSystemAttributes.offline = true;
                    break;
                case "Directory":
                    fileSystemAttributes.directory = true;
                    break;
                case "Archive":
                    fileSystemAttributes.archive = true;
                    break;
                case "NotContentIndexed":
                    fileSystemAttributes.notContentIndexed = true;
                    break;
                case "NoScrubData":
                    fileSystemAttributes.noScrubData = true;
                    break;
                default:
                    throw new RangeError("Invalid attribute: " + str);
            }
        }
        return fileSystemAttributes;
    };
    /**
     * Converts the given attributes to a string.
     *
     * @returns A string which represents the FileSystemAttributes
     */
    FileSystemAttributes.prototype.toString = function () {
        var attributes = [];
        if (this.readonly) {
            attributes.push("ReadOnly");
        }
        if (this.hidden) {
            attributes.push("Hidden");
        }
        if (this.system) {
            attributes.push("System");
        }
        if (this.none) {
            attributes.push("None");
        }
        if (this.temporary) {
            attributes.push("Temporary");
        }
        if (this.directory) {
            attributes.push("Directory");
        }
        if (this.archive) {
            attributes.push("Archive");
        }
        if (this.offline) {
            attributes.push("Offline");
        }
        if (this.notContentIndexed) {
            attributes.push("NotContentIndexed");
        }
        if (this.noScrubData) {
            attributes.push("NoScrubData");
        }
        return attributes.join("|");
    };
    return FileSystemAttributes;
}());

// Copyright (c) Microsoft Corporation.
var ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * A Node.js ReadableStream will internally retry when internal ReadableStream unexpected ends.
 */
var RetriableReadableStream = /** @class */ (function (_super) {
    tslib.__extends(RetriableReadableStream, _super);
    /**
     * Creates an instance of RetriableReadableStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param getter - A method calling downloading request returning
     *                                      a new ReadableStream from specified offset
     * @param offset - Offset position in original data source to read
     * @param count - How much data in original data source to read
     * @param options -
     */
    function RetriableReadableStream(source, getter, offset, count, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.retries = 0;
        _this.abortHandler = function () {
            _this.source.pause();
            _this.emit("error", ABORT_ERROR);
        };
        var aborter = options.abortSignal || abortController.AbortSignal.none;
        _this.aborter = aborter;
        _this.getter = getter;
        _this.source = source;
        _this.start = offset;
        _this.offset = offset;
        _this.end = offset + count - 1;
        _this.maxRetryRequests =
            options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
        _this.onProgress = options.onProgress;
        _this.options = options;
        aborter.addEventListener("abort", _this.abortHandler);
        _this.setSourceDataHandler();
        _this.setSourceEndHandler();
        _this.setSourceErrorHandler();
        return _this;
    }
    RetriableReadableStream.prototype._read = function () {
        if (!this.aborter.aborted) {
            this.source.resume();
        }
    };
    RetriableReadableStream.prototype.setSourceDataHandler = function () {
        var _this = this;
        this.source.on("data", function (data) {
            if (_this.options.doInjectErrorOnce) {
                _this.options.doInjectErrorOnce = undefined;
                _this.source.pause();
                _this.source.removeAllListeners("data");
                _this.source.emit("end");
                return;
            }
            // console.log(
            //   `Offset: ${this.offset}, Received ${data.length} from internal stream`
            // );
            _this.offset += data.length;
            if (_this.onProgress) {
                _this.onProgress({ loadedBytes: _this.offset - _this.start });
            }
            if (!_this.push(data)) {
                _this.source.pause();
            }
        });
    };
    RetriableReadableStream.prototype.setSourceEndHandler = function () {
        var _this = this;
        this.source.on("end", function () {
            // console.log(
            //   `Source stream emits end, offset: ${
            //     this.offset
            //   }, dest end : ${this.end}`
            // );
            if (_this.offset - 1 === _this.end) {
                _this.aborter.removeEventListener("abort", _this.abortHandler);
                _this.push(null);
            }
            else if (_this.offset <= _this.end) {
                // console.log(
                //   `retries: ${this.retries}, max retries: ${this.maxRetries}`
                // );
                if (_this.retries < _this.maxRetryRequests) {
                    _this.retries += 1;
                    _this.getter(_this.offset)
                        .then(function (newSource) {
                        _this.source = newSource;
                        _this.setSourceDataHandler();
                        _this.setSourceEndHandler();
                        _this.setSourceErrorHandler();
                    })
                        .catch(function (error) {
                        _this.emit("error", error);
                    });
                }
                else {
                    _this.emit("error", new Error(
                    // tslint:disable-next-line:max-line-length
                    "Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: " + (_this
                        .offset - 1) + ", data needed offset: " + _this.end + ", retries: " + _this.retries + ", max retries: " + _this.maxRetryRequests));
                }
            }
            else {
                _this.emit("error", new Error("Data corruption failure: Received more data than original request, data needed offset is " + _this.end + ", received offset: " + (_this.offset - 1)));
            }
        });
    };
    RetriableReadableStream.prototype.setSourceErrorHandler = function () {
        var _this = this;
        this.source.on("error", function (error) {
            _this.emit("error", error);
        });
    };
    return RetriableReadableStream;
}(stream.Readable));

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * FileDownloadResponse implements the `FileDownloadResponseModel` interface, and in a Node.js runtime it will
 * automatically retry when its internal read stream unexpectedly ends. (This kind of unexpected end cannot
 * trigger retries defined in the pipeline retry policy.)
 *
 * The {@link readableStreamBody} stream will retry beneath the `ReadableStream` layer, so you can just use it as
 * a normal Node.js Readable stream.
 */
var FileDownloadResponse = /** @class */ (function () {
    /**
     * Creates an instance of FileDownloadResponse.
     *
     * @param originalResponse -
     * @param getter -
     * @param offset -
     * @param count -
     * @param options -
     */
    function FileDownloadResponse(originalResponse, getter, offset, count, options) {
        if (options === void 0) { options = {}; }
        this.originalResponse = originalResponse;
        this.fileDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
    Object.defineProperty(FileDownloadResponse.prototype, "acceptRanges", {
        /**
         * Indicates that the service supports
         * requests for partial file content.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.acceptRanges;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "cacheControl", {
        /**
         * Returnes if it was previously specified
         * for the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.cacheControl;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentDisposition", {
        /**
         * Returns the value that was specified
         * for the 'x-ms-content-disposition' header and specifies how to process the
         * response.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentDisposition;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentEncoding", {
        /**
         * Returns the value that was specified
         * for the Content-Encoding request header.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentEncoding;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentLanguage", {
        /**
         * Returns the value that was specified
         * for the Content-Language request header.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentLength", {
        /**
         * The number of bytes present in the
         * response body.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentMD5", {
        /**
         * If the file has an MD5 hash and the
         * request is to read the full file, this response header is returned so that
         * the client can check for message content integrity. If the request is to
         * read a specified range and the 'x-ms-range-get-content-md5' is set to
         * true, then the request returns an MD5 hash for the range, as long as the
         * range size is less than or equal to 4 MB. If neither of these sets of
         * conditions is true, then no value is returned for the 'Content-MD5'
         * header.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentMD5;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentRange", {
        /**
         * Indicates the range of bytes returned if
         * the client requested a subset of the file by setting the Range request
         * header.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentRange;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentType", {
        /**
         * The content type specified for the file.
         * The default content type is 'application/octet-stream'
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.contentType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyCompletedOn", {
        /**
         * Conclusion time of the last attempted
         * Copy File operation where this file was the destination file. This value
         * can specify the time of a completed, aborted, or failed copy attempt.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.copyCompletedOn;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyId", {
        /**
         * String identifier for the last attempted Copy
         * File operation where this file was the destination file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.copyId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyProgress", {
        /**
         * Contains the number of bytes copied and
         * the total bytes in the source in the last attempted Copy File operation
         * where this file was the destination file. Can show between 0 and
         * Content-Length bytes copied.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.copyProgress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copySource", {
        /**
         * URL up to 2KB in length that specifies the
         * source file used in the last attempted Copy File operation where this file
         * was the destination file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.copySource;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyStatus", {
        /**
         * State of the copy operation
         * identified by 'x-ms-copy-id'. Possible values include: 'pending',
         * 'success', 'aborted', 'failed'
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.copyStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "copyStatusDescription", {
        /**
         * Only appears when
         * x-ms-copy-status is failed or pending. Describes cause of fatal or
         * non-fatal copy operation failure.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.copyStatusDescription;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "date", {
        /**
         * A UTC date/time value generated by the service that
         * indicates the time at which the response was initiated.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.date;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "etag", {
        /**
         * The ETag contains a value that you can use to
         * perform operations conditionally, in quotes.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.etag;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "errorCode", {
        get: function () {
            return this.originalResponse.errorCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileContentMD5", {
        /**
         * If the file has a MD5 hash, and if
         * request contains range header (Range or x-ms-range), this response header
         * is returned with the value of the whole file's MD5 value. This value may
         * or may not be equal to the value returned in Content-MD5 header, with the
         * latter calculated from the requested range.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileContentMD5;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "isServerEncrypted", {
        /**
         * The value of this header is set to
         * true if the file data and application metadata are completely encrypted
         * using the specified algorithm. Otherwise, the value is set to false (when
         * the file is unencrypted, or if only parts of the file/application metadata
         * are encrypted).
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.isServerEncrypted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "lastModified", {
        /**
         * Returns the date and time the file was last
         * modified. Any operation that modifies the file or its properties updates
         * the last modified time.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.lastModified;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "metadata", {
        /**
         * A name-value pair
         * to associate with a file storage object.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.metadata;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "requestId", {
        /**
         * This header uniquely identifies the request
         * that was made and can be used for troubleshooting the request.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.requestId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "version", {
        /**
         * Indicates the version of the File service used
         * to execute the request.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.version;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileAttributes", {
        /**
         * Attributes set for the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileAttributes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileCreatedOn", {
        /**
         * Creation time for the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileCreatedOn;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileLastWriteOn", {
        /**
         * Last write time for the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileLastWriteOn;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileChangeOn", {
        /**
         * Change time for the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileChangeOn;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "filePermissionKey", {
        /**
         * Key of the permission set for the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.filePermissionKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileId", {
        /**
         * The fileId of the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "fileParentId", {
        /**
         * The parent fileId of the file.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.fileParentId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "contentAsBlob", {
        /**
         * The response body as a browser Blob.
         * Always undefined in node.js.
         *
         * @readonly
         */
        get: function () {
            return this.originalResponse.blobBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "leaseDuration", {
        /**
         * When a file is leased, specifies whether the lease is of infinite or fixed duration. Possible
         * values include: 'infinite', 'fixed'
         */
        get: function () {
            return this.originalResponse.leaseDuration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "leaseState", {
        /**
         * Lease state of the file. Possible values include: 'available', 'leased', 'expired',
         * 'breaking', 'broken'
         */
        get: function () {
            return this.originalResponse.leaseState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "leaseStatus", {
        /**
         * The current lease status of the file. Possible values include: 'locked', 'unlocked'
         */
        get: function () {
            return this.originalResponse.leaseStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "readableStreamBody", {
        /**
         * The response body as a node.js Readable stream.
         * Always undefined in the browser.
         *
         * It will automatically retry when internal read stream unexpected ends.
         *
         * @readonly
         */
        get: function () {
            return coreHttp.isNode ? this.fileDownloadStream : undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileDownloadResponse.prototype, "_response", {
        get: function () {
            return this.originalResponse._response;
        },
        enumerable: false,
        configurable: true
    });
    return FileDownloadResponse;
}());

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Generate a range string. For example:
 *
 * "bytes=255-" or "bytes=0-511"
 *
 * @param range - A range of byte positions.
 * @returns The string representation for the byte range.
 */
function rangeToString(range) {
    if (range.offset < 0) {
        throw new RangeError("Range.offset cannot be smaller than 0.");
    }
    if (range.count && range.count <= 0) {
        throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
    }
    return range.count
        ? "bytes=" + range.offset + "-" + (range.offset + range.count - 1)
        : "bytes=" + range.offset + "-";
}

// Copyright (c) Microsoft Corporation.
/**
 * Convert protocols from joined string to ShareProtocols.
 *
 * @param protocolsString -
 */
function toShareProtocols(protocolsString) {
    if (protocolsString === undefined) {
        return undefined;
    }
    var protocolStrArray = protocolsString.split(";");
    var protocols = {};
    for (var _i = 0, protocolStrArray_1 = protocolStrArray; _i < protocolStrArray_1.length; _i++) {
        var protocol = protocolStrArray_1[_i];
        if (protocol === "SMB") {
            protocols.smbEnabled = true;
        }
        else if (protocol === "NFS") {
            protocols.nfsEnabled = true;
        }
    }
    return protocols;
}
/**
 * Convert ShareProtocols to joined string.
 *
 * @param protocols -
 */
function toShareProtocolsString(protocols) {
    if (protocols === void 0) { protocols = {}; }
    var protocolStr = undefined;
    if (protocols.smbEnabled === true) {
        protocolStr = "SMB";
    }
    if (protocols.nfsEnabled === true) {
        logger.info("Using \"NFS\" in favor of \"SMB\" for the share protocol as currently they can't be supported at the same time.");
        protocolStr = "NFS";
    }
    return protocolStr;
}
function validateFilePermissionOptions(filePermission, filePermissionKey) {
    if (filePermission && filePermissionKey) {
        throw new RangeError("Only one of filePermission or filePermissionKey can be specified.");
    }
}
function validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options) {
    // Would better deep copy params set by user.
    if (!options) {
        options = {};
    }
    validateFilePermissionOptions(options.filePermission, options.filePermissionKey);
    if (!options.creationTime) {
        options.creationTime = "now";
    }
    if (!options.lastWriteTime) {
        options.lastWriteTime = "now";
    }
    if (!options.filePermission && !options.filePermissionKey) {
        options.filePermission = "inherit";
    }
    return options;
}
function validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options) {
    // Would better deep copy params set by user.
    if (!options) {
        options = {};
    }
    validateFilePermissionOptions(options.filePermission, options.filePermissionKey);
    if (!options.creationTime) {
        options.creationTime = "preserve";
    }
    if (!options.lastWriteTime) {
        options.lastWriteTime = "preserve";
    }
    if (!options.fileAttributes) {
        options.fileAttributes = "preserve";
    }
    if (!options.filePermission && !options.filePermissionKey) {
        options.filePermission = "preserve";
    }
    return options;
}
function fileAttributesToString(fileAttributes) {
    return fileAttributes instanceof FileSystemAttributes
        ? fileAttributes.toString()
        : fileAttributes;
}
function fileCreationTimeToString(time) {
    return time instanceof Date ? truncatedISO8061Date(time) : time;
}
function fileLastWriteTimeToString(time) {
    return time instanceof Date ? truncatedISO8061Date(time) : time;
}

// Copyright (c) Microsoft Corporation.
/**
 * States for Batch.
 */
var BatchStates;
(function (BatchStates) {
    BatchStates[BatchStates["Good"] = 0] = "Good";
    BatchStates[BatchStates["Error"] = 1] = "Error";
})(BatchStates || (BatchStates = {}));
/**
 * Batch provides basic parallel execution with concurrency limits.
 * Will stop execute left operations when one of the executed operation throws an error.
 * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.
 */
var Batch = /** @class */ (function () {
    /**
     * Creates an instance of Batch.
     * @param concurrency -
     */
    function Batch(concurrency) {
        if (concurrency === void 0) { concurrency = 5; }
        /**
         * Number of active operations under execution.
         */
        this.actives = 0;
        /**
         * Number of completed operations under execution.
         */
        this.completed = 0;
        /**
         * Offset of next operation to be executed.
         */
        this.offset = 0;
        /**
         * Operation array to be executed.
         */
        this.operations = [];
        /**
         * States of Batch. When an error happens, state will turn into error.
         * Batch will stop execute left operations.
         */
        this.state = BatchStates.Good;
        if (concurrency < 1) {
            throw new RangeError("concurrency must be larger than 0");
        }
        this.concurrency = concurrency;
        this.emitter = new events.EventEmitter();
    }
    /**
     * Add a operation into queue.
     *
     * @param operation -
     */
    Batch.prototype.addOperation = function (operation) {
        var _this = this;
        this.operations.push(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
            var error_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        this.actives++;
                        return [4 /*yield*/, operation()];
                    case 1:
                        _a.sent();
                        this.actives--;
                        this.completed++;
                        this.parallelExecute();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        this.emitter.emit("error", error_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Start execute operations in the queue.
     *
     */
    Batch.prototype.do = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                if (this.operations.length === 0) {
                    return [2 /*return*/, Promise.resolve()];
                }
                this.parallelExecute();
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.emitter.on("finish", resolve);
                        _this.emitter.on("error", function (error) {
                            _this.state = BatchStates.Error;
                            reject(error);
                        });
                    })];
            });
        });
    };
    /**
     * Get next operation to be executed. Return null when reaching ends.
     *
     */
    Batch.prototype.nextOperation = function () {
        if (this.offset < this.operations.length) {
            return this.operations[this.offset++];
        }
        return null;
    };
    /**
     * Start execute operations. One one the most important difference between
     * this method with do() is that do() wraps as an sync method.
     *
     */
    Batch.prototype.parallelExecute = function () {
        if (this.state === BatchStates.Error) {
            return;
        }
        if (this.completed >= this.operations.length) {
            this.emitter.emit("finish");
            return;
        }
        while (this.actives < this.concurrency) {
            var operation = this.nextOperation();
            if (operation) {
                operation();
            }
            else {
                return;
            }
        }
    };
    return Batch;
}());

// Copyright (c) Microsoft Corporation.
/**
 * This class accepts a Node.js Readable stream as input, and keeps reading data
 * from the stream into the internal buffer structure, until it reaches maxBuffers.
 * Every available buffer will try to trigger outgoingHandler.
 *
 * The internal buffer structure includes an incoming buffer array, and a outgoing
 * buffer array. The incoming buffer array includes the "empty" buffers can be filled
 * with new incoming data. The outgoing array includes the filled buffers to be
 * handled by outgoingHandler. Every above buffer size is defined by parameter bufferSize.
 *
 * NUM_OF_ALL_BUFFERS = BUFFERS_IN_INCOMING + BUFFERS_IN_OUTGOING + BUFFERS_UNDER_HANDLING
 *
 * NUM_OF_ALL_BUFFERS lesser than or equal to maxBuffers
 *
 * PERFORMANCE IMPROVEMENT TIPS:
 * 1. Input stream highWaterMark is better to set a same value with bufferSize
 *    parameter, which will avoid Buffer.concat() operations.
 * 2. Concurrency should set a smaller value than maxBuffers, which is helpful to
 *    reduce the possibility when a outgoing handler waits for the stream data.
 *    in this situation, outgoing handlers are blocked.
 *    Outgoing queue shouldn't be empty.
 */
var BufferScheduler = /** @class */ (function () {
    /**
     * Creates an instance of BufferScheduler.
     *
     * @param readable - A Node.js Readable stream
     * @param bufferSize - Buffer size of every maintained buffer
     * @param maxBuffers - How many buffers can be allocated
     * @param outgoingHandler - An async function scheduled to be
     *                                          triggered when a buffer fully filled
     *                                          with stream data
     * @param concurrency - Concurrency of executing outgoingHandlers (greater than 0)
     * @param encoding - [Optional] Encoding of Readable stream when it's a string stream
     */
    function BufferScheduler(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
        /**
         * An internal event emitter.
         */
        this.emitter = new events.EventEmitter();
        /**
         * An internal offset marker to track data offset in bytes of next outgoingHandler.
         */
        this.offset = 0;
        /**
         * An internal marker to track whether stream is end.
         */
        this.isStreamEnd = false;
        /**
         * An internal marker to track whether stream or outgoingHandler returns error.
         */
        this.isError = false;
        /**
         * How many handlers are executing.
         */
        this.executingOutgoingHandlers = 0;
        /**
         * How many buffers have been allocated.
         */
        this.numBuffers = 0;
        /**
         * Because this class doesn't know how much data every time stream pops, which
         * is defined by highWaterMarker of the stream. So BufferScheduler will cache
         * data received from the stream, when data in unresolvedDataArray exceeds the
         * blockSize defined, it will try to concat a blockSize of buffer, fill into available
         * buffers from incoming and push to outgoing array.
         */
        this.unresolvedDataArray = [];
        /**
         * How much data consisted in unresolvedDataArray.
         */
        this.unresolvedLength = 0;
        /**
         * The array includes all the available buffers can be used to fill data from stream.
         */
        this.incoming = [];
        /**
         * The array (queue) includes all the buffers filled from stream data.
         */
        this.outgoing = [];
        if (bufferSize <= 0) {
            throw new RangeError("bufferSize must be larger than 0, current is " + bufferSize);
        }
        if (maxBuffers <= 0) {
            throw new RangeError("maxBuffers must be larger than 0, current is " + maxBuffers);
        }
        if (concurrency <= 0) {
            throw new RangeError("concurrency must be larger than 0, current is " + concurrency);
        }
        this.bufferSize = bufferSize;
        this.maxBuffers = maxBuffers;
        this.readable = readable;
        this.outgoingHandler = outgoingHandler;
        this.concurrency = concurrency;
        this.encoding = encoding;
    }
    /**
     * Start the scheduler, will return error when stream of any of the outgoingHandlers
     * returns error.
     *
     */
    BufferScheduler.prototype.do = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.readable.on("data", function (data) {
                            data = typeof data === "string" ? Buffer.from(data, _this.encoding) : data;
                            _this.appendUnresolvedData(data);
                            if (!_this.resolveData()) {
                                _this.readable.pause();
                            }
                        });
                        _this.readable.on("error", function (err) {
                            _this.emitter.emit("error", err);
                        });
                        _this.readable.on("end", function () {
                            _this.isStreamEnd = true;
                            _this.emitter.emit("checkEnd");
                        });
                        _this.emitter.on("error", function (err) {
                            _this.isError = true;
                            _this.readable.pause();
                            reject(err);
                        });
                        _this.emitter.on("checkEnd", function () {
                            if (_this.outgoing.length > 0) {
                                _this.triggerOutgoingHandlers();
                                return;
                            }
                            if (_this.isStreamEnd && _this.executingOutgoingHandlers === 0) {
                                if (_this.unresolvedLength > 0 && _this.unresolvedLength < _this.bufferSize) {
                                    _this.outgoingHandler(_this.shiftBufferFromUnresolvedDataArray(), _this.offset)
                                        .then(resolve)
                                        .catch(reject);
                                }
                                else if (_this.unresolvedLength >= _this.bufferSize) {
                                    return;
                                }
                                else {
                                    resolve();
                                }
                            }
                        });
                    })];
            });
        });
    };
    /**
     * Insert a new data into unresolved array.
     *
     * @param data -
     */
    BufferScheduler.prototype.appendUnresolvedData = function (data) {
        this.unresolvedDataArray.push(data);
        this.unresolvedLength += data.length;
    };
    /**
     * Try to shift a buffer with size in blockSize. The buffer returned may be less
     * than blockSize when data in unresolvedDataArray is less than bufferSize.
     *
     */
    BufferScheduler.prototype.shiftBufferFromUnresolvedDataArray = function () {
        if (this.unresolvedLength >= this.bufferSize) {
            if (this.bufferSize === this.unresolvedDataArray[0].length) {
                this.unresolvedLength -= this.bufferSize;
                return this.unresolvedDataArray.shift();
            }
            // Lazy concat because Buffer.concat highly drops performance
            var merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);
            var buffer = merged.slice(0, this.bufferSize);
            merged = merged.slice(this.bufferSize);
            this.unresolvedDataArray = [merged];
            this.unresolvedLength -= buffer.length;
            return buffer;
        }
        else if (this.unresolvedLength > 0) {
            var merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);
            this.unresolvedDataArray = [];
            this.unresolvedLength = 0;
            return merged;
        }
        else {
            return Buffer.allocUnsafe(0);
        }
    };
    /**
     * Resolve data in unresolvedDataArray. For every buffer with size in blockSize
     * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,
     * then push it into outgoing to be handled by outgoing handler.
     *
     * Return false when available buffers in incoming are not enough, else true.
     *
     * @returns Return false when buffers in incoming are not enough, else true.
     */
    BufferScheduler.prototype.resolveData = function () {
        while (this.unresolvedLength >= this.bufferSize) {
            var buffer = void 0;
            if (this.incoming.length > 0) {
                buffer = this.incoming.shift();
            }
            else {
                if (this.numBuffers < this.maxBuffers) {
                    buffer = Buffer.allocUnsafe(this.bufferSize);
                    this.numBuffers++;
                }
                else {
                    // No available buffer, wait for buffer returned
                    return false;
                }
            }
            buffer.fill(this.shiftBufferFromUnresolvedDataArray());
            this.outgoing.push(buffer);
            this.triggerOutgoingHandlers();
        }
        return true;
    };
    /**
     * Try to trigger a outgoing handler for every buffer in outgoing. Stop when
     * concurrency reaches.
     */
    BufferScheduler.prototype.triggerOutgoingHandlers = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var buffer;
            return tslib.__generator(this, function (_a) {
                do {
                    if (this.executingOutgoingHandlers >= this.concurrency) {
                        return [2 /*return*/];
                    }
                    buffer = this.outgoing.shift();
                    if (buffer) {
                        this.triggerOutgoingHandler(buffer);
                    }
                } while (buffer);
                return [2 /*return*/];
            });
        });
    };
    /**
     * Trigger a outgoing handler for a buffer shifted from outgoing.
     *
     * @param buffer -
     */
    BufferScheduler.prototype.triggerOutgoingHandler = function (buffer) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var bufferLength, err_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bufferLength = buffer.length;
                        this.executingOutgoingHandlers++;
                        this.offset += bufferLength;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.outgoingHandler(buffer, this.offset - bufferLength)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.emitter.emit("error", err_1);
                        return [2 /*return*/];
                    case 4:
                        this.executingOutgoingHandlers--;
                        this.reuseBuffer(buffer);
                        this.emitter.emit("checkEnd");
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Return buffer used by outgoing handler into incoming.
     *
     * @param buffer -
     */
    BufferScheduler.prototype.reuseBuffer = function (buffer) {
        this.incoming.push(buffer);
        if (!this.isError && this.resolveData() && !this.isStreamEnd) {
            this.readable.resume();
        }
    };
    return BufferScheduler;
}());

// Copyright (c) Microsoft Corporation.
/**
 * Reads a readable stream into buffer. Fill the buffer from offset to end.
 *
 * @param stream - A Node.js Readable stream
 * @param buffer - Buffer to be filled, length must greater than or equal to offset
 * @param offset - From which position in the buffer to be filled, inclusive
 * @param end - To which position in the buffer to be filled, exclusive
 * @param encoding - Encoding of the Readable stream
 */
function streamToBuffer(stream, buffer, offset, end, encoding) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var pos, count;
        return tslib.__generator(this, function (_a) {
            pos = 0;
            count = end - offset;
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    stream.on("readable", function () {
                        if (pos >= count) {
                            resolve();
                            return;
                        }
                        var chunk = stream.read();
                        if (!chunk) {
                            return;
                        }
                        if (typeof chunk === "string") {
                            chunk = Buffer.from(chunk, encoding);
                        }
                        // How much data needed in this chunk
                        var chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
                        buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
                        pos += chunkLength;
                    });
                    stream.on("end", function () {
                        if (pos < count) {
                            reject(new Error("Stream drains before getting enough data needed. Data read: " + pos + ", data need: " + count));
                        }
                        resolve();
                    });
                    stream.on("error", reject);
                })];
        });
    });
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Writes the content of a readstream to a local file. Returns a Promise which is completed after the file handle is closed.
 *
 * @param rs - The read stream.
 * @param file - Destination file path.
 */
function readStreamToLocalFile(rs, file) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var ws = fs.createWriteStream(file);
                    rs.on("error", function (err) {
                        reject(err);
                    });
                    ws.on("error", function (err) {
                        reject(err);
                    });
                    ws.on("close", resolve);
                    rs.pipe(ws);
                })];
        });
    });
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Promisified version of fs.stat().
 */
var fsStat = util.promisify(fs.stat);
var fsCreateReadStream = fs.createReadStream;

// Copyright (c) Microsoft Corporation.
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 */
var ShareClient = /** @class */ (function (_super) {
    tslib.__extends(ShareClient, _super);
    function ShareClient(urlOrConnectionString, credentialOrPipelineOrShareName, options) {
        var _this = this;
        var pipeline;
        var url;
        if (credentialOrPipelineOrShareName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrShareName;
        }
        else if (credentialOrPipelineOrShareName instanceof Credential) {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrShareName, options);
        }
        else if (!credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName !== "string") {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName === "string") {
            // (connectionString: string, name: string, options?: StoragePipelineOptions)
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            var name_1 = credentialOrPipelineOrShareName;
            if (extractedCreds.kind === "AccountConnString") {
                {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, name_1);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url = appendToURLPath(extractedCreds.url, name_1) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for name parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._name = getShareNameAndPathFromUrl(_this.url).shareName;
        _this.context = new Share(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareClient.prototype, "name", {
        /**
         * The name of the share
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new ShareClient object identical to the source but with the specified snapshot timestamp
     */
    ShareClient.prototype.withSnapshot = function (snapshot) {
        return new ShareClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options - Options to Share Create operation.
     * @returns Response data for the Share Create operation.
     */
    ShareClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.create(tslib.__assign(tslib.__assign(tslib.__assign({}, options), { enabledProtocols: toShareProtocolsString(options.protocols) }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options -
     */
    ShareClient.prototype.createIfNotExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_2;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("ShareClient-createIfNotExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.create(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, tslib.__assign({ succeeded: true }, res)];
                    case 3:
                        e_2 = _d.sent();
                        if (((_a = e_2.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareAlreadyExists") {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when creating a share only if it doesn't already exist."
                            });
                            return [2 /*return*/, tslib.__assign(tslib.__assign({ succeeded: false }, (_b = e_2.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_2.response })];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName - A directory name
     * @returns The ShareDirectoryClient object for the given directory name.
     */
    ShareClient.prototype.getDirectoryClient = function (directoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    };
    Object.defineProperty(ShareClient.prototype, "rootDirectoryClient", {
        /**
         * Gets the directory client for the root directory of this share.
         * Note that the root directory always exists and cannot be deleted.
         *
         * @readonly A new ShareDirectoryClient object for the root directory.
         */
        get: function () {
            return this.getDirectoryClient("");
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory creation response data and the corresponding directory client.
     */
    ShareClient.prototype.createDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, directoryCreateResponse, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createDirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(updatedOptions)];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    ShareClient.prototype.deleteDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteDirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    ShareClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, fileClient, fileCreateResponse, e_5;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, updatedOptions)];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param directoryName -
     * @param fileName -
     * @param options - Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     */
    ShareClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, fileClient, e_6;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns true if the Azrue share resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing share might be deleted by other clients or
     * applications. Vice versa new shares might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    ShareClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_7;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties(updatedOptions)];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_7 = _b.sent();
                        if (e_7.statusCode === 404) {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when checking share existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns Response data for the Share Get Properties operation.
     */
    ShareClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, res, protocols, e_8;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getProperties(tslib.__assign(tslib.__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        res = _b.sent();
                        protocols = toShareProtocols(res.enabledProtocols);
                        res.protocols = protocols;
                        return [2 /*return*/, res];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options - Options to Share Delete operation.
     * @returns Response data for the Share Delete operation.
     */
    ShareClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_9;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.delete(tslib.__assign(tslib.__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Marks the specified share for deletion if it exists. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options -
     */
    ShareClient.prototype.deleteIfExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_10;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("ShareClient-deleteIfExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, tslib.__assign({ succeeded: true }, res)];
                    case 3:
                        e_10 = _d.sent();
                        if (((_a = e_10.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareNotFound") {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a share only if it exists."
                            });
                            return [2 /*return*/, tslib.__assign(tslib.__assign({ succeeded: false }, (_b = e_10.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_10.response })];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed.
     * @param option - Options to Share Set Metadata operation.
     * @returns Response data for the Share Set Metadata operation.
     */
    ShareClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_11;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata(tslib.__assign(tslib.__assign(tslib.__assign({}, options), { metadata: metadata }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param option - Options to Share Get Access Policy operation.
     * @returns Response data for the Share Get Access Policy operation.
     */
    ShareClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, res, _i, response_1, identifier, accessPolicy, e_12;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getAccessPolicy", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getAccessPolicy(tslib.__assign(tslib.__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            etag: response.etag,
                            lastModified: response.lastModified,
                            requestId: response.requestId,
                            signedIdentifiers: [],
                            version: response.version
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            accessPolicy = undefined;
                            if (identifier.accessPolicy) {
                                accessPolicy = {
                                    permissions: identifier.accessPolicy.permissions
                                };
                                if (identifier.accessPolicy.expiresOn) {
                                    accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                                }
                                if (identifier.accessPolicy.startsOn) {
                                    accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                                }
                            }
                            res.signedIdentifiers.push({
                                accessPolicy: accessPolicy,
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_12 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_12.message
                        });
                        throw e_12;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param shareAcl - Array of signed identifiers, each having a unique Id and details of access policy.
     * @param option - Options to Share Set Access Policy operation.
     * @returns Response data for the Share Set Access Policy operation.
     */
    ShareClient.prototype.setAccessPolicy = function (shareAcl, options) {
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _d, span, updatedOptions, acl, _i, _e, identifier, e_13;
            return tslib.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _d = createSpan("ShareClient-setAccessPolicy", options), span = _d.span, updatedOptions = _d.updatedOptions;
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 3, 4, 5]);
                        acl = [];
                        for (_i = 0, _e = shareAcl || []; _i < _e.length; _i++) {
                            identifier = _e[_i];
                            acl.push({
                                accessPolicy: {
                                    expiresOn: ((_a = identifier.accessPolicy) === null || _a === void 0 ? void 0 : _a.expiresOn)
                                        ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)
                                        : undefined,
                                    permissions: (_b = identifier.accessPolicy) === null || _b === void 0 ? void 0 : _b.permissions,
                                    startsOn: ((_c = identifier.accessPolicy) === null || _c === void 0 ? void 0 : _c.startsOn)
                                        ? truncatedISO8061Date(identifier.accessPolicy.startsOn)
                                        : undefined
                                },
                                id: identifier.id
                            });
                        }
                        return [4 /*yield*/, this.context.setAccessPolicy(tslib.__assign(tslib.__assign(tslib.__assign({}, options), { shareAcl: acl }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _f.sent()];
                    case 3:
                        e_13 = _f.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param options - Options to Share Create Snapshot operation.
     * @returns Response data for the Share Create Snapshot operation.
     */
    ShareClient.prototype.createSnapshot = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_14;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createSnapshot", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.createSnapshot(tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets quota for the specified share.
     *
     * @deprecated Use {@link ShareClient.setProperties} instead.
     *
     * @param quotaInGB - Specifies the maximum size of the share in gigabytes
     * @param option - Options to Share Set Quota operation.
     * @returns Response data for the Share Get Quota operation.
     */
    ShareClient.prototype.setQuota = function (quotaInGB, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_15;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setQuota", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setProperties(tslib.__assign(tslib.__assign(tslib.__assign({}, options), { quota: quotaInGB }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_15 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_15.message
                        });
                        throw e_15;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties of the share.
     *
     * @param option - Options to Share Set Properties operation.
     * @returns Response data for the Share Set Properties operation.
     */
    ShareClient.prototype.setProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_16;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setProperties(tslib.__assign(tslib.__assign({}, options), { quota: options.quotaInGB, tracingOptions: updatedOptions.tracingOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_16 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_16.message
                        });
                        throw e_16;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves statistics related to the share.
     *
     * @param option - Options to Share Get Statistics operation.
     * @returns Response data for the Share Get Statistics operation.
     */
    ShareClient.prototype.getStatistics = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, GBBytes, e_17;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getStatistics", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getStatistics(tslib.__assign(tslib.__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        GBBytes = 1024 * 1024 * 1024;
                        return [2 /*return*/, tslib.__assign(tslib.__assign({}, response), { shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) })];
                    case 3:
                        e_17 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_17.message
                        });
                        throw e_17;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermission - File permission described in the SDDL
     */
    ShareClient.prototype.createPermission = function (filePermission, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_18;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createPermission", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.createPermission({
                                permission: filePermission
                            }, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_18 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_18.message
                        });
                        throw e_18;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermissionKey - File permission key which indicates the security descriptor of the permission.
     */
    ShareClient.prototype.getPermission = function (filePermissionKey, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_19;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getPermission", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getPermission(filePermissionKey, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_19 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_19.message
                        });
                        throw e_19;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Only available for ShareClient constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    ShareClient.prototype.generateSasUrl = function (options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        var sas = generateFileSASQueryParameters(tslib.__assign({ shareName: this.name }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    };
    return ShareClient;
}(StorageClient));
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 */
var ShareDirectoryClient = /** @class */ (function (_super) {
    tslib.__extends(ShareDirectoryClient, _super);
    function ShareDirectoryClient(url, credentialOrPipeline, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._name = _a.baseName, _this._shareName = _a.shareName, _this._path = _a.path);
        _this.context = new Directory(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareDirectoryClient.prototype, "shareName", {
        /**
         * The share name corresponding to this directory client
         */
        get: function () {
            return this._shareName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "path", {
        /**
         * The full path of the directory
         */
        get: function () {
            return this._path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "name", {
        /**
         * The name of the directory
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options - Options to Directory Create operation.
     * @returns Response data for the Directory  operation.
     */
    ShareDirectoryClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, attributes, e_20;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.fileAttributes) {
                            options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                            attributes = new FileSystemAttributes();
                            attributes.directory = true;
                            options.fileAttributes = attributes;
                        }
                        return [4 /*yield*/, this.context.create(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), tslib.__assign({ abortSignal: options.abortSignal, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_20 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_20.message
                        });
                        throw e_20;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new directory under the specified share or parent directory if it does not already exists.
     * If the directory already exists, it is not modified.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options -
     */
    ShareDirectoryClient.prototype.createIfNotExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_21;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("ShareDirectoryClient-createIfNotExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.create(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, tslib.__assign({ succeeded: true }, res)];
                    case 3:
                        e_21 = _d.sent();
                        if (((_a = e_21.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceAlreadyExists") {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when creating a directory only if it does not already exist."
                            });
                            return [2 /*return*/, tslib.__assign(tslib.__assign({ succeeded: false }, (_b = e_21.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_21.response })];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_21.message
                        });
                        throw e_21;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param DirectoryProperties - Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     */
    ShareDirectoryClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_22;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-setProperties", properties), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                        return [4 /*yield*/, this.context.setProperties(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), tslib.__assign({ abortSignal: properties.abortSignal, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_22 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_22.message
                        });
                        throw e_22;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName - A subdirectory name
     * @returns The ShareDirectoryClient object for the given subdirectory name.
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    ShareDirectoryClient.prototype.getDirectoryClient = function (subDirectoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subDirectoryName)), this.pipeline);
    };
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory create response data and the corresponding DirectoryClient instance.
     */
    ShareDirectoryClient.prototype.createSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, directoryCreateResponse, e_23;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createSubdirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(updatedOptions)];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_23 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_23.message
                        });
                        throw e_23;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    ShareDirectoryClient.prototype.deleteSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, e_24;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteSubdirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_24 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_24.message
                        });
                        throw e_24;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    ShareDirectoryClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, fileClient, fileCreateResponse, e_25;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, updatedOptions)];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_25 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_25.message
                        });
                        throw e_25;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param fileName - Name of the file to delete
     * @param options - Options to File Delete operation.
     * @returns File deletion response data.
     */
    ShareDirectoryClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, fileClient, e_26;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_26 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_26.message
                        });
                        throw e_26;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param fileName - A file name.
     * @returns A new ShareFileClient object for the given file name.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareDirectoryClient.prototype.getFileClient = function (fileName) {
        return new ShareFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    /**
     * Returns true if the specified directory exists; false otherwise.
     *
     * NOTE: use this function with care since an existing directory might be deleted by other clients or
     * applications. Vice versa new directories might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    ShareDirectoryClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_27;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_27 = _b.sent();
                        if (e_27.statusCode === 404) {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when checking directory existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_27.message
                        });
                        throw e_27;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param options - Options to Directory Get Properties operation.
     * @returns Response data for the Directory Get Properties operation.
     */
    ShareDirectoryClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_28;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getProperties(tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_28 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_28.message
                        });
                        throw e_28;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options - Options to Directory Delete operation.
     * @returns Response data for the Directory Delete operation.
     */
    ShareDirectoryClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_29;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.delete(tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_29 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_29.message
                        });
                        throw e_29;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options -
     */
    ShareDirectoryClient.prototype.deleteIfExists = function (options) {
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _d, span, updatedOptions, res, e_30;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _d = createSpan("ShareDirectoryClient-deleteIfExists", options), span = _d.span, updatedOptions = _d.updatedOptions;
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _e.sent();
                        return [2 /*return*/, tslib.__assign({ succeeded: true }, res)];
                    case 3:
                        e_30 = _e.sent();
                        if (((_a = e_30.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                            ((_b = e_30.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a directory only if it exists."
                            });
                            return [2 /*return*/, tslib.__assign(tslib.__assign({ succeeded: false }, (_c = e_30.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e_30.response })];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_30.message
                        });
                        throw e_30;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to Directory Set Metadata operation.
     * @returns Response data for the Directory Set Metadata operation.
     */
    ShareDirectoryClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_31;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata(tslib.__assign({ abortSignal: options.abortSignal, metadata: metadata }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_31 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_31.message
                        });
                        throw e_31;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list files and directories operation.
     */
    ShareDirectoryClient.prototype.iterateFilesAndDirectoriesSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function iterateFilesAndDirectoriesSegments_1() {
            var listFilesAndDirectoriesResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listFilesAndDirectoriesSegment(marker, options))];
                    case 2:
                        listFilesAndDirectoriesResponse = _a.sent();
                        marker = listFilesAndDirectoriesResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listFilesAndDirectoriesResponse)];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @param options - Options to list files and directories operation.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listFilesAndDirectoriesItems_1() {
            var marker, _a, _b, listFilesAndDirectoriesResponse, _i, _c, file, _d, _e, directory, e_32_1;
            var e_32, _f;
            return tslib.__generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 15, 16, 21]);
                        _a = tslib.__asyncValues(this.iterateFilesAndDirectoriesSegments(marker, options));
                        _g.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _g.sent(), !_b.done)) return [3 /*break*/, 14];
                        listFilesAndDirectoriesResponse = _b.value;
                        _i = 0, _c = listFilesAndDirectoriesResponse.segment.fileItems;
                        _g.label = 4;
                    case 4:
                        if (!(_i < _c.length)) return [3 /*break*/, 8];
                        file = _c[_i];
                        return [4 /*yield*/, tslib.__await(tslib.__assign({ kind: "file" }, file))];
                    case 5: return [4 /*yield*/, _g.sent()];
                    case 6:
                        _g.sent();
                        _g.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8:
                        _d = 0, _e = listFilesAndDirectoriesResponse.segment.directoryItems;
                        _g.label = 9;
                    case 9:
                        if (!(_d < _e.length)) return [3 /*break*/, 13];
                        directory = _e[_d];
                        return [4 /*yield*/, tslib.__await(tslib.__assign({ kind: "directory" }, directory))];
                    case 10: return [4 /*yield*/, _g.sent()];
                    case 11:
                        _g.sent();
                        _g.label = 12;
                    case 12:
                        _d++;
                        return [3 /*break*/, 9];
                    case 13: return [3 /*break*/, 2];
                    case 14: return [3 /*break*/, 21];
                    case 15:
                        e_32_1 = _g.sent();
                        e_32 = { error: e_32_1 };
                        return [3 /*break*/, 21];
                    case 16:
                        _g.trys.push([16, , 19, 20]);
                        if (!(_b && !_b.done && (_f = _a.return))) return [3 /*break*/, 18];
                        return [4 /*yield*/, tslib.__await(_f.call(_a))];
                    case 17:
                        _g.sent();
                        _g.label = 18;
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        if (e_32) throw e_32.error;
                        return [7 /*endfinally*/];
                    case 20: return [7 /*endfinally*/];
                    case 21: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param options - Options to list files and directories operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectories = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        // AsyncIterableIterator to iterate over files and directories
        var iter = this.listFilesAndDirectoriesItems(options);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return tslib.__awaiter(this, void 0, void 0, function () {
                        return tslib.__generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateFilesAndDirectoriesSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Directory List Files and Directories Segment operation.
     * @returns Response data for the Directory List Files and Directories operation.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_33;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listFilesAndDirectoriesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.listFilesAndDirectoriesSegment(tslib.__assign(tslib.__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_33 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_33.message
                        });
                        throw e_33;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    ShareDirectoryClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function iterateHandleSegments_1() {
            var listHandlesResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    ShareDirectoryClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listHandleItems_1() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_34_1;
            var e_34, _d;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = tslib.__asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, tslib.__await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_34_1 = _e.sent();
                        e_34 = { error: e_34_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, tslib.__await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_34) throw e_34.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return tslib.__awaiter(this, void 0, void 0, function () {
                        return tslib.__generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    ShareDirectoryClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_35;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(tslib.__assign(tslib.__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_35 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_35.message
                        });
                        throw e_35;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options -
     */
    ShareDirectoryClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_36;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.forceCloseHandles("*", tslib.__assign(tslib.__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_36 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_36.message
                        });
                        throw e_36;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options -
     */
    ShareDirectoryClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, handlesClosed, numberOfHandlesFailedToClose, marker, response, e_37;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseAllHandles", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        numberOfHandlesFailedToClose = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, updatedOptions)];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);
                        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose }];
                    case 6:
                        e_37 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_37.message
                        });
                        throw e_37;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param aborter - Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param options -
     */
    ShareDirectoryClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_38;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseHandle", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (handleId === "*") {
                            throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                        }
                        return [4 /*yield*/, this.context.forceCloseHandles(handleId, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_38 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_38.message
                        });
                        throw e_38;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ShareDirectoryClient;
}(StorageClient));
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 */
var ShareFileClient = /** @class */ (function (_super) {
    tslib.__extends(ShareFileClient, _super);
    function ShareFileClient(url, credentialOrPipeline, options) {
        var _a;
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._name = _a.baseName, _this._shareName = _a.shareName, _this._path = _a.path);
        _this.context = new File(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareFileClient.prototype, "shareName", {
        /**
         * The share name corresponding to this file client
         */
        get: function () {
            return this._shareName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareFileClient.prototype, "path", {
        /**
         * The full path of the file
         */
        get: function () {
            return this._path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareFileClient.prototype, "name", {
        /**
         * The name of the file
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base ShareFileClient.
     *
     * @param shareSnapshot - The share snapshot timestamp.
     * @returns A new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     */
    ShareFileClient.prototype.withShareSnapshot = function (shareSnapshot) {
        return new ShareFileClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, shareSnapshot.length === 0 ? undefined : shareSnapshot), this.pipeline);
    };
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns Response data for the File Create  operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareFileClient.prototype.create = function (size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, attributes, e_39;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (size < 0 || size > FILE_MAX_SIZE_BYTES) {
                            throw new RangeError("File size must >= 0 and < " + FILE_MAX_SIZE_BYTES + ".");
                        }
                        options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                        if (!options.fileAttributes) {
                            attributes = new FileSystemAttributes();
                            attributes.none = true;
                            options.fileAttributes = attributes;
                        }
                        options.fileHttpHeaders = options.fileHttpHeaders || {};
                        return [4 /*yield*/, this.context.create(size, fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), tslib.__assign({ abortSignal: options.abortSignal, fileHttpHeaders: options.fileHttpHeaders, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_39 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_39.message
                        });
                        throw e_39;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `contentAsBlob`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param offset - From which position of the file to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Options to File Download operation.
     * @returns Response data for the File Download operation.
     *
     * Example usage (Node.js):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download();
     * console.log(
     *   "Downloaded file content:",
     *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}
     * );
     *
     * // A helper method used to read a Node.js readable stream into string
     * async function streamToBuffer(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browsers):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download(0);
     * console.log(
     *   "Downloaded file content:",
     *   await blobToString(await downloadFileResponse.blobBody)}
     * );
     *
     * // A helper method used to convert a browser Blob into string.
     * export async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    ShareFileClient.prototype.download = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, downloadFullFile, res_1, e_40;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-download", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {
                            throw new RangeError("rangeGetContentMD5 only works with partial data downloading");
                        }
                        downloadFullFile = offset === 0 && !count;
                        return [4 /*yield*/, this.context.download(tslib.__assign({ abortSignal: options.abortSignal, requestOptions: {
                                    onDownloadProgress: coreHttp.isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream
                                }, range: downloadFullFile ? undefined : rangeToString({ offset: offset, count: count }), rangeGetContentMD5: options.rangeGetContentMD5, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        res_1 = _b.sent();
                        // Return browser response immediately
                        if (!coreHttp.isNode) {
                            return [2 /*return*/, res_1];
                        }
                        // We support retrying when download stream unexpected ends in Node.js runtime
                        // Following code shouldn't be bundled into browser build, however some
                        // bundlers may try to bundle following code and "FileReadResponse.ts".
                        // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
                        // The config is in package.json "browser" field
                        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                            // TODO: Default value or make it a required parameter?
                            options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
                        }
                        if (res_1.contentLength === undefined) {
                            throw new RangeError("File download response doesn't contain valid content length header");
                        }
                        return [2 /*return*/, new FileDownloadResponse(res_1, function (start) { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var updatedOptions, downloadRes;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            updatedOptions = {
                                                range: rangeToString({
                                                    count: offset + res_1.contentLength - start,
                                                    offset: start
                                                })
                                            };
                                            return [4 /*yield*/, this.context.download(tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, updatedOptions), convertTracingToRequestOptionsBase(updatedOptions)))];
                                        case 1:
                                            downloadRes = _a.sent();
                                            if (!(downloadRes.etag === res_1.etag)) {
                                                throw new Error("File has been modified concurrently");
                                            }
                                            return [2 /*return*/, downloadRes.readableStreamBody];
                                    }
                                });
                            }); }, offset, res_1.contentLength, {
                                abortSignal: options.abortSignal,
                                maxRetryRequests: options.maxRetryRequests,
                                onProgress: options.onProgress
                            })];
                    case 3:
                        e_40 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_40.message
                        });
                        throw e_40;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns true if the specified file exists; false otherwise.
     *
     * NOTE: use this function with care since an existing file might be deleted by other clients or
     * applications. Vice versa new files might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    ShareFileClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_41;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: tslib.__assign(tslib.__assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_41 = _b.sent();
                        if (e_41.statusCode === 404) {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when checking file existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_41.message
                        });
                        throw e_41;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param options - Options to File Get Properties operation.
     * @returns Response data for the File Get Properties operation.
     */
    ShareFileClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                try {
                    return [2 /*return*/, this.context.getProperties(tslib.__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param properties - File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     */
    ShareFileClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_42;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-setProperties", properties), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                        properties.fileHttpHeaders = properties.fileHttpHeaders || {};
                        return [4 /*yield*/, this.context.setHttpHeaders(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), tslib.__assign({ abortSignal: properties.abortSignal, fileHttpHeaders: properties.fileHttpHeaders, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey, leaseAccessConditions: properties.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_42 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_42.message
                        });
                        throw e_42;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options - Options to File Delete operation.
     * @returns Response data for the File Delete operation.
     */
    ShareFileClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_43;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.delete(tslib.__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_43 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_43.message
                        });
                        throw e_43;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the file from the storage account if it exists.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options -
     */
    ShareFileClient.prototype.deleteIfExists = function (options) {
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _d, span, updatedOptions, res, e_44;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _d = createSpan("ShareFileClient-deleteIfExists", options), span = _d.span, updatedOptions = _d.updatedOptions;
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _e.sent();
                        return [2 /*return*/, tslib.__assign({ succeeded: true }, res)];
                    case 3:
                        e_44 = _e.sent();
                        if (((_a = e_44.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                            ((_b = e_44.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                            span.setStatus({
                                code: coreTracing.SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a file only if it exists."
                            });
                            return [2 /*return*/, tslib.__assign(tslib.__assign({ succeeded: false }, (_c = e_44.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e_44.response })];
                        }
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_44.message
                        });
                        throw e_44;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param FileHttpHeaders - File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param options - Options to File Set HTTP Headers operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    ShareFileClient.prototype.setHttpHeaders = function (fileHttpHeaders, options) {
        if (fileHttpHeaders === void 0) { fileHttpHeaders = {}; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_45;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-setHTTPHeaders", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved
                        options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                        return [4 /*yield*/, this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), tslib.__assign({ abortSignal: options.abortSignal, fileHttpHeaders: fileHttpHeaders, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_45 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_45.message
                        });
                        throw e_45;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param length - Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param options - Options to File Resize operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    ShareFileClient.prototype.resize = function (length, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_46;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-resize", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (length < 0) {
                            throw new RangeError("Size cannot less than 0 when resizing file.");
                        }
                        // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.
                        options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                        return [4 /*yield*/, this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), tslib.__assign({ abortSignal: options.abortSignal, fileContentLength: length, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_46 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_46.message
                        });
                        throw e_46;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to File Set Metadata operation.
     * @returns Response data for the File Set Metadata operation.
     */
    ShareFileClient.prototype.setMetadata = function (metadata, options) {
        if (metadata === void 0) { metadata = {}; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_47;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata(tslib.__assign({ abortSignal: options.abortSignal, metadata: metadata, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_47 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_47.message
                        });
                        throw e_47;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Upload a range of bytes to a file. This operation can only be called on an existing file.
     * It won't change the size, properties or metadata of the file.
     * Both the start and count of the range must be specified. The range can be up to 4 MB in size.
     *
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param offset - Offset position of the destination Azure File to upload.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to File Upload Range operation.
     * @returns Response data for the File Upload Range operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareFileClient.prototype.uploadRange = function (body, offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_48;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadRange", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (offset < 0) {
                            throw new RangeError("offset must be >= 0");
                        }
                        if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("contentLength must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                        }
                        if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("offset must be < " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                        }
                        return [4 /*yield*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "update", contentLength, tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal, contentMD5: options.contentMD5, requestOptions: {
                                    onUploadProgress: options.onProgress
                                }, body: body }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_48 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_48.message
                        });
                        throw e_48;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param destOffset - Offset of destination file.
     * @param count - Number of bytes to be uploaded from source file.
     * @param options - Options to configure File - Upload Range from URL operation.
     */
    ShareFileClient.prototype.uploadRangeFromURL = function (sourceURL, sourceOffset, destOffset, count, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_49;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadRangeFromURL", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (sourceOffset < 0 || destOffset < 0) {
                            throw new RangeError("sourceOffset and destOffset must be >= 0");
                        }
                        if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("count must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                        }
                        return [4 /*yield*/, this.context.uploadRangeFromURL(rangeToString({ offset: destOffset, count: count }), sourceURL, 0, tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal, sourceRange: rangeToString({ offset: sourceOffset, count: count }), sourceModifiedAccessConditions: options.sourceConditions }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_49 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_49.message
                        });
                        throw e_49;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param offset -
     * @param contentLength -
     * @param options - Options to File Clear Range operation.
     */
    ShareFileClient.prototype.clearRange = function (offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_50;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-clearRange", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (offset < 0 || contentLength <= 0) {
                            throw new RangeError("offset must >= 0 and contentLength must be > 0");
                        }
                        return [4 /*yield*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "clear", 0, tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_50 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_50.message
                        });
                        throw e_50;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param options - Options to File Get range List operation.
     */
    ShareFileClient.prototype.getRangeList = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, originalResponse, parsedBody, e_51;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-getRangeList", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getRangeList(tslib.__assign({ abortSignal: options.abortSignal, range: options.range ? rangeToString(options.range) : undefined, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        originalResponse = _b.sent();
                        parsedBody = originalResponse._response.parsedBody.ranges
                            ? originalResponse._response.parsedBody.ranges
                            : [];
                        return [2 /*return*/, tslib.__assign(tslib.__assign({}, originalResponse), { _response: tslib.__assign(tslib.__assign({}, originalResponse._response), { parsedBody: parsedBody }), rangeList: originalResponse.ranges ? originalResponse.ranges : [] })];
                    case 3:
                        e_51 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_51.message
                        });
                        throw e_51;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the list of ranges that differ between a previous share snapshot and this file.
     *
     * @param prevShareSnapshot - The previous snapshot parameter is an opaque DateTime value that specifies the previous share snapshot to compare with.
     * @param options -
     */
    ShareFileClient.prototype.getRangeListDiff = function (prevShareSnapshot, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_52;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-getRangeListDiff", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getRangeList(tslib.__assign(tslib.__assign(tslib.__assign({ prevsharesnapshot: prevShareSnapshot }, options), { range: options.range ? rangeToString(options.range) : undefined }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_52 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_52.message
                        });
                        throw e_52;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param copySource - Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param options - Options to File Start Copy operation.
     */
    ShareFileClient.prototype.startCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_53;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-startCopyFromURL", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.startCopy(copySource, tslib.__assign({ abortSignal: options.abortSignal, metadata: options.metadata, leaseAccessConditions: options.leaseAccessConditions, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, copyFileSmbInfo: options.copyFileSmbInfo }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_53 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_53.message
                        });
                        throw e_53;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param copyId - Id of the Copy File operation to abort.
     * @param options - Options to File Abort Copy From URL operation.
     */
    ShareFileClient.prototype.abortCopyFromURL = function (copyId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_54;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-abortCopyFromURL", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.abortCopy(copyId, tslib.__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_54 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_54.message
                        });
                        throw e_54;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    // High Level functions
    /**
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to it.
     *
     * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView
     * @param options -
     */
    ShareFileClient.prototype.uploadData = function (data, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, buffer_1, browserBlob_1;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadData", options), span = _a.span, updatedOptions = _a.updatedOptions;
                try {
                    if (true) {
                        if (data instanceof Buffer) {
                            buffer_1 = data;
                        }
                        else if (data instanceof ArrayBuffer) {
                            buffer_1 = Buffer.from(data);
                        }
                        else {
                            data = data;
                            buffer_1 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                        }
                        return [2 /*return*/, this.uploadSeekableInternal(function (offset, size) { return buffer_1.slice(offset, offset + size); }, buffer_1.byteLength, updatedOptions)];
                    }
                    else {
                        browserBlob_1 = new Blob([data]);
                        return [2 /*return*/, this.uploadSeekableInternal(function (offset, size) { return browserBlob_1.slice(offset, offset + size); }, browserBlob_1.size, updatedOptions)];
                    }
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param blobFactory -
     * @param size -
     * @param options -
     */
    ShareFileClient.prototype.uploadSeekableBlob = function (blobFactory, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions;
            return tslib.__generator(this, function (_b) {
                _a = createSpan("ShareFileClient-UploadSeekableBlob", options), span = _a.span, updatedOptions = _a.updatedOptions;
                try {
                    return [2 /*return*/, this.uploadSeekableInternal(blobFactory, size, updatedOptions)];
                }
                catch (e) {
                    span.setStatus({
                        code: coreTracing.SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a local file to it.
     *
     * @param filePath - Full path of local file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    ShareFileClient.prototype.uploadFile = function (filePath, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, size, e_55;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        return [4 /*yield*/, fsStat(filePath)];
                    case 2:
                        size = (_b.sent()).size;
                        return [4 /*yield*/, this.uploadSeekableInternal(function (offset, count) {
                                return function () {
                                    return fsCreateReadStream(filePath, {
                                        autoClose: true,
                                        end: count ? offset + count - 1 : Infinity,
                                        start: offset
                                    });
                                };
                            }, size, updatedOptions)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        e_55 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_55.message
                        });
                        throw e_55;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @param streamFactory - Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    ShareFileClient.prototype.uploadResetableStream = function (streamFactory, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_56;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadResetableStream", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.uploadSeekableInternal(function (offset, count) {
                                return function () { return streamFactory(offset, count); };
                            }, size, updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_56 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_56.message
                        });
                        throw e_56;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     * @param bodyFactory -
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    ShareFileClient.prototype.uploadSeekableInternal = function (bodyFactory, size, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, numBlocks_1, transferProgress_1, batch, _loop_1, i, e_57;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadSeekableInternal", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("options.rangeSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                leaseAccessConditions: options.leaseAccessConditions,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        numBlocks_1 = Math.floor((size - 1) / options.rangeSize) + 1;
                        transferProgress_1 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_1 = function (i) {
                            batch.addOperation(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var start, end, contentLength;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            start = options.rangeSize * i;
                                            end = i === numBlocks_1 - 1 ? size : start + options.rangeSize;
                                            contentLength = end - start;
                                            return [4 /*yield*/, this.uploadRange(bodyFactory(start, contentLength), start, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    leaseAccessConditions: options.leaseAccessConditions,
                                                    tracingOptions: updatedOptions.tracingOptions
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            transferProgress_1 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_1 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_1; i++) {
                            _loop_1(i);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        e_57 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_57.message
                        });
                        throw e_57;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    ShareFileClient.prototype.downloadToBuffer = function (bufferOrOffset, offsetOrCount, countOrOptions, optOptions) {
        if (optOptions === void 0) { optOptions = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var buffer, offset, count, options, _a, span, updatedOptions, response, transferProgress_2, batch, _loop_2, off, e_58;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        buffer = undefined;
                        options = optOptions;
                        if (bufferOrOffset instanceof Buffer) {
                            buffer = bufferOrOffset;
                            offset = offsetOrCount || 0;
                            count = typeof countOrOptions === "number" ? countOrOptions : 0;
                        }
                        else {
                            offset = typeof bufferOrOffset === "number" ? bufferOrOffset : 0;
                            count = typeof offsetOrCount === "number" ? offsetOrCount : 0;
                            options = countOrOptions || {};
                        }
                        _a = createSpan("ShareFileClient-downloadToBuffer", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0) {
                            throw new RangeError("rangeSize option must be > 0");
                        }
                        if (offset < 0) {
                            throw new RangeError("offset option must be >= 0");
                        }
                        if (count && count <= 0) {
                            throw new RangeError("count option must be > 0");
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        if (!!count) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                leaseAccessConditions: options.leaseAccessConditions,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        response = _b.sent();
                        count = response.contentLength - offset;
                        if (count < 0) {
                            throw new RangeError("offset " + offset + " shouldn't be larger than file size " + response.contentLength);
                        }
                        _b.label = 3;
                    case 3:
                        if (!buffer) {
                            try {
                                buffer = Buffer.alloc(count);
                            }
                            catch (error) {
                                throw new Error("Unable to allocate a buffer of size: " + count + " bytes. Please try passing your own Buffer to " +
                                    'the "downloadToBuffer method or try using other methods like "download" or "downloadToFile".' +
                                    ("\t " + error.message));
                            }
                        }
                        if (buffer.length < count) {
                            throw new RangeError("The buffer's size should be equal to or larger than the request count of bytes: " + count);
                        }
                        transferProgress_2 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_2 = function (off) {
                            batch.addOperation(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
                                var chunkEnd, response, stream;
                                return tslib.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            chunkEnd = offset + count;
                                            if (off + options.rangeSize < chunkEnd) {
                                                chunkEnd = off + options.rangeSize;
                                            }
                                            return [4 /*yield*/, this.download(off, chunkEnd - off, {
                                                    abortSignal: options.abortSignal,
                                                    maxRetryRequests: options.maxRetryRequestsPerRange,
                                                    leaseAccessConditions: options.leaseAccessConditions,
                                                    tracingOptions: updatedOptions.tracingOptions
                                                })];
                                        case 1:
                                            response = _a.sent();
                                            stream = response.readableStreamBody;
                                            return [4 /*yield*/, streamToBuffer(stream, buffer, off - offset, chunkEnd - offset)];
                                        case 2:
                                            _a.sent();
                                            // Update progress after block is downloaded, in case of block trying
                                            // Could provide finer grained progress updating inside HTTP requests,
                                            // only if convenience layer download try is enabled
                                            transferProgress_2 += chunkEnd - off;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_2 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (off = offset; off < offset + count; off = off + options.rangeSize) {
                            _loop_2(off);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 4:
                        _b.sent();
                        return [2 /*return*/, buffer];
                    case 5:
                        e_58 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_58.message
                        });
                        throw e_58;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Node.js Readable stream into it.
     * This method will try to create an Azure File, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param stream - Node.js Readable stream. Must be less or equal than file size.
     * @param size - Size of file to be created. Maximum size allowed is 4 TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param bufferSize - Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be greater than 0 and lesser than or equal to 4 * 1024 * 1024 (4MB)
     * @param maxBuffers - Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param options -
     */
    ShareFileClient.prototype.uploadStream = function (stream, size, bufferSize, maxBuffers, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, transferProgress_3, scheduler, e_59;
            var _this = this;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadStream", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("bufferSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (maxBuffers < 0) {
                            throw new RangeError("maxBuffers must be > 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                leaseAccessConditions: options.leaseAccessConditions,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        transferProgress_3 = 0;
                        scheduler = new BufferScheduler(stream, bufferSize, maxBuffers, function (buffer, offset) { return tslib.__awaiter(_this, void 0, void 0, function () {
                            return tslib.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (transferProgress_3 + buffer.length > size) {
                                            throw new RangeError("Stream size is larger than file size " + size + " bytes, uploading failed. " +
                                                "Please make sure stream length is less or equal than file size.");
                                        }
                                        return [4 /*yield*/, this.uploadRange(buffer, offset, buffer.length, {
                                                abortSignal: options.abortSignal,
                                                leaseAccessConditions: options.leaseAccessConditions,
                                                tracingOptions: updatedOptions.tracingOptions
                                            })];
                                    case 1:
                                        _a.sent();
                                        // Update progress after block is successfully uploaded to server, in case of block trying
                                        transferProgress_3 += buffer.length;
                                        if (options.onProgress) {
                                            options.onProgress({ loadedBytes: transferProgress_3 });
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 
                        // Concurrency should set a smaller value than maxBuffers, which is helpful to
                        // reduce the possibility when a outgoing handler waits for stream data, in
                        // this situation, outgoing handlers are blocked.
                        // Outgoing queue shouldn't be empty.
                        Math.ceil((maxBuffers / 4) * 3));
                        return [4 /*yield*/, scheduler.do()];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        e_59 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_59.message
                        });
                        throw e_59;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param filePath -
     * @param offset - From which position of the block blob to download.
     * @param count - How much data to be downloaded. Will download to the end when passing undefined.
     * @param options - Options to Blob download options.
     * @returns The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     */
    ShareFileClient.prototype.downloadToFile = function (filePath, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_60;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-downloadToFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        return [4 /*yield*/, this.download(offset, count, updatedOptions)];
                    case 2:
                        response = _b.sent();
                        if (!response.readableStreamBody) return [3 /*break*/, 4];
                        return [4 /*yield*/, readStreamToLocalFile(response.readableStreamBody, filePath)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        // The stream is no longer accessible so setting it to undefined.
                        response.fileDownloadStream = undefined;
                        return [2 /*return*/, response];
                    case 5:
                        e_60 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_60.message
                        });
                        throw e_60;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    ShareFileClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_61;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-listHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(tslib.__assign(tslib.__assign({ abortSignal: options.abortSignal, marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_61 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_61.message
                        });
                        throw e_61;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    ShareFileClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function iterateHandleSegments_2() {
            var listHandlesResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    ShareFileClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listHandleItems_2() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_62_1;
            var e_62, _d;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = tslib.__asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, tslib.__await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_62_1 = _e.sent();
                        e_62 = { error: e_62_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, tslib.__await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_62) throw e_62.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    ShareFileClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return tslib.__awaiter(this, void 0, void 0, function () {
                        return tslib.__generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, tslib.__assign({ maxPageSize: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options - Options to force close handles operation.
     */
    ShareFileClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_63;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.forceCloseHandles("*", tslib.__assign({ abortSignal: options.abortSignal, marker: marker }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_63 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_63.message
                        });
                        throw e_63;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options - Options to force close handles operation.
     */
    ShareFileClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, handlesClosed, numberOfHandlesFailedToClose, marker, response, e_64;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseAllHandles", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        numberOfHandlesFailedToClose = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, { tracingOptions: updatedOptions.tracingOptions })];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);
                        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, {
                            closedHandlesCount: handlesClosed,
                            closeFailureCount: numberOfHandlesFailedToClose
                        }];
                    case 6:
                        e_64 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_64.message
                        });
                        throw e_64;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param FileForceCloseHandlesOptions - Options to force close handles operation.
     */
    ShareFileClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_65;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseHandle", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (handleId === "*") {
                            throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                        }
                        return [4 /*yield*/, this.context.forceCloseHandles(handleId, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_65 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_65.message
                        });
                        throw e_65;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a {@link ShareLeaseClient} that manages leases on the file.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new ShareLeaseClient object for managing leases on the file.
     */
    ShareFileClient.prototype.getShareLeaseClient = function (proposeLeaseId) {
        return new ShareLeaseClient(this, proposeLeaseId);
    };
    /**
     * Only available for clients constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    ShareFileClient.prototype.generateSasUrl = function (options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        var sas = generateFileSASQueryParameters(tslib.__assign({ shareName: this.shareName, filePath: this.path }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    };
    return ShareFileClient;
}(StorageClient));
/**
 * A client that manages leases for a {@link ShareFileClient} or {@link ShareClient}.
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-file
 * and
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-share
 */
var ShareLeaseClient = /** @class */ (function () {
    /**
     * Creates an instance of ShareLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */
    function ShareLeaseClient(client, leaseId) {
        var clientContext = new StorageClientContext(client.url, tslib.__assign({ version: SERVICE_VERSION }, client.pipeline.toServiceClientOptions()));
        if (client instanceof ShareClient) {
            this.isShare = true;
            this.fileOrShare = new Share(clientContext);
        }
        else {
            this.isShare = false;
            this.fileOrShare = new File(clientContext);
        }
        this._url = client.url;
        if (!leaseId) {
            leaseId = coreHttp.generateUuid();
        }
        this._leaseId = leaseId;
    }
    Object.defineProperty(ShareLeaseClient.prototype, "leaseId", {
        /**
         * Gets the lease Id.
         *
         * @readonly
         */
        get: function () {
            return this._leaseId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareLeaseClient.prototype, "url", {
        /**
         * Gets the url.
         *
         * @readonly
         */
        get: function () {
            return this._url;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Establishes and manages a lock on a file, share or share snapshot for write and delete operations.
     *
     * @param duration - Specifies the duration of lease in seconds. For file, the only allowed value is -1 for a lease that never expires. For share, must be -1 or between 15 to 60.
     * @param options - Options for the lease management operation.
     * @returns Response data for acquire lease operation.
     */
    ShareLeaseClient.prototype.acquireLease = function (duration, options) {
        if (duration === void 0) { duration = -1; }
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_66;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-acquireLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.acquireLease(tslib.__assign({ abortSignal: options.abortSignal, duration: duration, proposedLeaseId: this._leaseId }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_66 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_66.message
                        });
                        throw e_66;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To change the ID of an existing lease.
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - Options for the lease management operation.
     * @returns Response data for change lease operation.
     */
    ShareLeaseClient.prototype.changeLease = function (proposedLeaseId, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_67;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-changeLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.changeLease(this._leaseId, tslib.__assign({ proposedLeaseId: proposedLeaseId, abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        this._leaseId = proposedLeaseId;
                        return [2 /*return*/, response];
                    case 3:
                        e_67 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_67.message
                        });
                        throw e_67;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for release lease operation.
     */
    ShareLeaseClient.prototype.releaseLease = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_68;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-releaseLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.releaseLease(this._leaseId, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_68 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_68.message
                        });
                        throw e_68;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To force end the lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for break lease operation.
     */
    ShareLeaseClient.prototype.breakLease = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_69;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-breakLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.breakLease(tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_69 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_69.message
                        });
                        throw e_69;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To renew the lease. Only available for lease on share or share snapshot.
     * Note that the lease may be renewed even if it has expired as long as the share has not been leased again since the expiration of that lease.
     * When you renew a lease, the lease duration clock resets.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for renew lease operation.
     */
    ShareLeaseClient.prototype.renewLease = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_70;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-renewLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        if (!this.isShare) {
                            throw new RangeError("The renewLease operation is not available for lease on file.");
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.renewLease(this._leaseId, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_70 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_70.message
                        });
                        throw e_70;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ShareLeaseClient;
}());

// Copyright (c) Microsoft Corporation.
/**
 * ShareClientInternal is the thin wrapper for Share which contains internal helper methods.
 */
var ShareClientInternal = /** @class */ (function (_super) {
    tslib.__extends(ShareClientInternal, _super);
    function ShareClientInternal(url, pipeline) {
        var _this = _super.call(this, url, pipeline) || this;
        _this.context = new Share(_this.storageClientContext);
        return _this;
    }
    ShareClientInternal.prototype.restore = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.context.restore(options)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return ShareClientInternal;
}(StorageClient));

// Copyright (c) Microsoft Corporation.
/**
 * A ShareServiceClient represents a URL to the Azure Storage File service allowing you
 * to manipulate file shares.
 */
var ShareServiceClient = /** @class */ (function (_super) {
    tslib.__extends(ShareServiceClient, _super);
    function ShareServiceClient(url, credentialOrPipeline, options) {
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        _this.serviceContext = new Service(_this.storageClientContext);
        return _this;
    }
    /**
     *
     * Creates an instance of ShareServiceClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Options to configure the HTTP pipeline.
     * @returns A new ShareServiceClient from the given connection string.
     */
    ShareServiceClient.fromConnectionString = function (connectionString, options) {
        var extractedCreds = extractConnectionStringParts(connectionString);
        if (extractedCreds.kind === "AccountConnString") {
            {
                var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                var pipeline = newPipeline(sharedKeyCredential, options);
                return new ShareServiceClient(extractedCreds.url, pipeline);
            }
        }
        else if (extractedCreds.kind === "SASConnString") {
            var pipeline = newPipeline(new AnonymousCredential(), options);
            return new ShareServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
        }
        else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
    };
    /**
     * Creates a ShareClient object.
     *
     * @param shareName - Name of a share.
     * @returns The ShareClient object for the given share name.
     *
     * Example usage:
     *
     * ```js
     * const shareClient = serviceClient.getShareClient("<share name>");
     * await shareClient.create();
     * console.log("Created share successfully!");
     * ```
     */
    ShareServiceClient.prototype.getShareClient = function (shareName) {
        return new ShareClient(appendToURLPath(this.url, shareName), this.pipeline);
    };
    /**
     * Creates a Share.
     *
     * @param shareName -
     * @param options -
     * @returns Share creation response and the corresponding share client.
     */
    ShareServiceClient.prototype.createShare = function (shareName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, shareClient, shareCreateResponse, e_1;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-createShare", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        shareClient = this.getShareClient(shareName);
                        return [4 /*yield*/, shareClient.create(updatedOptions)];
                    case 2:
                        shareCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                shareCreateResponse: shareCreateResponse,
                                shareClient: shareClient
                            }];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deletes a Share.
     *
     * @param shareName -
     * @param options -
     * @returns Share deletion response and the corresponding share client.
     */
    ShareServiceClient.prototype.deleteShare = function (shareName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, shareClient, e_2;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-deleteShare", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        shareClient = this.getShareClient(shareName);
                        return [4 /*yield*/, shareClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the properties of a storage accounts file service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-service-properties
     *
     * @param options - Options to Get Properties operation.
     * @returns Response data for the Get Properties operation.
     */
    ShareServiceClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_3;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.getProperties(tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties for a storage accounts file service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-service-properties
     *
     * @param properties -
     * @param options - Options to Set Properties operation.
     * @returns Response data for the Set Properties operation.
     */
    ShareServiceClient.prototype.setProperties = function (properties, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_4;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-setProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.setProperties(properties, tslib.__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link ServiceListSharesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of shares to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all shares remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list shares operation.
     */
    ShareServiceClient.prototype.listSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listSegments_1() {
            var listSharesSegmentResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _a.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(this.listSharesSegment(marker, options))];
                    case 2:
                        listSharesSegmentResponse = _a.sent();
                        marker = listSharesSegmentResponse.continuationToken;
                        return [4 /*yield*/, tslib.__await(listSharesSegmentResponse)];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for share items
     *
     * @param options - Options to list shares operation.
     */
    ShareServiceClient.prototype.listItems = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listItems_1() {
            var marker, _a, _b, segment, e_5_1;
            var e_5, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 8, 9, 14]);
                        _a = tslib.__asyncValues(this.listSegments(marker, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 7];
                        segment = _b.value;
                        if (!segment.shareItems) return [3 /*break*/, 6];
                        return [5 /*yield**/, tslib.__values(tslib.__asyncDelegator(tslib.__asyncValues(segment.shareItems)))];
                    case 4: return [4 /*yield*/, tslib.__await.apply(void 0, [_d.sent()])];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6: return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_5_1 = _d.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _d.trys.push([9, , 12, 13]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 10:
                        _d.sent();
                        _d.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the shares
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the shares in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const share of serviceClient.listShares()) {
     *   console.log(`Share ${i++}: ${share.name}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = serviceClient.listShares();
     * let shareItem = await iter.next();
     * while (!shareItem.done) {
     *   console.log(`Share ${i++}: ${shareItem.value.name}`);
     *   shareItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of serviceClient.listShares().byPage({ maxPageSize: 20 })) {
     *   if (response.shareItems) {
     *    for (const share of response.shareItems) {
     *        console.log(`Share ${i++}: ${share.name}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = serviceClient.listShares().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = serviceClient.listShares().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list shares operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    ShareServiceClient.prototype.listShares = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        var include = [];
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        if (options.includeDeleted) {
            include.push("deleted");
        }
        var updatedOptions = tslib.__assign(tslib.__assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over queues
        var iter = this.listItems(updatedOptions);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return iter.next();
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSegments(settings.continuationToken, tslib.__assign({ maxResults: settings.maxPageSize }, updatedOptions));
            },
            _a;
    };
    /**
     * Gets the properties of a storage account's File service, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     *
     * @param marker - A string value that identifies the portion of
     *                          the list to be returned with the next list operation. The operation
     *                          returns a marker value within the response body if the list returned was
     *                          not complete. The marker value may then be used in a subsequent call to
     *                          request the next set of list items. The marker value is opaque to the
     *                          client.
     * @param options - Options to List Shares Segment operation.
     * @returns Response data for the List Shares Segment operation.
     */
    ShareServiceClient.prototype.listSharesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, res, i, protocolsStr, e_6;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-listSharesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.listSharesSegment(tslib.__assign(tslib.__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        res = _b.sent();
                        // parse protocols
                        if (res.shareItems) {
                            for (i = 0; i < res.shareItems.length; i++) {
                                protocolsStr = res.shareItems[i].properties.enabledProtocols;
                                res.shareItems[i].properties.protocols = toShareProtocols(protocolsStr);
                            }
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Restores a previously deleted share.
     * This API is only functional if Share Soft Delete is enabled
     * for the storage account associated with the share.
     *
     * @param deletedShareName - The name of the previously deleted share.
     * @param deletedShareVersion - The version of the previously deleted share.
     * @param options - Options to Share undelete operation.
     * @returns Restored share.
     */
    ShareServiceClient.prototype.undeleteShare = function (deletedShareName, deletedShareVersion, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, shareClient, e_7;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareServiceClient-undeleteShare", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        shareClient = this.getShareClient(deletedShareName);
                        return [4 /*yield*/, new ShareClientInternal(shareClient.url, this.pipeline).restore(tslib.__assign({ deletedShareName: deletedShareName, deletedShareVersion: deletedShareVersion, abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, shareClient];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: coreTracing.SpanStatusCode.ERROR,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Only available for ShareServiceClient constructed with a shared key credential.
     *
     * Generates an account Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not specified.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    ShareServiceClient.prototype.generateAccountSasUrl = function (expiresOn, permissions, resourceTypes, options) {
        if (permissions === void 0) { permissions = AccountSASPermissions.parse("r"); }
        if (resourceTypes === void 0) { resourceTypes = "sco"; }
        if (options === void 0) { options = {}; }
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
        }
        if (expiresOn === undefined) {
            var now = new Date();
            expiresOn = new Date(now.getTime() + 3600 * 1000);
        }
        var sas = generateAccountSASQueryParameters(tslib.__assign({ permissions: permissions,
            expiresOn: expiresOn,
            resourceTypes: resourceTypes, services: AccountSASServices.parse("f").toString() }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    };
    return ShareServiceClient;
}(StorageClient));

Object.defineProperty(exports, 'BaseRequestPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.BaseRequestPolicy;
    }
});
Object.defineProperty(exports, 'HttpHeaders', {
    enumerable: true,
    get: function () {
        return coreHttp.HttpHeaders;
    }
});
Object.defineProperty(exports, 'RequestPolicyOptions', {
    enumerable: true,
    get: function () {
        return coreHttp.RequestPolicyOptions;
    }
});
Object.defineProperty(exports, 'RestError', {
    enumerable: true,
    get: function () {
        return coreHttp.RestError;
    }
});
Object.defineProperty(exports, 'WebResource', {
    enumerable: true,
    get: function () {
        return coreHttp.WebResource;
    }
});
Object.defineProperty(exports, 'deserializationPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.deserializationPolicy;
    }
});
exports.AccountSASPermissions = AccountSASPermissions;
exports.AccountSASResourceTypes = AccountSASResourceTypes;
exports.AccountSASServices = AccountSASServices;
exports.AnonymousCredential = AnonymousCredential;
exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
exports.Credential = Credential;
exports.CredentialPolicy = CredentialPolicy;
exports.FileSASPermissions = FileSASPermissions;
exports.FileSystemAttributes = FileSystemAttributes;
exports.Pipeline = Pipeline;
exports.SASQueryParameters = SASQueryParameters;
exports.ShareClient = ShareClient;
exports.ShareDirectoryClient = ShareDirectoryClient;
exports.ShareFileClient = ShareFileClient;
exports.ShareLeaseClient = ShareLeaseClient;
exports.ShareSASPermissions = ShareSASPermissions;
exports.ShareServiceClient = ShareServiceClient;
exports.StorageBrowserPolicy = StorageBrowserPolicy;
exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
exports.StorageRetryPolicy = StorageRetryPolicy;
exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
exports.generateFileSASQueryParameters = generateFileSASQueryParameters;
exports.logger = logger;
exports.newPipeline = newPipeline;
//# sourceMappingURL=index.js.map

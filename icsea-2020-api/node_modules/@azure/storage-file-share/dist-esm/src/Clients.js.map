{"version":3,"file":"Clients.js","sourceRoot":"","sources":["../../src/Clients.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpRequestBody, HttpResponse, isNode, TransferProgressEvent } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  CopyFileSmbInfo,\n  DeleteSnapshotsOptionType,\n  DirectoryCreateResponse,\n  DirectoryDeleteResponse,\n  DirectoryGetPropertiesResponse,\n  DirectoryItem,\n  DirectoryListFilesAndDirectoriesSegmentResponse,\n  DirectoryListHandlesResponse,\n  DirectorySetMetadataResponse,\n  DirectorySetPropertiesResponse,\n  DirectoryForceCloseHandlesHeaders,\n  FileAbortCopyResponse,\n  FileCreateResponse,\n  FileDeleteResponse,\n  FileDownloadOptionalParams,\n  FileDownloadResponseModel,\n  FileForceCloseHandlesHeaders,\n  FileGetPropertiesResponse,\n  FileGetRangeListHeaders,\n  FileGetRangeListDiffResponse,\n  FileItem,\n  FileListHandlesResponse,\n  FileSetHTTPHeadersResponse,\n  FileSetMetadataResponse,\n  FileStartCopyResponse,\n  FileUploadRangeFromURLResponse,\n  FileUploadRangeResponse,\n  HandleItem,\n  LeaseAccessConditions,\n  RangeModel,\n  ShareCreatePermissionResponse,\n  ShareCreateResponse,\n  ShareCreateSnapshotResponse,\n  ShareDeleteResponse,\n  ShareGetAccessPolicyHeaders,\n  ShareGetPermissionResponse,\n  ShareGetPropertiesResponseModel,\n  ShareGetStatisticsResponseModel,\n  ShareSetAccessPolicyResponse,\n  ShareSetMetadataResponse,\n  ShareSetQuotaResponse,\n  SignedIdentifierModel,\n  SourceModifiedAccessConditions,\n  ShareAccessTier,\n  ShareSetPropertiesResponse,\n  ShareRootSquash\n} from \"./generatedModels\";\nimport { Share, Directory, File } from \"./generated/src/operations\";\nimport { newPipeline, StoragePipelineOptions, Pipeline } from \"./Pipeline\";\nimport {\n  DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS,\n  DEFAULT_HIGH_LEVEL_CONCURRENCY,\n  FILE_MAX_SIZE_BYTES,\n  FILE_RANGE_MAX_SIZE_BYTES,\n  URLConstants\n} from \"./utils/constants\";\nimport {\n  appendToURLPath,\n  setURLParameter,\n  truncatedISO8061Date,\n  extractConnectionStringParts,\n  getShareNameAndPathFromUrl,\n  appendToURLQuery\n} from \"./utils/utils.common\";\nimport { Credential } from \"./credentials/Credential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { StorageClient, CommonOptions } from \"./StorageClient\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { FileSystemAttributes } from \"./FileSystemAttributes\";\nimport { FileDownloadResponse } from \"./FileDownloadResponse\";\nimport { Range, rangeToString } from \"./Range\";\nimport {\n  CloseHandlesInfo,\n  FileAndDirectoryCreateCommonOptions,\n  FileAndDirectorySetPropertiesCommonOptions,\n  fileAttributesToString,\n  fileCreationTimeToString,\n  FileHttpHeaders,\n  fileLastWriteTimeToString,\n  Metadata,\n  validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions,\n  validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions,\n  ShareProtocols,\n  toShareProtocolsString,\n  toShareProtocols\n} from \"./models\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"./utils/BufferScheduler\";\nimport { Readable } from \"stream\";\nimport {\n  fsStat,\n  fsCreateReadStream,\n  readStreamToLocalFile,\n  streamToBuffer\n} from \"./utils/utils.node\";\nimport { StorageClientContext } from \"./generated/src/storageClientContext\";\nimport { SERVICE_VERSION } from \"./utils/constants\";\nimport { generateUuid } from \"@azure/core-http\";\nimport { generateFileSASQueryParameters } from \"./FileSASSignatureValues\";\nimport { ShareSASPermissions } from \"./ShareSASPermissions\";\nimport { SASProtocol } from \"./SASQueryParameters\";\nimport { SasIPRange } from \"./SasIPRange\";\nimport { FileSASPermissions } from \"./FileSASPermissions\";\n\n/**\n * Options to configure the {@link ShareClient.create} operation.\n */\nexport interface ShareCreateOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A name-value pair to associate with a file storage object.\n   */\n  metadata?: { [propertyName: string]: string };\n\n  /**\n   * Specifies the maximum size of the share, in\n   * gigabytes.\n   */\n  quota?: number;\n\n  /**\n   * Specifies the access tier of the share. Possible values include: 'TransactionOptimized',\n   * 'Hot', 'Cool'\n   */\n  accessTier?: ShareAccessTier;\n\n  /**\n   * Supported in version 2020-02-10 and above. Specifies the enabled protocols on the share. If not specified, the default is SMB.\n   */\n  protocols?: ShareProtocols;\n  /**\n   * Root squash to set on the share.  Only valid for NFS shares. Possible values include:\n   * 'NoRootSquash', 'RootSquash', 'AllSquash'.\n   */\n  rootSquash?: ShareRootSquash;\n}\n\n/**\n * Options to configure the {@link ShareClient.delete} operation.\n */\nexport interface ShareDeleteMethodOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the option\n   * include to delete the base share and all of its snapshots. Possible values\n   * include: 'include'\n   */\n  deleteSnapshots?: DeleteSnapshotsOptionType;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.setMetadata} operation.\n */\nexport interface ShareSetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.setAccessPolicy} operation.\n */\nexport interface ShareSetAccessPolicyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.getAccessPolicy} operation.\n */\nexport interface ShareGetAccessPolicyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.exists} operation.\n */\nexport interface ShareExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.getProperties} operation.\n */\nexport interface ShareGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.setQuota} operation.\n */\nexport interface ShareSetQuotaOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.setProperties} operation.\n */\nexport interface ShareSetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Specifies the access tier of the share. Possible values include: 'TransactionOptimized',\n   * 'Hot', 'Cool'.\n   */\n  accessTier?: ShareAccessTier;\n\n  /**\n   * Specifies the maximum size of the share, in gigabytes.\n   */\n  quotaInGB?: number;\n\n  /**\n   * Root squash to set on the share.  Only valid for NFS shares. Possible values include:\n   * 'NoRootSquash', 'RootSquash', 'AllSquash'.\n   */\n  rootSquash?: ShareRootSquash;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareClient.getStatistics} operation.\n */\nexport interface ShareGetStatisticsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, the operation only succeeds if the resource's lease is active and matches this ID.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Signed Identifier\n */\nexport interface SignedIdentifier {\n  /**\n   * a unique id\n   */\n  id: string;\n  /**\n   * Access Policy\n   */\n  accessPolicy: {\n    /**\n     * the date-time the policy is active.\n     */\n    startsOn: Date;\n    /**\n     * the date-time the policy expires.\n     */\n    expiresOn: Date;\n    /**\n     * the permissions for the acl policy\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl\n     */\n    permissions: string;\n  };\n}\n\nexport declare type ShareGetAccessPolicyResponse = {\n  signedIdentifiers: SignedIdentifier[];\n} & ShareGetAccessPolicyHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ShareGetAccessPolicyHeaders;\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: SignedIdentifierModel[];\n    };\n  };\n\n/**\n * Options to configure the {@link ShareClient.createSnapshot} operation.\n */\nexport interface ShareCreateSnapshotOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A name-value pair to associate with a file storage object.\n   */\n  metadata?: { [propertyName: string]: string };\n}\n\n/**\n * Options to configure the {@link ShareClient.createPermission} operation.\n */\nexport interface ShareCreatePermissionOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n/**\n * Options to configure the {@link ShareClient.getPermission} operation.\n */\nexport interface ShareGetPermissionOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Response data for the {@link ShareClient.getStatistics} Operation.\n */\nexport type ShareGetStatisticsResponse = ShareGetStatisticsResponseModel & {\n  /**\n   * @deprecated shareUsage is going to be deprecated. Please use ShareUsageBytes instead.\n   *\n   * The approximate size of the data stored on the share, rounded up to the nearest gigabyte. Note\n   * that this value may not include all recently created or recently resized files.\n   */\n  shareUsage: number;\n};\n\n/**\n * Contains response data for the {@link ShareClient.createIfNotExists} operation.\n */\nexport interface ShareCreateIfNotExistsResponse extends ShareCreateResponse {\n  /**\n   * Indicate whether the share is successfully created. Is false when the share is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link ShareClient.deleteIfExists} operation.\n */\nexport interface ShareDeleteIfExistsResponse extends ShareDeleteResponse {\n  /**\n   * Indicate whether the share is successfully deleted. Is false if the share does not exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link ShareClient.getProperties} operation.\n */\nexport type ShareGetPropertiesResponse = ShareGetPropertiesResponseModel & {\n  /**\n   * The protocols that have been enabled on the share.\n   */\n  protocols?: ShareProtocols;\n};\n\n/**\n * Common options of the {@link ShareGenerateSasUrlOptions} and {@link FileGenerateSasUrlOptions}.\n */\nexport interface CommonGenerateSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols, HTTPS only or HTTPSandHTTP\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n\n  /**\n   * Optional only when identifier is provided. The time after which the SAS will no longer work.\n   */\n  expiresOn?: Date;\n\n  /**\n   * Optional. IP ranges allowed in this SAS.\n   */\n  ipRange?: SasIPRange;\n\n  /**\n   * Optional. The name of the access policy on the share this SAS references if any.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy\n   */\n  identifier?: string;\n\n  /**\n   * Optional. The cache-control header for the SAS.\n   */\n  cacheControl?: string;\n\n  /**\n   * Optional. The content-disposition header for the SAS.\n   */\n  contentDisposition?: string;\n\n  /**\n   * Optional. The content-encoding header for the SAS.\n   */\n  contentEncoding?: string;\n\n  /**\n   * Optional. The content-language header for the SAS.\n   */\n  contentLanguage?: string;\n\n  /**\n   * Optional. The content-type header for the SAS.\n   */\n  contentType?: string;\n}\n\n/**\n * Options to configure {@link ShareClient.generateSasUrl} operation.\n */\nexport interface ShareGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: ShareSASPermissions;\n}\n\n/**\n * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.\n */\nexport class ShareClient extends StorageClient {\n  /**\n   * Share operation context provided by protocol layer.\n   */\n  private context: Share;\n\n  private _name: string;\n\n  /**\n   * The name of the share\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param name - Share name.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(connectionString: string, name: string, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of ShareClient.\n   *\n   * @param url - A URL string pointing to Azure Storage file share, such as\n   *                     \"https://myaccount.file.core.windows.net/share\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/share?sasString\".\n   * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.\n   *                                  If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of ShareClient.\n   *\n   * @param url - A URL string pointing to Azure Storage file share, such as\n   *                     \"https://myaccount.file.core.windows.net/share\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/share?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: Pipeline);\n  constructor(\n    urlOrConnectionString: string,\n    credentialOrPipelineOrShareName?: Credential | Pipeline | string,\n    options?: StoragePipelineOptions\n  ) {\n    let pipeline: Pipeline;\n    let url: string;\n    if (credentialOrPipelineOrShareName instanceof Pipeline) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrShareName;\n    } else if (credentialOrPipelineOrShareName instanceof Credential) {\n      // (url: string, credential?: Credential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      pipeline = newPipeline(credentialOrPipelineOrShareName, options);\n    } else if (\n      !credentialOrPipelineOrShareName &&\n      typeof credentialOrPipelineOrShareName !== \"string\"\n    ) {\n      // (url: string, credential?: Credential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (\n      credentialOrPipelineOrShareName &&\n      typeof credentialOrPipelineOrShareName === \"string\"\n    ) {\n      // (connectionString: string, name: string, options?: StoragePipelineOptions)\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      const name = credentialOrPipelineOrShareName;\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(\n            extractedCreds.accountName!,\n            extractedCreds.accountKey\n          );\n          url = appendToURLPath(extractedCreds.url, name);\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(extractedCreds.url, name) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\n          \"Connection string must be either an Account connection string or a SAS connection string\"\n        );\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for name parameter\");\n    }\n    super(url, pipeline);\n    this._name = getShareNameAndPathFromUrl(this.url).shareName;\n    this.context = new Share(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base share.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new ShareClient object identical to the source but with the specified snapshot timestamp\n   */\n  public withSnapshot(snapshot: string): ShareClient {\n    return new ShareClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.SHARE_SNAPSHOT,\n        snapshot.length === 0 ? undefined : snapshot\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a new share under the specified account. If the share with\n   * the same name already exists, the operation fails.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share\n   *\n   * @param options - Options to Share Create operation.\n   * @returns Response data for the Share Create operation.\n   */\n  public async create(options: ShareCreateOptions = {}): Promise<ShareCreateResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-create\", options);\n    try {\n      return await this.context.create({\n        ...options,\n        enabledProtocols: toShareProtocolsString(options.protocols),\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new share under the specified account. If the share with\n   * the same name already exists, it is not changed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share\n   *\n   * @param options -\n   */\n  public async createIfNotExists(\n    options: ShareCreateOptions = {}\n  ): Promise<ShareCreateIfNotExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-createIfNotExists\", options);\n    try {\n      const res = await this.create(updatedOptions);\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"ShareAlreadyExists\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when creating a share only if it doesn't already exist.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a {@link ShareDirectoryClient} object.\n   *\n   * @param directoryName - A directory name\n   * @returns The ShareDirectoryClient object for the given directory name.\n   */\n  public getDirectoryClient(directoryName: string): ShareDirectoryClient {\n    return new ShareDirectoryClient(\n      appendToURLPath(this.url, encodeURIComponent(directoryName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Gets the directory client for the root directory of this share.\n   * Note that the root directory always exists and cannot be deleted.\n   *\n   * @readonly A new ShareDirectoryClient object for the root directory.\n   */\n  public get rootDirectoryClient(): ShareDirectoryClient {\n    return this.getDirectoryClient(\"\");\n  }\n\n  /**\n   * Creates a new subdirectory under this share.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param directoryName -\n   * @param options - Options to Directory Create operation.\n   * @returns Directory creation response data and the corresponding directory client.\n   */\n  public async createDirectory(\n    directoryName: string,\n    options: DirectoryCreateOptions = {}\n  ): Promise<{\n    directoryClient: ShareDirectoryClient;\n    directoryCreateResponse: DirectoryCreateResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-createDirectory\", options);\n    try {\n      const directoryClient = this.getDirectoryClient(directoryName);\n      const directoryCreateResponse = await directoryClient.create(updatedOptions);\n      return {\n        directoryClient,\n        directoryCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty sub directory under this share.\n   * Note that the directory must be empty before it can be deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param directoryName -\n   * @param options - Options to Directory Delete operation.\n   * @returns Directory deletion response data.\n   */\n  public async deleteDirectory(\n    directoryName: string,\n    options: DirectoryDeleteOptions = {}\n  ): Promise<DirectoryDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-deleteDirectory\", options);\n    try {\n      const directoryClient = this.getDirectoryClient(directoryName);\n      return await directoryClient.delete(updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new file or replaces a file under the root directory of this share.\n   * Note it only initializes the file with no content.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file\n   *\n   * @param fileName -\n   * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.\n   * @param options - Options to File Create operation.\n   * @returns File creation response data and the corresponding file client.\n   */\n  public async createFile(\n    fileName: string,\n    size: number,\n    options: FileCreateOptions = {}\n  ): Promise<{ fileClient: ShareFileClient; fileCreateResponse: FileCreateResponse }> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-createFile\", options);\n    try {\n      const directoryClient = this.rootDirectoryClient;\n      const fileClient = directoryClient.getFileClient(fileName);\n      const fileCreateResponse = await fileClient.create(size, updatedOptions);\n      return {\n        fileClient,\n        fileCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes a file under the root directory of this share from the storage account.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400\n   * (`InvalidQueryParameterValue`)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param directoryName -\n   * @param fileName -\n   * @param options - Options to File Delete operation.\n   * @returns Promise<FileDeleteResponse> File Delete response data.\n   */\n  public async deleteFile(\n    fileName: string,\n    options: FileDeleteOptions = {}\n  ): Promise<FileDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-deleteFile\", options);\n    try {\n      const directoryClient = this.rootDirectoryClient;\n      const fileClient = directoryClient.getFileClient(fileName);\n      return await fileClient.delete(updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns true if the Azrue share resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing share might be deleted by other clients or\n   * applications. Vice versa new shares might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n  public async exists(options: ShareExistsOptions = {}): Promise<boolean> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-exists\", options);\n    try {\n      await this.getProperties(updatedOptions);\n      return true;\n    } catch (e) {\n      if (e.statusCode === 404) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when checking share existence\"\n        });\n        return false;\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all user-defined metadata and system properties for the specified\n   * share.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @returns Response data for the Share Get Properties operation.\n   */\n  public async getProperties(\n    options: ShareGetPropertiesOptions = {}\n  ): Promise<ShareGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-getProperties\", options);\n    try {\n      const res = await this.context.getProperties({\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      // parse protocols\n      const protocols = toShareProtocols(res.enabledProtocols);\n      (res as any).protocols = protocols;\n      return res;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified share for deletion. The share and any directories or files\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share\n   *\n   * @param options - Options to Share Delete operation.\n   * @returns Response data for the Share Delete operation.\n   */\n  public async delete(options: ShareDeleteMethodOptions = {}): Promise<ShareDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-delete\", options);\n    try {\n      return await this.context.delete({\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified share for deletion if it exists. The share and any directories or files\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share\n   *\n   * @param options -\n   */\n  public async deleteIfExists(\n    options: ShareDeleteMethodOptions = {}\n  ): Promise<ShareDeleteIfExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-deleteIfExists\", options);\n    try {\n      const res = await this.delete(updatedOptions);\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"ShareNotFound\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when deleting a share only if it exists.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets one or more user-defined name-value pairs for the specified share.\n   *\n   * If no option provided, or no metadata defined in the option parameter, the share\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata\n   *\n   * @param metadata - If no metadata provided, all existing directory metadata will be removed.\n   * @param option - Options to Share Set Metadata operation.\n   * @returns Response data for the Share Set Metadata operation.\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: ShareSetMetadataOptions = {}\n  ): Promise<ShareSetMetadataResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-setMetadata\", options);\n    try {\n      return await this.context.setMetadata({\n        ...options,\n        metadata,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets the permissions for the specified share. The permissions indicate\n   * whether share data may be accessed publicly.\n   *\n   * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.\n   * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl\n   *\n   * @param option - Options to Share Get Access Policy operation.\n   * @returns Response data for the Share Get Access Policy operation.\n   */\n  public async getAccessPolicy(\n    options: ShareGetAccessPolicyOptions = {}\n  ): Promise<ShareGetAccessPolicyResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-getAccessPolicy\", options);\n    try {\n      const response = await this.context.getAccessPolicy({\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      const res: ShareGetAccessPolicyResponse = {\n        _response: response._response,\n        date: response.date,\n        etag: response.etag,\n        lastModified: response.lastModified,\n        requestId: response.requestId,\n        signedIdentifiers: [],\n        version: response.version\n      };\n\n      for (const identifier of response) {\n        let accessPolicy: any = undefined;\n        if (identifier.accessPolicy) {\n          accessPolicy = {\n            permissions: identifier.accessPolicy.permissions\n          };\n\n          if (identifier.accessPolicy.expiresOn) {\n            accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);\n          }\n\n          if (identifier.accessPolicy.startsOn) {\n            accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);\n          }\n        }\n\n        res.signedIdentifiers.push({\n          accessPolicy,\n          id: identifier.id\n        });\n      }\n\n      return res;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets the permissions for the specified share. The permissions indicate\n   * whether directories or files in a share may be accessed publicly.\n   *\n   * When you set permissions for a share, the existing permissions are replaced.\n   * If no shareAcl provided, the existing share ACL will be\n   * removed.\n   *\n   * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.\n   * During this interval, a shared access signature that is associated with the stored access policy will\n   * fail with status code 403 (Forbidden), until the access policy becomes active.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl\n   *\n   * @param shareAcl - Array of signed identifiers, each having a unique Id and details of access policy.\n   * @param option - Options to Share Set Access Policy operation.\n   * @returns Response data for the Share Set Access Policy operation.\n   */\n  public async setAccessPolicy(\n    shareAcl?: SignedIdentifier[],\n    options: ShareSetAccessPolicyOptions = {}\n  ): Promise<ShareSetAccessPolicyResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-setAccessPolicy\", options);\n    try {\n      const acl: SignedIdentifierModel[] = [];\n      for (const identifier of shareAcl || []) {\n        acl.push({\n          accessPolicy: {\n            expiresOn: identifier.accessPolicy?.expiresOn\n              ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)\n              : undefined,\n            permissions: identifier.accessPolicy?.permissions,\n            startsOn: identifier.accessPolicy?.startsOn\n              ? truncatedISO8061Date(identifier.accessPolicy.startsOn)\n              : undefined\n          },\n          id: identifier.id\n        });\n      }\n\n      return await this.context.setAccessPolicy({\n        ...options,\n        shareAcl: acl,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a read-only snapshot of a share.\n   *\n   * @param options - Options to Share Create Snapshot operation.\n   * @returns Response data for the Share Create Snapshot operation.\n   */\n  public async createSnapshot(\n    options: ShareCreateSnapshotOptions = {}\n  ): Promise<ShareCreateSnapshotResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-createSnapshot\", options);\n    try {\n      return await this.context.createSnapshot({\n        abortSignal: options.abortSignal,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets quota for the specified share.\n   *\n   * @deprecated Use {@link ShareClient.setProperties} instead.\n   *\n   * @param quotaInGB - Specifies the maximum size of the share in gigabytes\n   * @param option - Options to Share Set Quota operation.\n   * @returns Response data for the Share Get Quota operation.\n   */\n  public async setQuota(\n    quotaInGB: number,\n    options: ShareSetQuotaOptions = {}\n  ): Promise<ShareSetQuotaResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-setQuota\", options);\n    try {\n      return await this.context.setProperties({\n        ...options,\n        quota: quotaInGB,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties of the share.\n   *\n   * @param option - Options to Share Set Properties operation.\n   * @returns Response data for the Share Set Properties operation.\n   */\n  public async setProperties(\n    options: ShareSetPropertiesOptions = {}\n  ): Promise<ShareSetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-setProperties\", options);\n    try {\n      return await this.context.setProperties({\n        ...options,\n        quota: options.quotaInGB,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves statistics related to the share.\n   *\n   * @param option - Options to Share Get Statistics operation.\n   * @returns Response data for the Share Get Statistics operation.\n   */\n  public async getStatistics(\n    options: ShareGetStatisticsOptions = {}\n  ): Promise<ShareGetStatisticsResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-getStatistics\", options);\n    try {\n      const response = await this.context.getStatistics({\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      const GBBytes = 1024 * 1024 * 1024;\n      return { ...response, shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a file permission (a security descriptor) at the share level.\n   * The created security descriptor can be used for the files/directories in the share.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission\n   *\n   * @param options - Options to Share Create Permission operation.\n   * @param filePermission - File permission described in the SDDL\n   */\n  public async createPermission(\n    filePermission: string,\n    options: ShareCreatePermissionOptions = {}\n  ): Promise<ShareCreatePermissionResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-createPermission\", options);\n    try {\n      return await this.context.createPermission(\n        {\n          permission: filePermission\n        },\n        {\n          abortSignal: options.abortSignal,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key\n   * which indicates a security descriptor.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission\n   *\n   * @param options - Options to Share Create Permission operation.\n   * @param filePermissionKey - File permission key which indicates the security descriptor of the permission.\n   */\n  public async getPermission(\n    filePermissionKey: string,\n    options: ShareGetPermissionOptions = {}\n  ): Promise<ShareGetPermissionResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareClient-getPermission\", options);\n    try {\n      return await this.context.getPermission(filePermissionKey, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Only available for ShareClient constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: ShareGenerateSasUrlOptions): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the SAS when the client is initialized with a shared key credential\"\n      );\n    }\n\n    const sas = generateFileSASQueryParameters(\n      {\n        shareName: this.name,\n        ...options\n      },\n      this.credential\n    ).toString();\n\n    return appendToURLQuery(this.url, sas);\n  }\n}\n\n/**\n * Options to configure {@link ShareDirectoryClient.create} operation.\n */\nexport interface DirectoryCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the file storage object.\n   */\n  metadata?: Metadata;\n}\n\nexport interface DirectoryProperties\n  extends FileAndDirectorySetPropertiesCommonOptions,\n    CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure Directory - List Files and Directories Segment operations.\n *\n * See:\n * - {@link ShareDirectoryClient.iterateFilesAndDirectoriesSegments}\n * - {@link ShareDirectoryClient.listFilesAndDirectoriesItems}\n * - {@link ShareDirectoryClient.listFilesAndDirectoriesSegment}\n */\ninterface DirectoryListFilesAndDirectoriesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only entries whose\n   * name begins with the specified prefix.\n   */\n  prefix?: string;\n\n  /**\n   * Specifies the maximum number of entries to\n   * return. If the request does not specify maxResults, or specifies a value\n   * greater than 5,000, the server will return up to 5,000 items.\n   */\n  maxResults?: number;\n}\n\n/**\n * Options to configure {@link ShareDirectoryClient.listFilesAndDirectories} operation.\n */\nexport interface DirectoryListFilesAndDirectoriesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only entries whose\n   * name begins with the specified prefix.\n   */\n  prefix?: string;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.delete} operation.\n */\nexport interface DirectoryDeleteOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.exists} operation.\n */\nexport interface DirectoryExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.getProperties} operation.\n */\nexport interface DirectoryGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.setMetadata} operation.\n */\nexport interface DirectorySetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure Directory - List Handles Segment operations.\n *\n * See:\n * - {@link ShareDirectoryClient.listHandlesSegment}\n * - {@link ShareDirectoryClient.iterateHandleSegments}\n * - {@link ShareDirectoryClient.listHandleItems}\n *\n */\nexport interface DirectoryListHandlesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of entries to return. If the request does not specify maxResults,\n   * or specifies a value greater than 5,000, the server will return up to 5,000 items.\n   */\n  maxResults?: number;\n  /**\n   * Specifies operation should apply to the directory specified in the URI, its files, its\n   * subdirectories and their files.\n   */\n  recursive?: boolean;\n}\n\n/**\n * Options to configure the {@link ShareDirectoryClient.listHandles} operation.\n */\nexport interface DirectoryListHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies whether operation should apply to the directory specified in the URI, its files, its\n   * subdirectories and their files.\n   */\n  recursive?: boolean;\n}\n\n/**\n * Options to configure Directory - Force Close Handles Segment operations.\n *\n * See:\n * - {@link ShareDirectoryClient.forceCloseHandlesSegment}\n * - {@link ShareDirectoryClient.forceCloseAllHandles}\n */\nexport interface DirectoryForceCloseHandlesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies operation should apply to the directory specified in the URI, its files, its\n   * subdirectories and their files.\n   */\n  recursive?: boolean;\n}\n\n/**\n * Additional response header values for close handles request.\n */\nexport interface DirectoryCloseHandlesHeaders {\n  /**\n   * This header uniquely identifies the request that was made and can be used for troubleshooting\n   * the request.\n   */\n  requestId?: string;\n  /**\n   * Indicates the version of the File service used to execute the request.\n   */\n  version?: string;\n  /**\n   * A UTC date/time value generated by the service that indicates the time at which the response\n   * was initiated.\n   */\n  date?: Date;\n  /**\n   * A string describing next handle to be closed. It is returned when more handles need to be\n   * closed to complete the request.\n   */\n  marker?: string;\n}\n\n/**\n * Response type for {@link ShareDirectoryClient.forceCloseHandle}.\n */\nexport type DirectoryForceCloseHandlesResponse = CloseHandlesInfo &\n  DirectoryCloseHandlesHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: DirectoryForceCloseHandlesHeaders;\n    };\n  };\n\n/**\n * Options to configure {@link ShareDirectoryClient.forceCloseHandle}.\n */\nexport interface DirectoryForceCloseHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Contains response data for the {@link DirectoryClient.createIfNotExists} operation.\n */\nexport interface DirectoryCreateIfNotExistsResponse extends DirectoryCreateResponse {\n  /**\n   * Indicate whether the directory is successfully created. Is false when the directory is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link DirectoryClient.deleteIfExists} operation.\n */\nexport interface DirectoryDeleteIfExistsResponse extends DirectoryDeleteResponse {\n  /**\n   * Indicate whether the directory is successfully deleted. Is false if the directory does not exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n/**\n * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.\n */\nexport class ShareDirectoryClient extends StorageClient {\n  /**\n   * context provided by protocol layer.\n   */\n  private context: Directory;\n\n  private _shareName: string;\n  private _path: string;\n  private _name: string;\n\n  /**\n   * The share name corresponding to this directory client\n   */\n  public get shareName(): string {\n    return this._shareName;\n  }\n\n  /**\n   * The full path of the directory\n   */\n  public get path(): string {\n    return this._path;\n  }\n\n  /**\n   * The name of the directory\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Creates an instance of DirectoryClient.\n   *\n   * @param url - A URL string pointing to Azure Storage file directory, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a directory name includes %, directory name must be encoded in the URL.\n   *                     Such as a directory named \"mydir%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydir%25\".\n   * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.\n   *                                  If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of DirectoryClient.\n   *\n   * @param url - A URL string pointing to Azure Storage file directory, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a directory name includes %, directory name must be encoded in the URL.\n   *                     Such as a directory named \"mydir%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydir%25\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: Pipeline);\n  constructor(\n    url: string,\n    credentialOrPipeline?: Credential | Pipeline,\n    options: StoragePipelineOptions = {}\n  ) {\n    let pipeline: Pipeline;\n    if (credentialOrPipeline instanceof Pipeline) {\n      pipeline = credentialOrPipeline;\n    } else if (credentialOrPipeline instanceof Credential) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential.\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n\n    super(url, pipeline);\n    ({\n      baseName: this._name,\n      shareName: this._shareName,\n      path: this._path\n    } = getShareNameAndPathFromUrl(this.url));\n    this.context = new Directory(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new directory under the specified share or parent directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param options - Options to Directory Create operation.\n   * @returns Response data for the Directory  operation.\n   */\n  public async create(options: DirectoryCreateOptions = {}): Promise<DirectoryCreateResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-create\", options);\n    try {\n      if (!options.fileAttributes) {\n        options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);\n        // By default set it as a directory.\n        const attributes: FileSystemAttributes = new FileSystemAttributes();\n        attributes.directory = true;\n        options.fileAttributes = attributes;\n      }\n\n      return await this.context.create(\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          metadata: options.metadata,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new directory under the specified share or parent directory if it does not already exists.\n   * If the directory already exists, it is not modified.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param options -\n   */\n  public async createIfNotExists(\n    options: DirectoryCreateOptions = {}\n  ): Promise<DirectoryCreateIfNotExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-createIfNotExists\", options);\n    try {\n      const res = await this.create(updatedOptions);\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"ResourceAlreadyExists\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when creating a directory only if it does not already exist.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties on the directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties\n   *\n   * @param DirectoryProperties - Directory properties. If no values are provided,\n   *                                            existing values will be preserved.\n   */\n  public async setProperties(\n    properties: DirectoryProperties = {}\n  ): Promise<DirectorySetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-setProperties\", properties);\n    try {\n      properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);\n\n      return await this.context.setProperties(\n        fileAttributesToString(properties.fileAttributes!),\n        fileCreationTimeToString(properties.creationTime!),\n        fileLastWriteTimeToString(properties.lastWriteTime!),\n        {\n          abortSignal: properties.abortSignal,\n          filePermission: properties.filePermission,\n          filePermissionKey: properties.filePermissionKey,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a ShareDirectoryClient object for a sub directory.\n   *\n   * @param subDirectoryName - A subdirectory name\n   * @returns The ShareDirectoryClient object for the given subdirectory name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const directoryClient = shareClient.getDirectoryClient(\"<directory name>\");\n   * await directoryClient.create();\n   * console.log(\"Created directory successfully\");\n   * ```\n   */\n  public getDirectoryClient(subDirectoryName: string): ShareDirectoryClient {\n    return new ShareDirectoryClient(\n      appendToURLPath(this.url, encodeURIComponent(subDirectoryName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a new subdirectory under this directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory\n   *\n   * @param directoryName -\n   * @param options - Options to Directory Create operation.\n   * @returns Directory create response data and the corresponding DirectoryClient instance.\n   */\n  public async createSubdirectory(\n    directoryName: string,\n    options: DirectoryCreateOptions = {}\n  ): Promise<{\n    directoryClient: ShareDirectoryClient;\n    directoryCreateResponse: DirectoryCreateResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-createSubdirectory\", options);\n    try {\n      const directoryClient = this.getDirectoryClient(directoryName);\n      const directoryCreateResponse = await directoryClient.create(updatedOptions);\n      return {\n        directoryClient,\n        directoryCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty sub directory under this directory.\n   * Note that the directory must be empty before it can be deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param directoryName -\n   * @param options - Options to Directory Delete operation.\n   * @returns Directory deletion response data.\n   */\n  public async deleteSubdirectory(\n    directoryName: string,\n    options: DirectoryDeleteOptions = {}\n  ): Promise<DirectoryDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-deleteSubdirectory\", options);\n    try {\n      const directoryClient = this.getDirectoryClient(directoryName);\n      return await directoryClient.delete(updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file\n   *\n   * @param fileName -\n   * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.\n   * @param options - Options to File Create operation.\n   * @returns File creation response data and the corresponding file client.\n   */\n  public async createFile(\n    fileName: string,\n    size: number,\n    options: FileCreateOptions = {}\n  ): Promise<{ fileClient: ShareFileClient; fileCreateResponse: FileCreateResponse }> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-createFile\", options);\n    try {\n      const fileClient = this.getFileClient(fileName);\n      const fileCreateResponse = await fileClient.create(size, updatedOptions);\n      return {\n        fileClient,\n        fileCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified file under this directory from the storage account.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code SharingViolation\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param fileName - Name of the file to delete\n   * @param options - Options to File Delete operation.\n   * @returns File deletion response data.\n   */\n  public async deleteFile(\n    fileName: string,\n    options: FileDeleteOptions = {}\n  ): Promise<FileDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-deleteFile\", options);\n    try {\n      const fileClient = this.getFileClient(fileName);\n      return await fileClient.delete(updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a {@link ShareFileClient} object.\n   *\n   * @param fileName - A file name.\n   * @returns A new ShareFileClient object for the given file name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\"\n   *\n   * const fileClient = directoryClient.getFileClient(\"<file name>\");\n   *\n   * await fileClient.create(content.length);\n   * console.log(\"Created file successfully!\");\n   *\n   * await fileClient.uploadRange(content, 0, content.length);\n   * console.log(\"Updated file successfully!\")\n   * ```\n   */\n  public getFileClient(fileName: string): ShareFileClient {\n    return new ShareFileClient(\n      appendToURLPath(this.url, encodeURIComponent(fileName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Returns true if the specified directory exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing directory might be deleted by other clients or\n   * applications. Vice versa new directories might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n  public async exists(options: DirectoryExistsOptions = {}): Promise<boolean> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-exists\", options);\n    try {\n      await this.getProperties({\n        abortSignal: options.abortSignal,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      });\n      return true;\n    } catch (e) {\n      if (e.statusCode === 404) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when checking directory existence\"\n        });\n        return false;\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all system properties for the specified directory, and can also be used to check the\n   * existence of a directory. The data returned does not include the files in the directory or any\n   * subdirectories.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties\n   *\n   * @param options - Options to Directory Get Properties operation.\n   * @returns Response data for the Directory Get Properties operation.\n   */\n  public async getProperties(\n    options: DirectoryGetPropertiesOptions = {}\n  ): Promise<DirectoryGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-getProperties\", options);\n    try {\n      return await this.context.getProperties({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty directory. Note that the directory must be empty before it can be\n   * deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param options - Options to Directory Delete operation.\n   * @returns Response data for the Directory Delete operation.\n   */\n  public async delete(options: DirectoryDeleteOptions = {}): Promise<DirectoryDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-delete\", options);\n    try {\n      return await this.context.delete({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be\n   * deleted.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory\n   *\n   * @param options -\n   */\n  public async deleteIfExists(\n    options: DirectoryDeleteOptions = {}\n  ): Promise<DirectoryDeleteIfExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-deleteIfExists\", options);\n    try {\n      const res = await this.delete(updatedOptions);\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (\n        e.details?.errorCode === \"ResourceNotFound\" ||\n        e.details?.errorCode === \"ParentNotFound\"\n      ) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when deleting a directory only if it exists.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Updates user defined metadata for the specified directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata\n   *\n   * @param metadata - If no metadata provided, all existing directory metadata will be removed\n   * @param options - Options to Directory Set Metadata operation.\n   * @returns Response data for the Directory Set Metadata operation.\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: DirectorySetMetadataOptions = {}\n  ): Promise<DirectorySetMetadataResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-setMetadata\", options);\n    try {\n      return await this.context.setMetadata({\n        abortSignal: options.abortSignal,\n        metadata,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects\n   *\n   * @param marker - A string value that identifies the portion of\n   *                          the list of files and directories to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all files and directories remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list files and directories operation.\n   */\n  private async *iterateFilesAndDirectoriesSegments(\n    marker?: string,\n    options: DirectoryListFilesAndDirectoriesSegmentOptions = {}\n  ): AsyncIterableIterator<DirectoryListFilesAndDirectoriesSegmentResponse> {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    let listFilesAndDirectoriesResponse;\n    do {\n      listFilesAndDirectoriesResponse = await this.listFilesAndDirectoriesSegment(marker, options);\n      marker = listFilesAndDirectoriesResponse.continuationToken;\n      yield await listFilesAndDirectoriesResponse;\n    } while (marker);\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for file and directory items\n   *\n   * @param options - Options to list files and directories operation.\n   */\n  private async *listFilesAndDirectoriesItems(\n    options: DirectoryListFilesAndDirectoriesSegmentOptions = {}\n  ): AsyncIterableIterator<\n    ({ kind: \"file\" } & FileItem) | ({ kind: \"directory\" } & DirectoryItem)\n  > {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    let marker: string | undefined;\n    for await (const listFilesAndDirectoriesResponse of this.iterateFilesAndDirectoriesSegments(\n      marker,\n      options\n    )) {\n      for (const file of listFilesAndDirectoriesResponse.segment.fileItems) {\n        yield { kind: \"file\", ...file };\n      }\n      for (const directory of listFilesAndDirectoriesResponse.segment.directoryItems) {\n        yield { kind: \"directory\", ...directory };\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the files and directories\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the files and directories in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const entity of directoryClient.listFilesAndDirectories()) {\n   *   if (entity.kind === \"directory\") {\n   *     console.log(`${i++} - directory\\t: ${entity.name}`);\n   *   } else {\n   *     console.log(`${i++} - file\\t: ${entity.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = directoryClient.listFilesAndDirectories();\n   * let entity = await iter.next();\n   * while (!entity.done) {\n   *   if (entity.value.kind === \"directory\") {\n   *     console.log(`${i++} - directory\\t: ${entity.value.name}`);\n   *   } else {\n   *     console.log(`${i++} - file\\t: ${entity.value.name}`);\n   *   }\n   *   entity = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of directoryClient\n   *   .listFilesAndDirectories()\n   *   .byPage({ maxPageSize: 20 })) {\n   *   for (const fileItem of response.segment.fileItems) {\n   *     console.log(`${i++} - file\\t: ${fileItem.name}`);\n   *   }\n   *   for (const dirItem of response.segment.directoryItems) {\n   *     console.log(`${i++} - directory\\t: ${dirItem.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 3 file and directory names\n   * for (const fileItem of response.segment.fileItems) {\n   *   console.log(`${i++} - file\\t: ${fileItem.name}`);\n   * }\n   *\n   * for (const dirItem of response.segment.directoryItems) {\n   *   console.log(`${i++} - directory\\t: ${dirItem.name}`);\n   * }\n   *\n   * // Gets next marker\n   * let dirMarker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   * iterator = directoryClient\n   *   .listFilesAndDirectories()\n   *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 file and directory names\n   * for (const fileItem of response.segment.fileItems) {\n   *   console.log(`${i++} - file\\t: ${fileItem.name}`);\n   * }\n   *\n   * for (const dirItem of response.segment.directoryItems) {\n   *   console.log(`${i++} - directory\\t: ${dirItem.name}`);\n   * }\n   * ```\n   *\n   * @param options - Options to list files and directories operation.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listFilesAndDirectories(\n    options: DirectoryListFilesAndDirectoriesOptions = {}\n  ): PagedAsyncIterableIterator<\n    ({ kind: \"file\" } & FileItem) | ({ kind: \"directory\" } & DirectoryItem),\n    DirectoryListFilesAndDirectoriesSegmentResponse\n  > {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    // AsyncIterableIterator to iterate over files and directories\n    const iter = this.listFilesAndDirectoriesItems(options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.iterateFilesAndDirectoriesSegments(settings.continuationToken, {\n          maxResults: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Returns a list of files or directories under the specified share or directory. It lists the\n   * contents only for a single level of the directory hierarchy.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files\n   *\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Directory List Files and Directories Segment operation.\n   * @returns Response data for the Directory List Files and Directories operation.\n   */\n  private async listFilesAndDirectoriesSegment(\n    marker?: string,\n    options: DirectoryListFilesAndDirectoriesSegmentOptions = {}\n  ): Promise<DirectoryListFilesAndDirectoriesSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"ShareDirectoryClient-listFilesAndDirectoriesSegment\",\n      options\n    );\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    try {\n      return await this.context.listFilesAndDirectoriesSegment({\n        marker,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}\n   *\n   * @param marker - A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param options - Options to list handles operation.\n   */\n  private async *iterateHandleSegments(\n    marker?: string,\n    options: DirectoryListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<DirectoryListHandlesResponse> {\n    let listHandlesResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listHandlesResponse = await this.listHandlesSegment(marker, options);\n        marker = listHandlesResponse.continuationToken;\n        yield await listHandlesResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for handles\n   *\n   * @param options - Options to list handles operation.\n   */\n  private async *listHandleItems(\n    options: DirectoryListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<HandleItem> {\n    let marker: string | undefined;\n    for await (const listHandlesResponse of this.iterateHandleSegments(marker, options)) {\n      if (listHandlesResponse.handleList) {\n        for (const handle of listHandlesResponse.handleList) {\n          yield handle;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the handles.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the handles in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = dirClient.listHandles();\n   * for await (const handle of iter) {\n   *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = dirClient.listHandles();\n   * let handleItem = await iter.next();\n   * while (!handleItem.done) {\n   *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);\n   *   handleItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {\n   *   if (response.handleList) {\n   *     for (const handle of response.handleList) {\n   *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });\n   * let response = await iterator.next();\n   *\n   * // Prints 2 handles\n   * if (response.value.handleList) {\n   *   for (const handle of response.value.handleList) {\n   *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.value.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   * console.log(`    continuation`);\n   * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = await iterator.next();\n   *\n   * // Prints 2 more handles assuming you have more than four directory/files opened\n   * if (!response.done && response.value.handleList) {\n   *   for (const handle of response.value.handleList) {\n   *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list handles operation.\n   *\n   * An asyncIterableIterator that supports paging.\n   */\n  public listHandles(\n    options: DirectoryListHandlesOptions = {}\n  ): PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse> {\n    // an AsyncIterableIterator to iterate over handles\n    const iter = this.listHandleItems(options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.iterateHandleSegments(settings.continuationToken, {\n          maxResults: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Lists handles for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles\n   *\n   * @param marker - Optional. A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param options -\n   */\n  private async listHandlesSegment(\n    marker?: string,\n    options: DirectoryListHandlesSegmentOptions = {}\n  ): Promise<DirectoryListHandlesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-listHandlesSegment\", options);\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const response = await this.context.listHandles({\n        marker,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      // TODO: Protocol layer issue that when handle list is in returned XML\n      // response.handleList is an empty string\n      if ((response.handleList as any) === \"\") {\n        response.handleList = undefined;\n      }\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close all handles for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param marker - Optional. A string value that identifies the position of handles that will\n   *                          be closed with the next force close handles operation.\n   *                          The operation returns a marker value within the response\n   *                          body if there are more handles to close. The marker value\n   *                          may then be used in a subsequent call to close the next set of handles.\n   * @param options -\n   */\n  private async forceCloseHandlesSegment(\n    marker?: string,\n    options: DirectoryForceCloseHandlesSegmentOptions = {}\n  ): Promise<DirectoryForceCloseHandlesResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"ShareDirectoryClient-forceCloseHandlesSegment\",\n      options\n    );\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const rawResponse = await this.context.forceCloseHandles(\"*\", {\n        marker,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n      const response = rawResponse as DirectoryForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close all handles for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param options -\n   */\n  public async forceCloseAllHandles(\n    options: DirectoryForceCloseHandlesSegmentOptions = {}\n  ): Promise<CloseHandlesInfo> {\n    const { span, updatedOptions } = createSpan(\n      \"ShareDirectoryClient-forceCloseAllHandles\",\n      options\n    );\n    try {\n      let handlesClosed = 0;\n      let numberOfHandlesFailedToClose = 0;\n      let marker: string | undefined = \"\";\n\n      do {\n        const response: DirectoryForceCloseHandlesResponse = await this.forceCloseHandlesSegment(\n          marker,\n          updatedOptions\n        );\n        marker = response.marker;\n        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);\n        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);\n      } while (marker);\n\n      return { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close a specific handle for a directory.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param aborter - Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param handleId - Specific handle ID, cannot be asterisk \"*\".\n   *                          Use forceCloseHandlesSegment() to close all handles.\n   * @param options -\n   */\n  public async forceCloseHandle(\n    handleId: string,\n    options: DirectoryForceCloseHandlesOptions = {}\n  ): Promise<DirectoryForceCloseHandlesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareDirectoryClient-forceCloseHandle\", options);\n    try {\n      if (handleId === \"*\") {\n        throw new RangeError(\n          `Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`\n        );\n      }\n\n      const rawResponse = await this.context.forceCloseHandles(handleId, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n      const response = rawResponse as DirectoryForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Options to configure the {@link ShareFileClient.create} operation.\n */\nexport interface FileCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * File HTTP headers like Content-Type.\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n\n  /**\n   * A collection of key-value string pair to associate with the file storage object.\n   */\n  metadata?: Metadata;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\nexport interface FileProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * File HTTP headers like Content-Type.\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\nexport interface SetPropertiesResponse extends FileSetHTTPHeadersResponse {}\n\n/**\n * Options to configure the {@link ShareFileClient.delete} operation.\n */\nexport interface FileDeleteOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure File - Download operations.\n *\n * See:\n * - {@link ShareFileClient.download}\n * - {@link ShareFileClient.downloadToFile}\n */\nexport interface FileDownloadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. ONLY AVAILABLE IN NODE.JS.\n   *\n   * How many retries will perform when original body download stream unexpected ends.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors.\n   *\n   * With this option, every additional retry means an additional ShareFileClient.download() request will be made\n   * from the broken point, until the requested range has been successfully downloaded or maxRetryRequests is reached.\n   *\n   * Default value is 5, please set a larger value when loading large files in poor network.\n   */\n  maxRetryRequests?: number;\n\n  /**\n   * When this header is set to true and\n   * specified together with the Range header, the service returns the MD5 hash\n   * for the range, as long as the range is less than or equal to 4 MB in size.\n   */\n  rangeGetContentMD5?: boolean;\n\n  /**\n   * Download progress updating event handler.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.uploadRange} operation.\n */\nexport interface FileUploadRangeOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * An MD5 hash of the content. This hash is\n   * used to verify the integrity of the data during transport. When the\n   * Content-MD5 header is specified, the File service compares the hash of the\n   * content that has arrived with the header value that was sent. If the two\n   * hashes do not match, the operation will fail with error code 400 (Bad\n   * Request).\n   */\n  contentMD5?: Uint8Array;\n\n  /**\n   * Progress updating event handler.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.uploadRangeFromURL} operation.\n */\nexport interface FileUploadRangeFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * The timeout parameter is expressed in seconds. For more information, see <a\n   * href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN\">Setting\n   * Timeouts for File Service Operations.</a>\n   */\n  timeoutInSeconds?: number;\n  /**\n   * Specify the crc64 calculated for the range of bytes that must be read from the copy source.\n   */\n  sourceContentCrc64?: Uint8Array;\n  /**\n   * Additional parameters for the operation\n   */\n  sourceConditions?: SourceModifiedAccessConditions;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * The option is defined as parity to REST definition.\n * While it's not ready to be used now, considering Crc64 of source content is\n * not accessible.\n */\n// export interface IFileUploadRangeFromURLOptions extends CommonOptions {\n//   /**\n//    * Crc64 of the source content.\n//    *\n//    * @type {Uint8Array}\n//    * @memberof IFileUploadRangeFromURLOptions\n//    */\n//   sourceContentCrc64?: Uint8Array;\n\n//   /**\n//    * Source modified access condition.\n//    *\n//    * @type {SourceModifiedAccessConditions}\n//    * @memberof IFileUploadRangeFromURLOptions\n//    */\n//   sourceModifiedAccessConditions?: SourceModifiedAccessConditions;\n// }\n\n/**\n * Options to configure the {@link ShareFileClient.getRangeList} operation.\n */\nexport interface FileGetRangeListOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. Specifies the range of bytes over which to list ranges, inclusively.\n   */\n  range?: Range;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.exists} operation.\n */\nexport interface FileExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.getProperties} operation.\n */\nexport interface FileGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Contains response data for the {@link ShareFileClient.getRangeList} operation.\n */\nexport type FileGetRangeListResponse = FileGetRangeListHeaders & {\n  /**\n   * Range list for an Azure file.\n   */\n  rangeList: RangeModel[];\n\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: FileGetRangeListHeaders;\n    /**\n     * The response body as text (string format)\n     */\n    bodyAsText: string;\n    /**\n     * The response body as parsed JSON or XML\n     */\n    parsedBody: RangeModel[];\n  };\n};\n\n/**\n * Options to configure the {@link ShareFileClient.startCopyFromURL} operation.\n */\nexport interface FileStartCopyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the file storage object.\n   */\n  metadata?: Metadata;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n  /**\n   * If specified the permission (security descriptor) shall be set for the directory/file. This\n   * header can be used if Permission size is lesser than or equal to 8KB, else x-ms-file-permission-key header shall be\n   * used. Default value: Inherit. If SDDL is specified as input, it must have owner, group and\n   * dacl. Note: Only one of the x-ms-file-permission or x-ms-file-permission-key should be\n   * specified.\n   */\n  filePermission?: string;\n  /**\n   * Key of the permission to be set for the directory/file. Note: Only one of the\n   * x-ms-file-permission or x-ms-file-permission-key should be specified.\n   */\n  filePermissionKey?: string;\n  /**\n   * SMB info.\n   */\n  copyFileSmbInfo?: CopyFileSmbInfo;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.setMetadata} operation.\n */\nexport interface FileSetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.setHttpHeaders} operation.\n */\nexport interface FileSetHttpHeadersOptions\n  extends FileAndDirectorySetPropertiesCommonOptions,\n    CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.abortCopyFromURL} operation.\n */\nexport interface FileAbortCopyFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.resize} operation.\n */\nexport interface FileResizeOptions\n  extends FileAndDirectorySetPropertiesCommonOptions,\n    CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link ShareFileClient.clearRange} operation.\n */\nexport interface FileClearRangeOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure File - List Handles Segment operations.\n *\n * See:\n * - {@link ShareFileClient.listHandlesSegment}\n * - {@link ShareFileClient.iterateHandleSegments}\n * - {@link ShareFileClient.listHandleItems}\n */\nexport interface FileListHandlesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of entries to return. If the request does not specify maxResults,\n   * or specifies a value greater than 5,000, the server will return up to 5,000 items.\n   */\n  maxPageSize?: number;\n}\n\nexport interface FileListHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure File - Force Close Handles operations.\n *\n * See:\n * - {@link ShareFileClient.forceCloseHandlesSegment}\n * - {@link ShareFileClient.forceCloseAllHandles}\n * - {@link ShareFileClient.forceCloseHandle}\n */\nexport interface FileForceCloseHandlesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Additional response header values for close handles request.\n */\nexport interface FileCloseHandlesHeaders {\n  /**\n   * This header uniquely identifies the request that was made and can be used for troubleshooting\n   * the request.\n   */\n  requestId?: string;\n  /**\n   * Indicates the version of the File service used to execute the request.\n   */\n  version?: string;\n  /**\n   * A UTC date/time value generated by the service that indicates the time at which the response\n   * was initiated.\n   */\n  date?: Date;\n  /**\n   * A string describing next handle to be closed. It is returned when more handles need to be\n   * closed to complete the request.\n   */\n  marker?: string;\n}\n\n/**\n * Response type for {@link ShareFileClient.forceCloseHandle}.\n */\nexport type FileForceCloseHandlesResponse = CloseHandlesInfo &\n  FileCloseHandlesHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: FileForceCloseHandlesHeaders;\n    };\n  };\n\n/**\n * Option interface for ShareFileClient.uploadStream().\n */\nexport interface FileUploadStreamOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Azure File HTTP Headers.\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n\n  /**\n   * Metadata of the Azure file.\n   */\n  metadata?: Metadata;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Option interface for File - Upload operations\n *\n * See:\n * - {@link ShareFileClient.uploadFile}\n * - {@link ShareFileClient.uploadSeekableStream}\n */\nexport interface FileParallelUploadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * RangeSize specifies the range size to use in each parallel upload,\n   * the default (and maximum size) is FILE_RANGE_MAX_SIZE_BYTES.\n   */\n  rangeSize?: number;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * File HTTP Headers.\n   */\n  fileHttpHeaders?: FileHttpHeaders;\n\n  /**\n   * Metadata of an Azure file.\n   */\n  metadata?: Metadata;\n\n  /**\n   * Concurrency indicates the maximum number of ranges to upload in parallel.\n   * If not provided, 5 concurrency will be used by default.\n   */\n  concurrency?: number;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Option interface for the {@link ShareFileClient.downloadToBuffer} operation.\n */\nexport interface FileDownloadToBufferOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * When downloading Azure files, download method will try to split large file into small ranges.\n   * Every small range will be downloaded via a separate request.\n   * This option defines size data every small request trying to download.\n   * Must be greater than 0, will use the default value if undefined,\n   */\n  rangeSize?: number;\n\n  /**\n   * Optional. ONLY AVAILABLE IN NODE.JS.\n   *\n   * How many retries will perform when original range download stream unexpected ends.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors.\n   *\n   * With this option, every additional retry means an additional ShareFileClient.download() request will be made\n   * from the broken point, until the requested range has been successfully downloaded or\n   * maxRetryRequestsPerRange is reached.\n   *\n   * Default value is 5, please set a larger value when in poor network.\n   */\n  maxRetryRequestsPerRange?: number;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Concurrency indicates the maximum number of ranges to download in parallel.\n   * If not provided, 5 concurrency will be used by default.\n   */\n  concurrency?: number;\n  /**\n   * Lease access conditions.\n   */\n  leaseAccessConditions?: LeaseAccessConditions;\n}\n\n/**\n * Contains response data for the {@link ShareFileClient.deleteIfExists} operation.\n */\nexport interface FileDeleteIfExistsResponse extends FileDeleteResponse {\n  /**\n   * Indicate whether the file is successfully deleted. Is false if the file does not exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Options to configure {@link ShareFileClient.generateSasUrl} operation.\n */\nexport interface FileGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: FileSASPermissions;\n}\n\n/**\n * A ShareFileClient represents a URL to an Azure Storage file.\n */\nexport class ShareFileClient extends StorageClient {\n  /**\n   * context provided by protocol layer.\n   */\n  private context: File;\n\n  private _shareName: string;\n  private _path: string;\n  private _name: string;\n\n  /**\n   * The share name corresponding to this file client\n   */\n  public get shareName(): string {\n    return this._shareName;\n  }\n\n  /**\n   * The full path of the file\n   */\n  public get path(): string {\n    return this._path;\n  }\n\n  /**\n   * The name of the file\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Creates an instance of ShareFileClient.\n   *\n   * @param url - A URL string pointing to Azure Storage file, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a file.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.\n   *                     Such as a file named \"myfile%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25\".\n   * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.\n   *                                  If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of ShareFileClient.\n   *\n   * @param url - A URL string pointing to Azure Storage file, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a file.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.\n   *                     Such as a file named \"myfile%\", the URL should be \"https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: Pipeline);\n  constructor(\n    url: string,\n    credentialOrPipeline?: Credential | Pipeline,\n    options?: StoragePipelineOptions\n  ) {\n    let pipeline: Pipeline;\n    if (credentialOrPipeline instanceof Pipeline) {\n      pipeline = credentialOrPipeline;\n    } else if (credentialOrPipeline instanceof Credential) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential.\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n\n    super(url, pipeline);\n    ({\n      baseName: this._name,\n      shareName: this._shareName,\n      path: this._path\n    } = getShareNameAndPathFromUrl(this.url));\n    this.context = new File(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new ShareFileClient object identical to the source but with the specified share snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base ShareFileClient.\n   *\n   * @param shareSnapshot - The share snapshot timestamp.\n   * @returns A new ShareFileClient object identical to the source but with the specified share snapshot timestamp.\n   */\n  public withShareSnapshot(shareSnapshot: string): ShareFileClient {\n    return new ShareFileClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.SHARE_SNAPSHOT,\n        shareSnapshot.length === 0 ? undefined : shareSnapshot\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a new file or replaces a file. Note it only initializes the file with no content.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file\n   *\n   * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.\n   * @param options - Options to File Create operation.\n   * @returns Response data for the File Create  operation.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * // Create the file\n   * await fileClient.create(content.length);\n   * console.log(\"Created file successfully!\");\n   *\n   * // Then upload data to the file\n   * await fileClient.uploadRange(content, 0, content.length);\n   * console.log(\"Updated file successfully!\")\n   * ```\n   */\n  public async create(size: number, options: FileCreateOptions = {}): Promise<FileCreateResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-create\", options);\n    try {\n      if (size < 0 || size > FILE_MAX_SIZE_BYTES) {\n        throw new RangeError(`File size must >= 0 and < ${FILE_MAX_SIZE_BYTES}.`);\n      }\n      options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);\n\n      if (!options.fileAttributes) {\n        // Note: It would be Archive in service side if None is set.\n        const attributes: FileSystemAttributes = new FileSystemAttributes();\n        attributes.none = true;\n        options.fileAttributes = attributes;\n      }\n\n      options.fileHttpHeaders = options.fileHttpHeaders || {};\n\n      return await this.context.create(\n        size,\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          fileHttpHeaders: options.fileHttpHeaders,\n          metadata: options.metadata,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          leaseAccessConditions: options.leaseAccessConditions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Reads or downloads a file from the system, including its metadata and properties.\n   *\n   * * In Node.js, data returns in a Readable stream `readableStreamBody`\n   * * In browsers, data returns in a promise `contentAsBlob`\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file\n   *\n   * @param offset - From which position of the file to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Options to File Download operation.\n   * @returns Response data for the File Download operation.\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Download a file to a string\n   * const downloadFileResponse = await fileClient.download();\n   * console.log(\n   *   \"Downloaded file content:\",\n   *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}\n   * );\n   *\n   * // A helper method used to read a Node.js readable stream into string\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * Example usage (browsers):\n   *\n   * ```js\n   * // Download a file to a string\n   * const downloadFileResponse = await fileClient.download(0);\n   * console.log(\n   *   \"Downloaded file content:\",\n   *   await blobToString(await downloadFileResponse.blobBody)}\n   * );\n   *\n   * // A helper method used to convert a browser Blob into string.\n   * export async function blobToString(blob: Blob): Promise<string> {\n   *   const fileReader = new FileReader();\n   *   return new Promise<string>((resolve, reject) => {\n   *     fileReader.onloadend = (ev: any) => {\n   *       resolve(ev.target!.result);\n   *     };\n   *     fileReader.onerror = reject;\n   *     fileReader.readAsText(blob);\n   *   });\n   * }\n   * ```\n   */\n  public async download(\n    offset: number = 0,\n    count?: number,\n    options: FileDownloadOptions = {}\n  ): Promise<FileDownloadResponseModel> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-download\", options);\n    try {\n      if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {\n        throw new RangeError(`rangeGetContentMD5 only works with partial data downloading`);\n      }\n\n      const downloadFullFile = offset === 0 && !count;\n      const res = await this.context.download({\n        abortSignal: options.abortSignal,\n        requestOptions: {\n          onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream\n        },\n        range: downloadFullFile ? undefined : rangeToString({ offset, count }),\n        rangeGetContentMD5: options.rangeGetContentMD5,\n        leaseAccessConditions: options.leaseAccessConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      // Return browser response immediately\n      if (!isNode) {\n        return res;\n      }\n\n      // We support retrying when download stream unexpected ends in Node.js runtime\n      // Following code shouldn't be bundled into browser build, however some\n      // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n      // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n      // The config is in package.json \"browser\" field\n      if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n        // TODO: Default value or make it a required parameter?\n        options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n      }\n\n      if (res.contentLength === undefined) {\n        throw new RangeError(`File download response doesn't contain valid content length header`);\n      }\n\n      return new FileDownloadResponse(\n        res,\n        async (start: number): Promise<NodeJS.ReadableStream> => {\n          const updatedOptions: FileDownloadOptionalParams = {\n            range: rangeToString({\n              count: offset + res.contentLength! - start,\n              offset: start\n            })\n          };\n\n          // Debug purpose only\n          // console.log(\n          //   `Read from internal stream, range: ${\n          //     updatedOptions.range\n          //   }, options: ${JSON.stringify(updatedOptions)}`\n          // );\n\n          const downloadRes = await this.context.download({\n            abortSignal: options.abortSignal,\n            leaseAccessConditions: options.leaseAccessConditions,\n            ...updatedOptions,\n            ...convertTracingToRequestOptionsBase(updatedOptions)\n          });\n\n          if (!(downloadRes.etag === res.etag)) {\n            throw new Error(\"File has been modified concurrently\");\n          }\n          return downloadRes.readableStreamBody!;\n        },\n        offset,\n        res.contentLength!,\n        {\n          abortSignal: options.abortSignal,\n          maxRetryRequests: options.maxRetryRequests,\n          onProgress: options.onProgress\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns true if the specified file exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing file might be deleted by other clients or\n   * applications. Vice versa new files might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n  public async exists(options: FileExistsOptions = {}): Promise<boolean> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-exists\", options);\n    try {\n      await this.getProperties({\n        abortSignal: options.abortSignal,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      });\n      return true;\n    } catch (e) {\n      if (e.statusCode === 404) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when checking file existence\"\n        });\n        return false;\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the file. It does not return the content of the file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties\n   *\n   * @param options - Options to File Get Properties operation.\n   * @returns Response data for the File Get Properties operation.\n   */\n  public async getProperties(\n    options: FileGetPropertiesOptions = {}\n  ): Promise<FileGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-getProperties\", options);\n    try {\n      return this.context.getProperties({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.leaseAccessConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties on the file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties\n   *\n   * @param properties - File properties. For file HTTP headers(e.g. Content-Type),\n   *                                       if no values are provided, existing HTTP headers will be removed.\n   *                                       For other file properties(e.g. fileAttributes), if no values are provided,\n   *                                       existing values will be preserved.\n   */\n  public async setProperties(properties: FileProperties = {}): Promise<SetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-setProperties\", properties);\n    try {\n      properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);\n\n      properties.fileHttpHeaders = properties.fileHttpHeaders || {};\n\n      return await this.context.setHttpHeaders(\n        fileAttributesToString(properties.fileAttributes!),\n        fileCreationTimeToString(properties.creationTime!),\n        fileLastWriteTimeToString(properties.lastWriteTime!),\n        {\n          abortSignal: properties.abortSignal,\n          fileHttpHeaders: properties.fileHttpHeaders,\n          filePermission: properties.filePermission,\n          filePermissionKey: properties.filePermissionKey,\n          leaseAccessConditions: properties.leaseAccessConditions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the file from the storage account.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code SharingViolation\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param options - Options to File Delete operation.\n   * @returns Response data for the File Delete operation.\n   */\n  public async delete(options: FileDeleteOptions = {}): Promise<FileDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-delete\", options);\n    try {\n      return await this.context.delete({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.leaseAccessConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the file from the storage account if it exists.\n   * When a file is successfully deleted, it is immediately removed from the storage\n   * account's index and is no longer accessible to clients. The file's data is later\n   * removed from the service during garbage collection.\n   *\n   * Delete File will fail with status code 409 (Conflict) and error code SharingViolation\n   * if the file is open on an SMB client.\n   *\n   * Delete File is not supported on a share snapshot, which is a read-only copy of\n   * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2\n   *\n   * @param options -\n   */\n  public async deleteIfExists(\n    options: FileDeleteOptions = {}\n  ): Promise<FileDeleteIfExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-deleteIfExists\", options);\n    try {\n      const res = await this.delete(updatedOptions);\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (\n        e.details?.errorCode === \"ResourceNotFound\" ||\n        e.details?.errorCode === \"ParentNotFound\"\n      ) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when deleting a file only if it exists.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets HTTP headers on the file.\n   *\n   * If no option provided, or no value provided for the file HTTP headers in the options,\n   * these file HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties\n   *\n   * @param FileHttpHeaders - File HTTP headers like Content-Type.\n   *                                             Provide undefined will remove existing HTTP headers.\n   * @param options - Options to File Set HTTP Headers operation.\n   * @returns Response data for the File Set HTTP Headers operation.\n   */\n  public async setHttpHeaders(\n    fileHttpHeaders: FileHttpHeaders = {},\n    options: FileSetHttpHeadersOptions = {}\n  ): Promise<FileSetHTTPHeadersResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-setHTTPHeaders\", options);\n    try {\n      // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved\n      options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);\n      return await this.context.setHttpHeaders(\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          fileHttpHeaders,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          leaseAccessConditions: options.leaseAccessConditions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Resize file.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties\n   *\n   * @param length - Resizes a file to the specified size in bytes.\n   *                        If the specified byte value is less than the current size of the file,\n   *                        then all ranges above the specified byte value are cleared.\n   * @param options - Options to File Resize operation.\n   * @returns Response data for the File Set HTTP Headers operation.\n   */\n  public async resize(\n    length: number,\n    options: FileResizeOptions = {}\n  ): Promise<FileSetHTTPHeadersResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-resize\", options);\n    try {\n      if (length < 0) {\n        throw new RangeError(`Size cannot less than 0 when resizing file.`);\n      }\n      // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.\n      options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);\n\n      return await this.context.setHttpHeaders(\n        fileAttributesToString(options.fileAttributes!),\n        fileCreationTimeToString(options.creationTime!),\n        fileLastWriteTimeToString(options.lastWriteTime!),\n        {\n          abortSignal: options.abortSignal,\n          fileContentLength: length,\n          filePermission: options.filePermission,\n          filePermissionKey: options.filePermissionKey,\n          leaseAccessConditions: options.leaseAccessConditions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Updates user-defined metadata for the specified file.\n   *\n   * If no metadata defined in the option parameter, the file\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata\n   *\n   * @param metadata - If no metadata provided, all existing directory metadata will be removed\n   * @param options - Options to File Set Metadata operation.\n   * @returns Response data for the File Set Metadata operation.\n   */\n  public async setMetadata(\n    metadata: Metadata = {},\n    options: FileSetMetadataOptions = {}\n  ): Promise<FileSetMetadataResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-setMetadata\", options);\n    try {\n      return await this.context.setMetadata({\n        abortSignal: options.abortSignal,\n        metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Upload a range of bytes to a file. This operation can only be called on an existing file.\n   * It won't change the size, properties or metadata of the file.\n   * Both the start and count of the range must be specified. The range can be up to 4 MB in size.\n   *\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param offset - Offset position of the destination Azure File to upload.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to File Upload Range operation.\n   * @returns Response data for the File Upload Range operation.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * // Create the file\n   * await fileClient.create(content.length);\n   * console.log(\"Created file successfully!\");\n   *\n   * // Then upload data to the file\n   * await fileClient.uploadRange(content, 0, content.length);\n   * console.log(\"Updated file successfully!\")\n   * ```\n   */\n  public async uploadRange(\n    body: HttpRequestBody,\n    offset: number,\n    contentLength: number,\n    options: FileUploadRangeOptions = {}\n  ): Promise<FileUploadRangeResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadRange\", options);\n    try {\n      if (offset < 0) {\n        throw new RangeError(`offset must be >= 0`);\n      }\n\n      if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`contentLength must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);\n      }\n\n      if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`offset must be < ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);\n      }\n\n      return await this.context.uploadRange(\n        rangeToString({ count: contentLength, offset }),\n        \"update\",\n        contentLength,\n        {\n          abortSignal: options.abortSignal,\n          contentMD5: options.contentMD5,\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          body: body,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n          leaseAccessConditions: options.leaseAccessConditions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Upload a range of bytes to a file where the contents are read from a another file's URL.\n   * The range can be up to 4 MB in size.\n   *\n   * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.\n   * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source file.\n   * @param destOffset - Offset of destination file.\n   * @param count - Number of bytes to be uploaded from source file.\n   * @param options - Options to configure File - Upload Range from URL operation.\n   */\n  public async uploadRangeFromURL(\n    sourceURL: string,\n    sourceOffset: number,\n    destOffset: number,\n    count: number,\n    options: FileUploadRangeFromURLOptions = {}\n  ): Promise<FileUploadRangeFromURLResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadRangeFromURL\", options);\n    try {\n      if (sourceOffset < 0 || destOffset < 0) {\n        throw new RangeError(`sourceOffset and destOffset must be >= 0`);\n      }\n\n      if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`count must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);\n      }\n\n      return await this.context.uploadRangeFromURL(\n        rangeToString({ offset: destOffset, count }),\n        sourceURL,\n        0,\n        {\n          abortSignal: options.abortSignal,\n          sourceRange: rangeToString({ offset: sourceOffset, count }),\n          sourceModifiedAccessConditions: options.sourceConditions,\n          ...options,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Clears the specified range and\n   * releases the space used in storage for that range.\n   *\n   * @param offset -\n   * @param contentLength -\n   * @param options - Options to File Clear Range operation.\n   */\n  public async clearRange(\n    offset: number,\n    contentLength: number,\n    options: FileClearRangeOptions = {}\n  ): Promise<FileUploadRangeResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-clearRange\", options);\n    try {\n      if (offset < 0 || contentLength <= 0) {\n        throw new RangeError(`offset must >= 0 and contentLength must be > 0`);\n      }\n\n      return await this.context.uploadRange(\n        rangeToString({ count: contentLength, offset }),\n        \"clear\",\n        0,\n        {\n          abortSignal: options.abortSignal,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n          leaseAccessConditions: options.leaseAccessConditions\n        }\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the list of valid ranges for a file.\n   *\n   * @param options - Options to File Get range List operation.\n   */\n  public async getRangeList(\n    options: FileGetRangeListOptions = {}\n  ): Promise<FileGetRangeListResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-getRangeList\", options);\n    try {\n      const originalResponse = await this.context.getRangeList({\n        abortSignal: options.abortSignal,\n        range: options.range ? rangeToString(options.range) : undefined,\n        leaseAccessConditions: options.leaseAccessConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      // Only returns ranges, ignoring clearRanges.\n      const parsedBody = originalResponse._response.parsedBody.ranges\n        ? originalResponse._response.parsedBody.ranges\n        : [];\n      return {\n        ...originalResponse,\n        _response: { ...originalResponse._response, parsedBody },\n        rangeList: originalResponse.ranges ? originalResponse.ranges : []\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the list of ranges that differ between a previous share snapshot and this file.\n   *\n   * @param prevShareSnapshot - The previous snapshot parameter is an opaque DateTime value that specifies the previous share snapshot to compare with.\n   * @param options -\n   */\n  public async getRangeListDiff(\n    prevShareSnapshot: string,\n    options: FileGetRangeListOptions = {}\n  ): Promise<FileGetRangeListDiffResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-getRangeListDiff\", options);\n    try {\n      return await this.context.getRangeList({\n        prevsharesnapshot: prevShareSnapshot,\n        ...options,\n        range: options.range ? rangeToString(options.range) : undefined,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Copies a blob or file to a destination file within the storage account.\n   *\n   * @param copySource - Specifies the URL of the source file or blob, up to 2 KB in length.\n   * To copy a file to another file within the same storage account, you may use Shared Key to\n   * authenticate the source file. If you are copying a file from another storage account, or if you\n   * are copying a blob from the same storage account or another storage account, then you must\n   * authenticate the source file or blob using a shared access signature. If the source is a public\n   * blob, no authentication is required to perform the copy operation. A file in a share snapshot\n   * can also be specified as a copy source.\n   * @param options - Options to File Start Copy operation.\n   */\n  public async startCopyFromURL(\n    copySource: string,\n    options: FileStartCopyOptions = {}\n  ): Promise<FileStartCopyResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-startCopyFromURL\", options);\n    try {\n      return await this.context.startCopy(copySource, {\n        abortSignal: options.abortSignal,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        filePermission: options.filePermission,\n        filePermissionKey: options.filePermissionKey,\n        copyFileSmbInfo: options.copyFileSmbInfo,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Aborts a pending Copy File operation, and leaves a destination file with zero length and full\n   * metadata.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file\n   *\n   * @param copyId - Id of the Copy File operation to abort.\n   * @param options - Options to File Abort Copy From URL operation.\n   */\n  public async abortCopyFromURL(\n    copyId: string,\n    options: FileAbortCopyFromURLOptions = {}\n  ): Promise<FileAbortCopyResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-abortCopyFromURL\", options);\n    try {\n      return await this.context.abortCopy(copyId, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.leaseAccessConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // High Level functions\n\n  /**\n   * Creates a new Azure File or replaces an existing Azure File, and then uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to it.\n   *\n   * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView\n   * @param options -\n   */\n  public async uploadData(\n    data: Buffer | Blob | ArrayBuffer | ArrayBufferView,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadData\", options);\n    try {\n      if (isNode) {\n        let buffer: Buffer;\n        if (data instanceof Buffer) {\n          buffer = data;\n        } else if (data instanceof ArrayBuffer) {\n          buffer = Buffer.from(data);\n        } else {\n          data = data as ArrayBufferView;\n          buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Buffer => buffer.slice(offset, offset + size),\n          buffer.byteLength,\n          updatedOptions\n        );\n      } else {\n        const browserBlob = new Blob([data]);\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Blob => browserBlob.slice(offset, offset + size),\n          browserBlob.size,\n          updatedOptions\n        );\n      }\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN BROWSERS.\n   *\n   * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,\n   * which need to return a Blob object with the offset and size provided.\n   *\n   * @param blobFactory -\n   * @param size -\n   * @param options -\n   */\n  async uploadSeekableBlob(\n    blobFactory: (offset: number, size: number) => Blob,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-UploadSeekableBlob\", options);\n    try {\n      return this.uploadSeekableInternal(blobFactory, size, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Creates a new Azure File or replaces an existing Azure File, and then uploads a local file to it.\n   *\n   * @param filePath - Full path of local file\n   * @param fileClient - ShareFileClient\n   * @param options -\n   */\n  public async uploadFile(\n    filePath: string,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadFile\", options);\n    try {\n      const size = (await fsStat(filePath)).size;\n      return await this.uploadSeekableInternal(\n        (offset, count) => {\n          return () =>\n            fsCreateReadStream(filePath, {\n              autoClose: true,\n              end: count ? offset + count - 1 : Infinity,\n              start: offset\n            });\n        },\n        size,\n        updatedOptions\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.\n   * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset\n   * is the offset in the Azure file to be uploaded.\n   *\n   * @param streamFactory - Returns a Node.js Readable stream starting\n   *                                                                  from the offset defined\n   * @param size - Size of the Azure file\n   * @param fileClient - ShareFileClient\n   * @param options -\n   */\n  async uploadResetableStream(\n    streamFactory: (offset: number, count?: number) => NodeJS.ReadableStream,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadResetableStream\", options);\n    try {\n      return await this.uploadSeekableInternal(\n        (offset: number, count?: number) => {\n          return () => streamFactory(offset, count);\n        },\n        size,\n        updatedOptions\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   *\n   * @param bodyFactory -\n   * @param size - Size of the Azure file\n   * @param fileClient - ShareFileClient\n   * @param options -\n   */\n  private async uploadSeekableInternal(\n    bodyFactory: (offset: number, count: number) => HttpRequestBody,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadSeekableInternal\", options);\n    try {\n      if (!options.rangeSize) {\n        options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;\n      }\n      if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`options.rangeSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);\n      }\n\n      if (!options.fileHttpHeaders) {\n        options.fileHttpHeaders = {};\n      }\n\n      if (!options.concurrency) {\n        options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.concurrency < 0) {\n        throw new RangeError(`options.concurrency cannot less than 0.`);\n      }\n\n      // Create the file\n      await this.create(size, {\n        abortSignal: options.abortSignal,\n        fileHttpHeaders: options.fileHttpHeaders,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n\n      const numBlocks: number = Math.floor((size - 1) / options.rangeSize) + 1;\n      let transferProgress: number = 0;\n      const batch = new Batch(options.concurrency);\n\n      for (let i = 0; i < numBlocks; i++) {\n        batch.addOperation(\n          async (): Promise<any> => {\n            const start = options.rangeSize! * i;\n            const end = i === numBlocks - 1 ? size : start + options.rangeSize!;\n            const contentLength = end - start;\n            await this.uploadRange(bodyFactory(start, contentLength), start, contentLength, {\n              abortSignal: options.abortSignal,\n              leaseAccessConditions: options.leaseAccessConditions,\n              tracingOptions: updatedOptions.tracingOptions\n            });\n            // Update progress after block is successfully uploaded to server, in case of block trying\n            transferProgress += contentLength;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          }\n        );\n      }\n      return await batch.do();\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to download the entire file.\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link downloadToFile}.\n   *\n   * @param buffer - Buffer to be fill, must have length larger than count\n   * @param offset - From which position of the Azure File to download\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined\n   * @param options -\n   */\n  public async downloadToBuffer(\n    buffer: Buffer,\n    offset?: number,\n    count?: number,\n    options?: FileDownloadToBufferOptions\n  ): Promise<Buffer>;\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME\n   *\n   * Downloads an Azure file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to download the entire file\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link downloadToFile}.\n   *\n   * @param offset - From which position of the Azure file to download\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined\n   * @param options -\n   */\n  public async downloadToBuffer(\n    offset?: number,\n    count?: number,\n    options?: FileDownloadToBufferOptions\n  ): Promise<Buffer>;\n\n  public async downloadToBuffer(\n    bufferOrOffset?: Buffer | number,\n    offsetOrCount?: number,\n    countOrOptions?: FileDownloadToBufferOptions | number,\n    optOptions: FileDownloadToBufferOptions = {}\n  ): Promise<Buffer> {\n    let buffer: Buffer | undefined = undefined;\n    let offset: number;\n    let count: number;\n    let options: FileDownloadToBufferOptions = optOptions;\n\n    if (bufferOrOffset instanceof Buffer) {\n      buffer = bufferOrOffset;\n      offset = offsetOrCount || 0;\n      count = typeof countOrOptions === \"number\" ? countOrOptions : 0;\n    } else {\n      offset = typeof bufferOrOffset === \"number\" ? bufferOrOffset : 0;\n      count = typeof offsetOrCount === \"number\" ? offsetOrCount : 0;\n      options = (countOrOptions as FileDownloadToBufferOptions) || {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-downloadToBuffer\", options);\n\n    try {\n      if (!options.rangeSize) {\n        options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;\n      }\n      if (options.rangeSize < 0) {\n        throw new RangeError(\"rangeSize option must be > 0\");\n      }\n\n      if (offset < 0) {\n        throw new RangeError(\"offset option must be >= 0\");\n      }\n\n      if (count && count <= 0) {\n        throw new RangeError(\"count option must be > 0\");\n      }\n\n      if (!options.concurrency) {\n        options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.concurrency < 0) {\n        throw new RangeError(`options.concurrency cannot less than 0.`);\n      }\n\n      // Customer doesn't specify length, get it\n      if (!count) {\n        const response = await this.getProperties({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.leaseAccessConditions,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        count = response.contentLength! - offset;\n        if (count < 0) {\n          throw new RangeError(\n            `offset ${offset} shouldn't be larger than file size ${response.contentLength!}`\n          );\n        }\n      }\n\n      if (!buffer) {\n        try {\n          buffer = Buffer.alloc(count);\n        } catch (error) {\n          throw new Error(\n            `Unable to allocate a buffer of size: ${count} bytes. Please try passing your own Buffer to ` +\n              'the \"downloadToBuffer method or try using other methods like \"download\" or \"downloadToFile\".' +\n              `\\t ${error.message}`\n          );\n        }\n      }\n\n      if (buffer.length < count) {\n        throw new RangeError(\n          `The buffer's size should be equal to or larger than the request count of bytes: ${count}`\n        );\n      }\n\n      let transferProgress: number = 0;\n      const batch = new Batch(options.concurrency);\n      for (let off = offset; off < offset + count; off = off + options.rangeSize) {\n        batch.addOperation(async () => {\n          // Exclusive chunk end position\n          let chunkEnd = offset + count!;\n          if (off + options.rangeSize! < chunkEnd) {\n            chunkEnd = off + options.rangeSize!;\n          }\n          const response = await this.download(off, chunkEnd - off, {\n            abortSignal: options.abortSignal,\n            maxRetryRequests: options.maxRetryRequestsPerRange,\n            leaseAccessConditions: options.leaseAccessConditions,\n            tracingOptions: updatedOptions.tracingOptions\n          });\n          const stream = response.readableStreamBody!;\n          await streamToBuffer(stream, buffer!, off - offset, chunkEnd - offset);\n          // Update progress after block is downloaded, in case of block trying\n          // Could provide finer grained progress updating inside HTTP requests,\n          // only if convenience layer download try is enabled\n          transferProgress += chunkEnd - off;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        });\n      }\n      await batch.do();\n      return buffer;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Creates a new Azure File or replaces an existing Azure File, and then uploads a Node.js Readable stream into it.\n   * This method will try to create an Azure File, then starts uploading chunk by chunk.\n   * Size of chunk is defined by `bufferSize` parameter.\n   * Please make sure potential size of stream doesn't exceed file size.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with bufferSize\n   *   parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param stream - Node.js Readable stream. Must be less or equal than file size.\n   * @param size - Size of file to be created. Maximum size allowed is 4 TB.\n   *                      If this value is larger than stream size, there will be empty bytes in file tail.\n   * @param bufferSize - Size of every buffer allocated in bytes, also the chunk/range size during\n   *                            the uploaded file. Size must be greater than 0 and lesser than or equal to 4 * 1024 * 1024 (4MB)\n   * @param maxBuffers - Max buffers will allocate during uploading, positive correlation\n   *                            with max uploading concurrency\n   * @param options -\n   */\n  public async uploadStream(\n    stream: Readable,\n    size: number,\n    bufferSize: number,\n    maxBuffers: number,\n    options: FileUploadStreamOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-uploadStream\", options);\n    try {\n      if (!options.fileHttpHeaders) {\n        options.fileHttpHeaders = {};\n      }\n\n      if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {\n        throw new RangeError(`bufferSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);\n      }\n\n      if (maxBuffers < 0) {\n        throw new RangeError(`maxBuffers must be > 0.`);\n      }\n\n      // Create the file\n      await this.create(size, {\n        abortSignal: options.abortSignal,\n        fileHttpHeaders: options.fileHttpHeaders,\n        metadata: options.metadata,\n        leaseAccessConditions: options.leaseAccessConditions,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n\n      let transferProgress: number = 0;\n      const scheduler = new BufferScheduler(\n        stream,\n        bufferSize,\n        maxBuffers,\n        async (buffer: Buffer, offset?: number) => {\n          if (transferProgress + buffer.length > size) {\n            throw new RangeError(\n              `Stream size is larger than file size ${size} bytes, uploading failed. ` +\n                `Please make sure stream length is less or equal than file size.`\n            );\n          }\n\n          await this.uploadRange(buffer, offset!, buffer.length, {\n            abortSignal: options.abortSignal,\n            leaseAccessConditions: options.leaseAccessConditions,\n            tracingOptions: updatedOptions.tracingOptions\n          });\n\n          // Update progress after block is successfully uploaded to server, in case of block trying\n          transferProgress += buffer.length;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        },\n        // Concurrency should set a smaller value than maxBuffers, which is helpful to\n        // reduce the possibility when a outgoing handler waits for stream data, in\n        // this situation, outgoing handlers are blocked.\n        // Outgoing queue shouldn't be empty.\n        Math.ceil((maxBuffers / 4) * 3)\n      );\n      return await scheduler.do();\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n   *\n   * @param filePath -\n   * @param offset - From which position of the block blob to download.\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n   * @param options - Options to Blob download options.\n   * @returns The response data for blob download operation,\n   *                                                 but with readableStreamBody set to undefined since its\n   *                                                 content is already read and written into a local file\n   *                                                 at the specified path.\n   */\n  public async downloadToFile(\n    filePath: string,\n    offset: number = 0,\n    count?: number,\n    options: FileDownloadOptions = {}\n  ): Promise<FileDownloadResponseModel> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-downloadToFile\", options);\n    try {\n      const response = await this.download(offset, count, updatedOptions);\n      if (response.readableStreamBody) {\n        await readStreamToLocalFile(response.readableStreamBody, filePath);\n      }\n\n      // The stream is no longer accessible so setting it to undefined.\n      (response as any).fileDownloadStream = undefined;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Lists handles for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles\n   *\n   * @param marker - Optional. A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param options -\n   */\n  private async listHandlesSegment(\n    marker?: string,\n    options: FileListHandlesSegmentOptions = {}\n  ): Promise<FileListHandlesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-listHandlesSegment\", options);\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const response = await this.context.listHandles({\n        abortSignal: options.abortSignal,\n        marker,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n\n      // TODO: Protocol layer issue that when handle list is in returned XML\n      // response.handleList is an empty string\n      if ((response.handleList as any) === \"\") {\n        response.handleList = undefined;\n      }\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for FileListHandlesResponse\n   *\n   * @param marker - A string value that identifies the portion of the list to be\n   *                          returned with the next list handles operation. The operation returns a\n   *                          marker value within the response body if the list returned was not complete.\n   *                          The marker value may then be used in a subsequent call to request the next\n   *                          set of list items.\n   * @param options - Options to list handles operation.\n   */\n  private async *iterateHandleSegments(\n    marker?: string,\n    options: FileListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<FileListHandlesResponse> {\n    let listHandlesResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listHandlesResponse = await this.listHandlesSegment(marker, options);\n        marker = listHandlesResponse.continuationToken;\n        yield listHandlesResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for handles\n   *\n   * @param options - Options to list handles operation.\n   */\n  private async *listHandleItems(\n    options: FileListHandlesSegmentOptions = {}\n  ): AsyncIterableIterator<HandleItem> {\n    let marker: string | undefined;\n    for await (const listHandlesResponse of this.iterateHandleSegments(marker, options)) {\n      if (listHandlesResponse.handleList) {\n        for (const handle of listHandlesResponse.handleList) {\n          yield handle;\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the handles.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the handles in pages.\n   *\n   * @param options - Options to list handles operation.\n   *\n   * An asyncIterableIterator that supports paging.\n   */\n  public listHandles(\n    options: FileListHandlesOptions = {}\n  ): PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse> {\n    // an AsyncIterableIterator to iterate over handles\n    const iter = this.listHandleItems(options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.iterateHandleSegments(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options\n        });\n      }\n    };\n  }\n\n  /**\n   * Force close all handles for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param marker - Optional. A string value that identifies the position of handles that will\n   *                          be closed with the next force close handles operation.\n   *                          The operation returns a marker value within the response\n   *                          body if there are more handles to close. The marker value\n   *                          may then be used in a subsequent call to close the next set of handles.\n   * @param options - Options to force close handles operation.\n   */\n  private async forceCloseHandlesSegment(\n    marker?: string,\n    options: FileForceCloseHandlesOptions = {}\n  ): Promise<FileForceCloseHandlesResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"ShareFileClient-forceCloseHandlesSegment\",\n      options\n    );\n    try {\n      marker = marker === \"\" ? undefined : marker;\n      const rawResponse = await this.context.forceCloseHandles(\"*\", {\n        abortSignal: options.abortSignal,\n        marker,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n      const response = rawResponse as FileForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close all handles for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param options - Options to force close handles operation.\n   */\n  public async forceCloseAllHandles(\n    options: FileForceCloseHandlesOptions = {}\n  ): Promise<CloseHandlesInfo> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-forceCloseAllHandles\", options);\n    try {\n      let handlesClosed = 0;\n      let numberOfHandlesFailedToClose = 0;\n      let marker: string | undefined = \"\";\n\n      do {\n        const response: FileForceCloseHandlesResponse = await this.forceCloseHandlesSegment(\n          marker,\n          { tracingOptions: updatedOptions.tracingOptions }\n        );\n        marker = response.marker;\n        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);\n        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);\n      } while (marker);\n\n      return {\n        closedHandlesCount: handlesClosed,\n        closeFailureCount: numberOfHandlesFailedToClose\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Force close a specific handle for a file.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles\n   *\n   * @param handleId - Specific handle ID, cannot be asterisk \"*\".\n   *                          Use forceCloseAllHandles() to close all handles.\n   * @param FileForceCloseHandlesOptions - Options to force close handles operation.\n   */\n  public async forceCloseHandle(\n    handleId: string,\n    options: FileForceCloseHandlesOptions = {}\n  ): Promise<FileForceCloseHandlesResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareFileClient-forceCloseHandle\", options);\n    try {\n      if (handleId === \"*\") {\n        throw new RangeError(\n          `Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`\n        );\n      }\n\n      const rawResponse = await this.context.forceCloseHandles(handleId, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n      const response = rawResponse as FileForceCloseHandlesResponse;\n      response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;\n      response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Get a {@link ShareLeaseClient} that manages leases on the file.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new ShareLeaseClient object for managing leases on the file.\n   */\n  public getShareLeaseClient(proposeLeaseId?: string) {\n    return new ShareLeaseClient(this, proposeLeaseId);\n  }\n\n  /**\n   * Only available for clients constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: FileGenerateSasUrlOptions): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the SAS when the client is initialized with a shared key credential\"\n      );\n    }\n\n    const sas = generateFileSASQueryParameters(\n      {\n        shareName: this.shareName,\n        filePath: this.path,\n        ...options\n      },\n      this.credential\n    ).toString();\n\n    return appendToURLQuery(this.url, sas);\n  }\n}\n\n/**\n * The details of the response for a specific lease operation.\n */\nexport interface LeaseOperationResponseHeaders {\n  /**\n   * The ETag contains a value that you can use to perform operations conditionally. If the request\n   * version is 2011-08-18 or newer, the ETag value will be in quotes.\n   */\n  etag?: string;\n  /**\n   * Returns the date and time the file was last modified. Any operation that modifies the file,\n   * including an update of the file's metadata or properties, changes the last-modified time of\n   * the file.\n   */\n  lastModified?: Date;\n  /**\n   * Approximate time remaining in the lease period, in seconds. Only availabe for {@link ShareLeaseClient.breakLease} for share lease.\n   */\n  leaseTimeInSeconds?: number;\n  /**\n   * Uniquely identifies a file's lease, won't be set when returned by releaseLease.\n   */\n  leaseId?: string;\n  /**\n   * This header uniquely identifies the request that was made and can be used for troubleshooting\n   * the request.\n   */\n  requestId?: string;\n  /**\n   * Indicates the version of the Blob service used to execute the request. This header is returned\n   * for requests made against version 2009-09-19 and above.\n   */\n  version?: string;\n  /**\n   * UTC date/time value generated by the service that indicates the time at which the response was\n   * initiated\n   */\n  date?: Date;\n  errorCode?: string;\n}\n\n/**\n * Contains the response data for operations that acquire, change, break or release a lease.\n *\n * See {@link ShareLeaseClient}.\n */\nexport type LeaseOperationResponse = LeaseOperationResponseHeaders & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse & {\n    /**\n     * The parsed HTTP response headers.\n     */\n    parsedHeaders: LeaseOperationResponseHeaders;\n  };\n};\n\n/**\n * lease operations options.\n */\nexport interface LeaseOperationOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * A client that manages leases for a {@link ShareFileClient} or {@link ShareClient}.\n * @see https://docs.microsoft.com/rest/api/storageservices/lease-file\n * and\n * @see https://docs.microsoft.com/rest/api/storageservices/lease-share\n */\nexport class ShareLeaseClient {\n  private _leaseId: string;\n  private _url: string;\n  private fileOrShare: File | Share;\n  private isShare: boolean;\n  /**\n   * Gets the lease Id.\n   *\n   * @readonly\n   */\n  public get leaseId(): string {\n    return this._leaseId;\n  }\n\n  /**\n   * Gets the url.\n   *\n   * @readonly\n   */\n  public get url(): string {\n    return this._url;\n  }\n\n  /**\n   * Creates an instance of ShareLeaseClient.\n   * @param client - The client to make the lease operation requests.\n   * @param leaseId - Initial proposed lease id.\n   */\n  constructor(client: ShareFileClient, leaseId?: string) {\n    const clientContext = new StorageClientContext(client.url, {\n      version: SERVICE_VERSION,\n      ...(client as any).pipeline.toServiceClientOptions()\n    });\n\n    if (client instanceof ShareClient) {\n      this.isShare = true;\n      this.fileOrShare = new Share(clientContext);\n    } else {\n      this.isShare = false;\n      this.fileOrShare = new File(clientContext);\n    }\n    this._url = client.url;\n\n    if (!leaseId) {\n      leaseId = generateUuid();\n    }\n    this._leaseId = leaseId;\n  }\n\n  /**\n   * Establishes and manages a lock on a file, share or share snapshot for write and delete operations.\n   *\n   * @param duration - Specifies the duration of lease in seconds. For file, the only allowed value is -1 for a lease that never expires. For share, must be -1 or between 15 to 60.\n   * @param options - Options for the lease management operation.\n   * @returns Response data for acquire lease operation.\n   */\n  public async acquireLease(\n    duration: number = -1,\n    options: LeaseOperationOptions = {}\n  ): Promise<LeaseOperationResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareLeaseClient-acquireLease\", options);\n    try {\n      return await this.fileOrShare.acquireLease({\n        abortSignal: options.abortSignal,\n        duration,\n        proposedLeaseId: this._leaseId,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To change the ID of an existing lease.\n   *\n   * @param proposedLeaseId - the proposed new lease Id.\n   * @param options - Options for the lease management operation.\n   * @returns Response data for change lease operation.\n   */\n  public async changeLease(\n    proposedLeaseId: string,\n    options: LeaseOperationOptions = {}\n  ): Promise<LeaseOperationResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareLeaseClient-changeLease\", options);\n    try {\n      const response = await this.fileOrShare.changeLease(this._leaseId, {\n        proposedLeaseId,\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n      this._leaseId = proposedLeaseId;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To free the lease if it is no longer needed so that another client may\n   * immediately acquire a lease.\n   *\n   * @param options - Options for the lease management operation.\n   * @returns Response data for release lease operation.\n   */\n  public async releaseLease(options: LeaseOperationOptions = {}): Promise<LeaseOperationResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareLeaseClient-releaseLease\", options);\n    try {\n      return await this.fileOrShare.releaseLease(this._leaseId, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To force end the lease.\n   *\n   * @param options - Options for the lease management operation.\n   * @returns Response data for break lease operation.\n   */\n  public async breakLease(options: LeaseOperationOptions = {}): Promise<LeaseOperationResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareLeaseClient-breakLease\", options);\n    try {\n      return await this.fileOrShare.breakLease({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * To renew the lease. Only available for lease on share or share snapshot.\n   * Note that the lease may be renewed even if it has expired as long as the share has not been leased again since the expiration of that lease.\n   * When you renew a lease, the lease duration clock resets.\n   *\n   * @param options - Options for the lease management operation.\n   * @returns Response data for renew lease operation.\n   */\n  public async renewLease(options: LeaseOperationOptions = {}): Promise<LeaseOperationResponse> {\n    const { span, updatedOptions } = createSpan(\"ShareLeaseClient-renewLease\", options);\n\n    if (!this.isShare) {\n      throw new RangeError(\"The renewLease operation is not available for lease on file.\");\n    }\n\n    try {\n      return await (this.fileOrShare as Share).renewLease(this._leaseId, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n"]}
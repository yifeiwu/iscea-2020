// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __assign, __asyncGenerator, __asyncValues, __await, __awaiter, __extends, __generator } from "tslib";
import { isNode } from "@azure/core-http";
import { SpanStatusCode } from "@azure/core-tracing";
import { Share, Directory, File } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, DEFAULT_HIGH_LEVEL_CONCURRENCY, FILE_MAX_SIZE_BYTES, FILE_RANGE_MAX_SIZE_BYTES, URLConstants } from "./utils/constants";
import { appendToURLPath, setURLParameter, truncatedISO8061Date, extractConnectionStringParts, getShareNameAndPathFromUrl, appendToURLQuery } from "./utils/utils.common";
import { Credential } from "./credentials/Credential";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { convertTracingToRequestOptionsBase, createSpan } from "./utils/tracing";
import { StorageClient } from "./StorageClient";
import "@azure/core-paging";
import { FileSystemAttributes } from "./FileSystemAttributes";
import { FileDownloadResponse } from "./FileDownloadResponse";
import { rangeToString } from "./Range";
import { fileAttributesToString, fileCreationTimeToString, fileLastWriteTimeToString, validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions, validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions, toShareProtocolsString, toShareProtocols } from "./models";
import { Batch } from "./utils/Batch";
import { BufferScheduler } from "./utils/BufferScheduler";
import { fsStat, fsCreateReadStream, readStreamToLocalFile, streamToBuffer } from "./utils/utils.node";
import { StorageClientContext } from "./generated/src/storageClientContext";
import { SERVICE_VERSION } from "./utils/constants";
import { generateUuid } from "@azure/core-http";
import { generateFileSASQueryParameters } from "./FileSASSignatureValues";
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 */
var ShareClient = /** @class */ (function (_super) {
    __extends(ShareClient, _super);
    function ShareClient(urlOrConnectionString, credentialOrPipelineOrShareName, options) {
        var _this = this;
        var pipeline;
        var url;
        if (credentialOrPipelineOrShareName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrShareName;
        }
        else if (credentialOrPipelineOrShareName instanceof Credential) {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrShareName, options);
        }
        else if (!credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName !== "string") {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName === "string") {
            // (connectionString: string, name: string, options?: StoragePipelineOptions)
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            var name_1 = credentialOrPipelineOrShareName;
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, name_1);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url = appendToURLPath(extractedCreds.url, name_1) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for name parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._name = getShareNameAndPathFromUrl(_this.url).shareName;
        _this.context = new Share(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareClient.prototype, "name", {
        /**
         * The name of the share
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new ShareClient object identical to the source but with the specified snapshot timestamp
     */
    ShareClient.prototype.withSnapshot = function (snapshot) {
        return new ShareClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options - Options to Share Create operation.
     * @returns Response data for the Share Create operation.
     */
    ShareClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.create(__assign(__assign(__assign({}, options), { enabledProtocols: toShareProtocolsString(options.protocols) }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options -
     */
    ShareClient.prototype.createIfNotExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_2;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("ShareClient-createIfNotExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.create(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, __assign({ succeeded: true }, res)];
                    case 3:
                        e_2 = _d.sent();
                        if (((_a = e_2.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareAlreadyExists") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when creating a share only if it doesn't already exist."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_b = e_2.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_2.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName - A directory name
     * @returns The ShareDirectoryClient object for the given directory name.
     */
    ShareClient.prototype.getDirectoryClient = function (directoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    };
    Object.defineProperty(ShareClient.prototype, "rootDirectoryClient", {
        /**
         * Gets the directory client for the root directory of this share.
         * Note that the root directory always exists and cannot be deleted.
         *
         * @readonly A new ShareDirectoryClient object for the root directory.
         */
        get: function () {
            return this.getDirectoryClient("");
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory creation response data and the corresponding directory client.
     */
    ShareClient.prototype.createDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, directoryCreateResponse, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createDirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(updatedOptions)];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    ShareClient.prototype.deleteDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteDirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    ShareClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, fileClient, fileCreateResponse, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, updatedOptions)];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param directoryName -
     * @param fileName -
     * @param options - Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     */
    ShareClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, fileClient, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns true if the Azrue share resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing share might be deleted by other clients or
     * applications. Vice versa new shares might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    ShareClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_7;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties(updatedOptions)];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_7 = _b.sent();
                        if (e_7.statusCode === 404) {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when checking share existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns Response data for the Share Get Properties operation.
     */
    ShareClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, res, protocols, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getProperties(__assign(__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        res = _b.sent();
                        protocols = toShareProtocols(res.enabledProtocols);
                        res.protocols = protocols;
                        return [2 /*return*/, res];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options - Options to Share Delete operation.
     * @returns Response data for the Share Delete operation.
     */
    ShareClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_9;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.delete(__assign(__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Marks the specified share for deletion if it exists. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options -
     */
    ShareClient.prototype.deleteIfExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_10;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("ShareClient-deleteIfExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, __assign({ succeeded: true }, res)];
                    case 3:
                        e_10 = _d.sent();
                        if (((_a = e_10.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareNotFound") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a share only if it exists."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_b = e_10.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_10.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed.
     * @param option - Options to Share Set Metadata operation.
     * @returns Response data for the Share Set Metadata operation.
     */
    ShareClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_11;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata(__assign(__assign(__assign({}, options), { metadata: metadata }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param option - Options to Share Get Access Policy operation.
     * @returns Response data for the Share Get Access Policy operation.
     */
    ShareClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, res, _i, response_1, identifier, accessPolicy, e_12;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getAccessPolicy", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getAccessPolicy(__assign(__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            etag: response.etag,
                            lastModified: response.lastModified,
                            requestId: response.requestId,
                            signedIdentifiers: [],
                            version: response.version
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            accessPolicy = undefined;
                            if (identifier.accessPolicy) {
                                accessPolicy = {
                                    permissions: identifier.accessPolicy.permissions
                                };
                                if (identifier.accessPolicy.expiresOn) {
                                    accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                                }
                                if (identifier.accessPolicy.startsOn) {
                                    accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                                }
                            }
                            res.signedIdentifiers.push({
                                accessPolicy: accessPolicy,
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_12 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_12.message
                        });
                        throw e_12;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param shareAcl - Array of signed identifiers, each having a unique Id and details of access policy.
     * @param option - Options to Share Set Access Policy operation.
     * @returns Response data for the Share Set Access Policy operation.
     */
    ShareClient.prototype.setAccessPolicy = function (shareAcl, options) {
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _d, span, updatedOptions, acl, _i, _e, identifier, e_13;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _d = createSpan("ShareClient-setAccessPolicy", options), span = _d.span, updatedOptions = _d.updatedOptions;
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 3, 4, 5]);
                        acl = [];
                        for (_i = 0, _e = shareAcl || []; _i < _e.length; _i++) {
                            identifier = _e[_i];
                            acl.push({
                                accessPolicy: {
                                    expiresOn: ((_a = identifier.accessPolicy) === null || _a === void 0 ? void 0 : _a.expiresOn)
                                        ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)
                                        : undefined,
                                    permissions: (_b = identifier.accessPolicy) === null || _b === void 0 ? void 0 : _b.permissions,
                                    startsOn: ((_c = identifier.accessPolicy) === null || _c === void 0 ? void 0 : _c.startsOn)
                                        ? truncatedISO8061Date(identifier.accessPolicy.startsOn)
                                        : undefined
                                },
                                id: identifier.id
                            });
                        }
                        return [4 /*yield*/, this.context.setAccessPolicy(__assign(__assign(__assign({}, options), { shareAcl: acl }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _f.sent()];
                    case 3:
                        e_13 = _f.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param options - Options to Share Create Snapshot operation.
     * @returns Response data for the Share Create Snapshot operation.
     */
    ShareClient.prototype.createSnapshot = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_14;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createSnapshot", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.createSnapshot(__assign(__assign({ abortSignal: options.abortSignal }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets quota for the specified share.
     *
     * @deprecated Use {@link ShareClient.setProperties} instead.
     *
     * @param quotaInGB - Specifies the maximum size of the share in gigabytes
     * @param option - Options to Share Set Quota operation.
     * @returns Response data for the Share Get Quota operation.
     */
    ShareClient.prototype.setQuota = function (quotaInGB, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_15;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setQuota", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setProperties(__assign(__assign(__assign({}, options), { quota: quotaInGB }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_15 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_15.message
                        });
                        throw e_15;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties of the share.
     *
     * @param option - Options to Share Set Properties operation.
     * @returns Response data for the Share Set Properties operation.
     */
    ShareClient.prototype.setProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_16;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setProperties(__assign(__assign({}, options), { quota: options.quotaInGB, tracingOptions: updatedOptions.tracingOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_16 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_16.message
                        });
                        throw e_16;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves statistics related to the share.
     *
     * @param option - Options to Share Get Statistics operation.
     * @returns Response data for the Share Get Statistics operation.
     */
    ShareClient.prototype.getStatistics = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, GBBytes, e_17;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getStatistics", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getStatistics(__assign(__assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        GBBytes = 1024 * 1024 * 1024;
                        return [2 /*return*/, __assign(__assign({}, response), { shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) })];
                    case 3:
                        e_17 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_17.message
                        });
                        throw e_17;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermission - File permission described in the SDDL
     */
    ShareClient.prototype.createPermission = function (filePermission, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_18;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createPermission", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.createPermission({
                                permission: filePermission
                            }, __assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_18 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_18.message
                        });
                        throw e_18;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermissionKey - File permission key which indicates the security descriptor of the permission.
     */
    ShareClient.prototype.getPermission = function (filePermissionKey, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_19;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getPermission", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getPermission(filePermissionKey, __assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_19 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_19.message
                        });
                        throw e_19;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Only available for ShareClient constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    ShareClient.prototype.generateSasUrl = function (options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        var sas = generateFileSASQueryParameters(__assign({ shareName: this.name }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    };
    return ShareClient;
}(StorageClient));
export { ShareClient };
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 */
var ShareDirectoryClient = /** @class */ (function (_super) {
    __extends(ShareDirectoryClient, _super);
    function ShareDirectoryClient(url, credentialOrPipeline, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._name = _a.baseName, _this._shareName = _a.shareName, _this._path = _a.path);
        _this.context = new Directory(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareDirectoryClient.prototype, "shareName", {
        /**
         * The share name corresponding to this directory client
         */
        get: function () {
            return this._shareName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "path", {
        /**
         * The full path of the directory
         */
        get: function () {
            return this._path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "name", {
        /**
         * The name of the directory
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options - Options to Directory Create operation.
     * @returns Response data for the Directory  operation.
     */
    ShareDirectoryClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, attributes, e_20;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.fileAttributes) {
                            options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                            attributes = new FileSystemAttributes();
                            attributes.directory = true;
                            options.fileAttributes = attributes;
                        }
                        return [4 /*yield*/, this.context.create(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), __assign({ abortSignal: options.abortSignal, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_20 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_20.message
                        });
                        throw e_20;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new directory under the specified share or parent directory if it does not already exists.
     * If the directory already exists, it is not modified.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options -
     */
    ShareDirectoryClient.prototype.createIfNotExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_21;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("ShareDirectoryClient-createIfNotExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.create(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, __assign({ succeeded: true }, res)];
                    case 3:
                        e_21 = _d.sent();
                        if (((_a = e_21.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceAlreadyExists") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when creating a directory only if it does not already exist."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_b = e_21.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_21.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_21.message
                        });
                        throw e_21;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param DirectoryProperties - Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     */
    ShareDirectoryClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_22;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-setProperties", properties), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                        return [4 /*yield*/, this.context.setProperties(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), __assign({ abortSignal: properties.abortSignal, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_22 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_22.message
                        });
                        throw e_22;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName - A subdirectory name
     * @returns The ShareDirectoryClient object for the given subdirectory name.
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    ShareDirectoryClient.prototype.getDirectoryClient = function (subDirectoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subDirectoryName)), this.pipeline);
    };
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory create response data and the corresponding DirectoryClient instance.
     */
    ShareDirectoryClient.prototype.createSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, directoryCreateResponse, e_23;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createSubdirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(updatedOptions)];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_23 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_23.message
                        });
                        throw e_23;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    ShareDirectoryClient.prototype.deleteSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, directoryClient, e_24;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteSubdirectory", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_24 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_24.message
                        });
                        throw e_24;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    ShareDirectoryClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, fileClient, fileCreateResponse, e_25;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, updatedOptions)];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_25 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_25.message
                        });
                        throw e_25;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param fileName - Name of the file to delete
     * @param options - Options to File Delete operation.
     * @returns File deletion response data.
     */
    ShareDirectoryClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, fileClient, e_26;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_26 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_26.message
                        });
                        throw e_26;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param fileName - A file name.
     * @returns A new ShareFileClient object for the given file name.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareDirectoryClient.prototype.getFileClient = function (fileName) {
        return new ShareFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    /**
     * Returns true if the specified directory exists; false otherwise.
     *
     * NOTE: use this function with care since an existing directory might be deleted by other clients or
     * applications. Vice versa new directories might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    ShareDirectoryClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_27;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_27 = _b.sent();
                        if (e_27.statusCode === 404) {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when checking directory existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_27.message
                        });
                        throw e_27;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param options - Options to Directory Get Properties operation.
     * @returns Response data for the Directory Get Properties operation.
     */
    ShareDirectoryClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_28;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getProperties(__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_28 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_28.message
                        });
                        throw e_28;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options - Options to Directory Delete operation.
     * @returns Response data for the Directory Delete operation.
     */
    ShareDirectoryClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_29;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.delete(__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_29 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_29.message
                        });
                        throw e_29;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options -
     */
    ShareDirectoryClient.prototype.deleteIfExists = function (options) {
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _d, span, updatedOptions, res, e_30;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _d = createSpan("ShareDirectoryClient-deleteIfExists", options), span = _d.span, updatedOptions = _d.updatedOptions;
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _e.sent();
                        return [2 /*return*/, __assign({ succeeded: true }, res)];
                    case 3:
                        e_30 = _e.sent();
                        if (((_a = e_30.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                            ((_b = e_30.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a directory only if it exists."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_c = e_30.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e_30.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_30.message
                        });
                        throw e_30;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to Directory Set Metadata operation.
     * @returns Response data for the Directory Set Metadata operation.
     */
    ShareDirectoryClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_31;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata(__assign({ abortSignal: options.abortSignal, metadata: metadata }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_31 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_31.message
                        });
                        throw e_31;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list files and directories operation.
     */
    ShareDirectoryClient.prototype.iterateFilesAndDirectoriesSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function iterateFilesAndDirectoriesSegments_1() {
            var listFilesAndDirectoriesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listFilesAndDirectoriesSegment(marker, options))];
                    case 2:
                        listFilesAndDirectoriesResponse = _a.sent();
                        marker = listFilesAndDirectoriesResponse.continuationToken;
                        return [4 /*yield*/, __await(listFilesAndDirectoriesResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @param options - Options to list files and directories operation.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listFilesAndDirectoriesItems_1() {
            var marker, _a, _b, listFilesAndDirectoriesResponse, _i, _c, file, _d, _e, directory, e_32_1;
            var e_32, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 15, 16, 21]);
                        _a = __asyncValues(this.iterateFilesAndDirectoriesSegments(marker, options));
                        _g.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _g.sent(), !_b.done)) return [3 /*break*/, 14];
                        listFilesAndDirectoriesResponse = _b.value;
                        _i = 0, _c = listFilesAndDirectoriesResponse.segment.fileItems;
                        _g.label = 4;
                    case 4:
                        if (!(_i < _c.length)) return [3 /*break*/, 8];
                        file = _c[_i];
                        return [4 /*yield*/, __await(__assign({ kind: "file" }, file))];
                    case 5: return [4 /*yield*/, _g.sent()];
                    case 6:
                        _g.sent();
                        _g.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8:
                        _d = 0, _e = listFilesAndDirectoriesResponse.segment.directoryItems;
                        _g.label = 9;
                    case 9:
                        if (!(_d < _e.length)) return [3 /*break*/, 13];
                        directory = _e[_d];
                        return [4 /*yield*/, __await(__assign({ kind: "directory" }, directory))];
                    case 10: return [4 /*yield*/, _g.sent()];
                    case 11:
                        _g.sent();
                        _g.label = 12;
                    case 12:
                        _d++;
                        return [3 /*break*/, 9];
                    case 13: return [3 /*break*/, 2];
                    case 14: return [3 /*break*/, 21];
                    case 15:
                        e_32_1 = _g.sent();
                        e_32 = { error: e_32_1 };
                        return [3 /*break*/, 21];
                    case 16:
                        _g.trys.push([16, , 19, 20]);
                        if (!(_b && !_b.done && (_f = _a.return))) return [3 /*break*/, 18];
                        return [4 /*yield*/, __await(_f.call(_a))];
                    case 17:
                        _g.sent();
                        _g.label = 18;
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        if (e_32) throw e_32.error;
                        return [7 /*endfinally*/];
                    case 20: return [7 /*endfinally*/];
                    case 21: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param options - Options to list files and directories operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectories = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        // AsyncIterableIterator to iterate over files and directories
        var iter = this.listFilesAndDirectoriesItems(options);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateFilesAndDirectoriesSegments(settings.continuationToken, __assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Directory List Files and Directories Segment operation.
     * @returns Response data for the Directory List Files and Directories operation.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_33;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listFilesAndDirectoriesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.listFilesAndDirectoriesSegment(__assign(__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_33 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_33.message
                        });
                        throw e_33;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    ShareDirectoryClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function iterateHandleSegments_1() {
            var listHandlesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, __await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    ShareDirectoryClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listHandleItems_1() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_34_1;
            var e_34, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = __asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, __await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_34_1 = _e.sent();
                        e_34 = { error: e_34_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, __await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_34) throw e_34.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, __assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    ShareDirectoryClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_35;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(__assign(__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_35 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_35.message
                        });
                        throw e_35;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options -
     */
    ShareDirectoryClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_36;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.forceCloseHandles("*", __assign(__assign({ marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_36 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_36.message
                        });
                        throw e_36;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options -
     */
    ShareDirectoryClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, handlesClosed, numberOfHandlesFailedToClose, marker, response, e_37;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseAllHandles", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        numberOfHandlesFailedToClose = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, updatedOptions)];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);
                        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose }];
                    case 6:
                        e_37 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_37.message
                        });
                        throw e_37;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param aborter - Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param options -
     */
    ShareDirectoryClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_38;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseHandle", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (handleId === "*") {
                            throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                        }
                        return [4 /*yield*/, this.context.forceCloseHandles(handleId, __assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_38 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_38.message
                        });
                        throw e_38;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ShareDirectoryClient;
}(StorageClient));
export { ShareDirectoryClient };
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 */
var ShareFileClient = /** @class */ (function (_super) {
    __extends(ShareFileClient, _super);
    function ShareFileClient(url, credentialOrPipeline, options) {
        var _a;
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._name = _a.baseName, _this._shareName = _a.shareName, _this._path = _a.path);
        _this.context = new File(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareFileClient.prototype, "shareName", {
        /**
         * The share name corresponding to this file client
         */
        get: function () {
            return this._shareName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareFileClient.prototype, "path", {
        /**
         * The full path of the file
         */
        get: function () {
            return this._path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareFileClient.prototype, "name", {
        /**
         * The name of the file
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base ShareFileClient.
     *
     * @param shareSnapshot - The share snapshot timestamp.
     * @returns A new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     */
    ShareFileClient.prototype.withShareSnapshot = function (shareSnapshot) {
        return new ShareFileClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, shareSnapshot.length === 0 ? undefined : shareSnapshot), this.pipeline);
    };
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns Response data for the File Create  operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareFileClient.prototype.create = function (size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, attributes, e_39;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (size < 0 || size > FILE_MAX_SIZE_BYTES) {
                            throw new RangeError("File size must >= 0 and < " + FILE_MAX_SIZE_BYTES + ".");
                        }
                        options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                        if (!options.fileAttributes) {
                            attributes = new FileSystemAttributes();
                            attributes.none = true;
                            options.fileAttributes = attributes;
                        }
                        options.fileHttpHeaders = options.fileHttpHeaders || {};
                        return [4 /*yield*/, this.context.create(size, fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), __assign({ abortSignal: options.abortSignal, fileHttpHeaders: options.fileHttpHeaders, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_39 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_39.message
                        });
                        throw e_39;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `contentAsBlob`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param offset - From which position of the file to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Options to File Download operation.
     * @returns Response data for the File Download operation.
     *
     * Example usage (Node.js):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download();
     * console.log(
     *   "Downloaded file content:",
     *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}
     * );
     *
     * // A helper method used to read a Node.js readable stream into string
     * async function streamToBuffer(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browsers):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download(0);
     * console.log(
     *   "Downloaded file content:",
     *   await blobToString(await downloadFileResponse.blobBody)}
     * );
     *
     * // A helper method used to convert a browser Blob into string.
     * export async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    ShareFileClient.prototype.download = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, downloadFullFile, res_1, e_40;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-download", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {
                            throw new RangeError("rangeGetContentMD5 only works with partial data downloading");
                        }
                        downloadFullFile = offset === 0 && !count;
                        return [4 /*yield*/, this.context.download(__assign({ abortSignal: options.abortSignal, requestOptions: {
                                    onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream
                                }, range: downloadFullFile ? undefined : rangeToString({ offset: offset, count: count }), rangeGetContentMD5: options.rangeGetContentMD5, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        res_1 = _b.sent();
                        // Return browser response immediately
                        if (!isNode) {
                            return [2 /*return*/, res_1];
                        }
                        // We support retrying when download stream unexpected ends in Node.js runtime
                        // Following code shouldn't be bundled into browser build, however some
                        // bundlers may try to bundle following code and "FileReadResponse.ts".
                        // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
                        // The config is in package.json "browser" field
                        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                            // TODO: Default value or make it a required parameter?
                            options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
                        }
                        if (res_1.contentLength === undefined) {
                            throw new RangeError("File download response doesn't contain valid content length header");
                        }
                        return [2 /*return*/, new FileDownloadResponse(res_1, function (start) { return __awaiter(_this, void 0, void 0, function () {
                                var updatedOptions, downloadRes;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            updatedOptions = {
                                                range: rangeToString({
                                                    count: offset + res_1.contentLength - start,
                                                    offset: start
                                                })
                                            };
                                            return [4 /*yield*/, this.context.download(__assign(__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, updatedOptions), convertTracingToRequestOptionsBase(updatedOptions)))];
                                        case 1:
                                            downloadRes = _a.sent();
                                            if (!(downloadRes.etag === res_1.etag)) {
                                                throw new Error("File has been modified concurrently");
                                            }
                                            return [2 /*return*/, downloadRes.readableStreamBody];
                                    }
                                });
                            }); }, offset, res_1.contentLength, {
                                abortSignal: options.abortSignal,
                                maxRetryRequests: options.maxRetryRequests,
                                onProgress: options.onProgress
                            })];
                    case 3:
                        e_40 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_40.message
                        });
                        throw e_40;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns true if the specified file exists; false otherwise.
     *
     * NOTE: use this function with care since an existing file might be deleted by other clients or
     * applications. Vice versa new files might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    ShareFileClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_41;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_41 = _b.sent();
                        if (e_41.statusCode === 404) {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when checking file existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_41.message
                        });
                        throw e_41;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param options - Options to File Get Properties operation.
     * @returns Response data for the File Get Properties operation.
     */
    ShareFileClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                try {
                    return [2 /*return*/, this.context.getProperties(__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                }
                catch (e) {
                    span.setStatus({
                        code: SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param properties - File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     */
    ShareFileClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_42;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-setProperties", properties), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                        properties.fileHttpHeaders = properties.fileHttpHeaders || {};
                        return [4 /*yield*/, this.context.setHttpHeaders(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), __assign({ abortSignal: properties.abortSignal, fileHttpHeaders: properties.fileHttpHeaders, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey, leaseAccessConditions: properties.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_42 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_42.message
                        });
                        throw e_42;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options - Options to File Delete operation.
     * @returns Response data for the File Delete operation.
     */
    ShareFileClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_43;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.delete(__assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_43 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_43.message
                        });
                        throw e_43;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the file from the storage account if it exists.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options -
     */
    ShareFileClient.prototype.deleteIfExists = function (options) {
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _d, span, updatedOptions, res, e_44;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _d = createSpan("ShareFileClient-deleteIfExists", options), span = _d.span, updatedOptions = _d.updatedOptions;
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _e.sent();
                        return [2 /*return*/, __assign({ succeeded: true }, res)];
                    case 3:
                        e_44 = _e.sent();
                        if (((_a = e_44.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                            ((_b = e_44.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a file only if it exists."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_c = e_44.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e_44.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_44.message
                        });
                        throw e_44;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param FileHttpHeaders - File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param options - Options to File Set HTTP Headers operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    ShareFileClient.prototype.setHttpHeaders = function (fileHttpHeaders, options) {
        if (fileHttpHeaders === void 0) { fileHttpHeaders = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_45;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-setHTTPHeaders", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved
                        options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                        return [4 /*yield*/, this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), __assign({ abortSignal: options.abortSignal, fileHttpHeaders: fileHttpHeaders, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_45 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_45.message
                        });
                        throw e_45;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param length - Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param options - Options to File Resize operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    ShareFileClient.prototype.resize = function (length, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_46;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-resize", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (length < 0) {
                            throw new RangeError("Size cannot less than 0 when resizing file.");
                        }
                        // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.
                        options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                        return [4 /*yield*/, this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), __assign({ abortSignal: options.abortSignal, fileContentLength: length, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_46 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_46.message
                        });
                        throw e_46;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to File Set Metadata operation.
     * @returns Response data for the File Set Metadata operation.
     */
    ShareFileClient.prototype.setMetadata = function (metadata, options) {
        if (metadata === void 0) { metadata = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_47;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata(__assign({ abortSignal: options.abortSignal, metadata: metadata, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_47 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_47.message
                        });
                        throw e_47;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Upload a range of bytes to a file. This operation can only be called on an existing file.
     * It won't change the size, properties or metadata of the file.
     * Both the start and count of the range must be specified. The range can be up to 4 MB in size.
     *
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param offset - Offset position of the destination Azure File to upload.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to File Upload Range operation.
     * @returns Response data for the File Upload Range operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareFileClient.prototype.uploadRange = function (body, offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_48;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadRange", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (offset < 0) {
                            throw new RangeError("offset must be >= 0");
                        }
                        if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("contentLength must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                        }
                        if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("offset must be < " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                        }
                        return [4 /*yield*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "update", contentLength, __assign(__assign({ abortSignal: options.abortSignal, contentMD5: options.contentMD5, requestOptions: {
                                    onUploadProgress: options.onProgress
                                }, body: body }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_48 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_48.message
                        });
                        throw e_48;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param destOffset - Offset of destination file.
     * @param count - Number of bytes to be uploaded from source file.
     * @param options - Options to configure File - Upload Range from URL operation.
     */
    ShareFileClient.prototype.uploadRangeFromURL = function (sourceURL, sourceOffset, destOffset, count, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_49;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadRangeFromURL", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (sourceOffset < 0 || destOffset < 0) {
                            throw new RangeError("sourceOffset and destOffset must be >= 0");
                        }
                        if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("count must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                        }
                        return [4 /*yield*/, this.context.uploadRangeFromURL(rangeToString({ offset: destOffset, count: count }), sourceURL, 0, __assign(__assign({ abortSignal: options.abortSignal, sourceRange: rangeToString({ offset: sourceOffset, count: count }), sourceModifiedAccessConditions: options.sourceConditions }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_49 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_49.message
                        });
                        throw e_49;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param offset -
     * @param contentLength -
     * @param options - Options to File Clear Range operation.
     */
    ShareFileClient.prototype.clearRange = function (offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_50;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-clearRange", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (offset < 0 || contentLength <= 0) {
                            throw new RangeError("offset must >= 0 and contentLength must be > 0");
                        }
                        return [4 /*yield*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "clear", 0, __assign(__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_50 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_50.message
                        });
                        throw e_50;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param options - Options to File Get range List operation.
     */
    ShareFileClient.prototype.getRangeList = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, originalResponse, parsedBody, e_51;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-getRangeList", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getRangeList(__assign({ abortSignal: options.abortSignal, range: options.range ? rangeToString(options.range) : undefined, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        originalResponse = _b.sent();
                        parsedBody = originalResponse._response.parsedBody.ranges
                            ? originalResponse._response.parsedBody.ranges
                            : [];
                        return [2 /*return*/, __assign(__assign({}, originalResponse), { _response: __assign(__assign({}, originalResponse._response), { parsedBody: parsedBody }), rangeList: originalResponse.ranges ? originalResponse.ranges : [] })];
                    case 3:
                        e_51 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_51.message
                        });
                        throw e_51;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the list of ranges that differ between a previous share snapshot and this file.
     *
     * @param prevShareSnapshot - The previous snapshot parameter is an opaque DateTime value that specifies the previous share snapshot to compare with.
     * @param options -
     */
    ShareFileClient.prototype.getRangeListDiff = function (prevShareSnapshot, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_52;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-getRangeListDiff", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getRangeList(__assign(__assign(__assign({ prevsharesnapshot: prevShareSnapshot }, options), { range: options.range ? rangeToString(options.range) : undefined }), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_52 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_52.message
                        });
                        throw e_52;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param copySource - Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param options - Options to File Start Copy operation.
     */
    ShareFileClient.prototype.startCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_53;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-startCopyFromURL", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.startCopy(copySource, __assign({ abortSignal: options.abortSignal, metadata: options.metadata, leaseAccessConditions: options.leaseAccessConditions, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, copyFileSmbInfo: options.copyFileSmbInfo }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_53 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_53.message
                        });
                        throw e_53;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param copyId - Id of the Copy File operation to abort.
     * @param options - Options to File Abort Copy From URL operation.
     */
    ShareFileClient.prototype.abortCopyFromURL = function (copyId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_54;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-abortCopyFromURL", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.abortCopy(copyId, __assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_54 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_54.message
                        });
                        throw e_54;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    // High Level functions
    /**
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to it.
     *
     * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView
     * @param options -
     */
    ShareFileClient.prototype.uploadData = function (data, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, buffer_1, browserBlob_1;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadData", options), span = _a.span, updatedOptions = _a.updatedOptions;
                try {
                    if (isNode) {
                        if (data instanceof Buffer) {
                            buffer_1 = data;
                        }
                        else if (data instanceof ArrayBuffer) {
                            buffer_1 = Buffer.from(data);
                        }
                        else {
                            data = data;
                            buffer_1 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                        }
                        return [2 /*return*/, this.uploadSeekableInternal(function (offset, size) { return buffer_1.slice(offset, offset + size); }, buffer_1.byteLength, updatedOptions)];
                    }
                    else {
                        browserBlob_1 = new Blob([data]);
                        return [2 /*return*/, this.uploadSeekableInternal(function (offset, size) { return browserBlob_1.slice(offset, offset + size); }, browserBlob_1.size, updatedOptions)];
                    }
                }
                catch (e) {
                    span.setStatus({
                        code: SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param blobFactory -
     * @param size -
     * @param options -
     */
    ShareFileClient.prototype.uploadSeekableBlob = function (blobFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-UploadSeekableBlob", options), span = _a.span, updatedOptions = _a.updatedOptions;
                try {
                    return [2 /*return*/, this.uploadSeekableInternal(blobFactory, size, updatedOptions)];
                }
                catch (e) {
                    span.setStatus({
                        code: SpanStatusCode.ERROR,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a local file to it.
     *
     * @param filePath - Full path of local file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    ShareFileClient.prototype.uploadFile = function (filePath, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, size, e_55;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        return [4 /*yield*/, fsStat(filePath)];
                    case 2:
                        size = (_b.sent()).size;
                        return [4 /*yield*/, this.uploadSeekableInternal(function (offset, count) {
                                return function () {
                                    return fsCreateReadStream(filePath, {
                                        autoClose: true,
                                        end: count ? offset + count - 1 : Infinity,
                                        start: offset
                                    });
                                };
                            }, size, updatedOptions)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        e_55 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_55.message
                        });
                        throw e_55;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @param streamFactory - Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    ShareFileClient.prototype.uploadResetableStream = function (streamFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_56;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadResetableStream", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.uploadSeekableInternal(function (offset, count) {
                                return function () { return streamFactory(offset, count); };
                            }, size, updatedOptions)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_56 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_56.message
                        });
                        throw e_56;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     * @param bodyFactory -
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    ShareFileClient.prototype.uploadSeekableInternal = function (bodyFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, numBlocks_1, transferProgress_1, batch, _loop_1, i, e_57;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadSeekableInternal", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("options.rangeSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                leaseAccessConditions: options.leaseAccessConditions,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        numBlocks_1 = Math.floor((size - 1) / options.rangeSize) + 1;
                        transferProgress_1 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_1 = function (i) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var start, end, contentLength;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            start = options.rangeSize * i;
                                            end = i === numBlocks_1 - 1 ? size : start + options.rangeSize;
                                            contentLength = end - start;
                                            return [4 /*yield*/, this.uploadRange(bodyFactory(start, contentLength), start, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    leaseAccessConditions: options.leaseAccessConditions,
                                                    tracingOptions: updatedOptions.tracingOptions
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            transferProgress_1 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_1 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_1; i++) {
                            _loop_1(i);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        e_57 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_57.message
                        });
                        throw e_57;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    ShareFileClient.prototype.downloadToBuffer = function (bufferOrOffset, offsetOrCount, countOrOptions, optOptions) {
        if (optOptions === void 0) { optOptions = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var buffer, offset, count, options, _a, span, updatedOptions, response, transferProgress_2, batch, _loop_2, off, e_58;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        buffer = undefined;
                        options = optOptions;
                        if (bufferOrOffset instanceof Buffer) {
                            buffer = bufferOrOffset;
                            offset = offsetOrCount || 0;
                            count = typeof countOrOptions === "number" ? countOrOptions : 0;
                        }
                        else {
                            offset = typeof bufferOrOffset === "number" ? bufferOrOffset : 0;
                            count = typeof offsetOrCount === "number" ? offsetOrCount : 0;
                            options = countOrOptions || {};
                        }
                        _a = createSpan("ShareFileClient-downloadToBuffer", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0) {
                            throw new RangeError("rangeSize option must be > 0");
                        }
                        if (offset < 0) {
                            throw new RangeError("offset option must be >= 0");
                        }
                        if (count && count <= 0) {
                            throw new RangeError("count option must be > 0");
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        if (!!count) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                leaseAccessConditions: options.leaseAccessConditions,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        response = _b.sent();
                        count = response.contentLength - offset;
                        if (count < 0) {
                            throw new RangeError("offset " + offset + " shouldn't be larger than file size " + response.contentLength);
                        }
                        _b.label = 3;
                    case 3:
                        if (!buffer) {
                            try {
                                buffer = Buffer.alloc(count);
                            }
                            catch (error) {
                                throw new Error("Unable to allocate a buffer of size: " + count + " bytes. Please try passing your own Buffer to " +
                                    'the "downloadToBuffer method or try using other methods like "download" or "downloadToFile".' +
                                    ("\t " + error.message));
                            }
                        }
                        if (buffer.length < count) {
                            throw new RangeError("The buffer's size should be equal to or larger than the request count of bytes: " + count);
                        }
                        transferProgress_2 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_2 = function (off) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var chunkEnd, response, stream;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            chunkEnd = offset + count;
                                            if (off + options.rangeSize < chunkEnd) {
                                                chunkEnd = off + options.rangeSize;
                                            }
                                            return [4 /*yield*/, this.download(off, chunkEnd - off, {
                                                    abortSignal: options.abortSignal,
                                                    maxRetryRequests: options.maxRetryRequestsPerRange,
                                                    leaseAccessConditions: options.leaseAccessConditions,
                                                    tracingOptions: updatedOptions.tracingOptions
                                                })];
                                        case 1:
                                            response = _a.sent();
                                            stream = response.readableStreamBody;
                                            return [4 /*yield*/, streamToBuffer(stream, buffer, off - offset, chunkEnd - offset)];
                                        case 2:
                                            _a.sent();
                                            // Update progress after block is downloaded, in case of block trying
                                            // Could provide finer grained progress updating inside HTTP requests,
                                            // only if convenience layer download try is enabled
                                            transferProgress_2 += chunkEnd - off;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_2 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (off = offset; off < offset + count; off = off + options.rangeSize) {
                            _loop_2(off);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 4:
                        _b.sent();
                        return [2 /*return*/, buffer];
                    case 5:
                        e_58 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_58.message
                        });
                        throw e_58;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Node.js Readable stream into it.
     * This method will try to create an Azure File, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param stream - Node.js Readable stream. Must be less or equal than file size.
     * @param size - Size of file to be created. Maximum size allowed is 4 TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param bufferSize - Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be greater than 0 and lesser than or equal to 4 * 1024 * 1024 (4MB)
     * @param maxBuffers - Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param options -
     */
    ShareFileClient.prototype.uploadStream = function (stream, size, bufferSize, maxBuffers, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, transferProgress_3, scheduler, e_59;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadStream", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("bufferSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (maxBuffers < 0) {
                            throw new RangeError("maxBuffers must be > 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                leaseAccessConditions: options.leaseAccessConditions,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        transferProgress_3 = 0;
                        scheduler = new BufferScheduler(stream, bufferSize, maxBuffers, function (buffer, offset) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (transferProgress_3 + buffer.length > size) {
                                            throw new RangeError("Stream size is larger than file size " + size + " bytes, uploading failed. " +
                                                "Please make sure stream length is less or equal than file size.");
                                        }
                                        return [4 /*yield*/, this.uploadRange(buffer, offset, buffer.length, {
                                                abortSignal: options.abortSignal,
                                                leaseAccessConditions: options.leaseAccessConditions,
                                                tracingOptions: updatedOptions.tracingOptions
                                            })];
                                    case 1:
                                        _a.sent();
                                        // Update progress after block is successfully uploaded to server, in case of block trying
                                        transferProgress_3 += buffer.length;
                                        if (options.onProgress) {
                                            options.onProgress({ loadedBytes: transferProgress_3 });
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 
                        // Concurrency should set a smaller value than maxBuffers, which is helpful to
                        // reduce the possibility when a outgoing handler waits for stream data, in
                        // this situation, outgoing handlers are blocked.
                        // Outgoing queue shouldn't be empty.
                        Math.ceil((maxBuffers / 4) * 3));
                        return [4 /*yield*/, scheduler.do()];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        e_59 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_59.message
                        });
                        throw e_59;
                    case 5:
                        span.end();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param filePath -
     * @param offset - From which position of the block blob to download.
     * @param count - How much data to be downloaded. Will download to the end when passing undefined.
     * @param options - Options to Blob download options.
     * @returns The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     */
    ShareFileClient.prototype.downloadToFile = function (filePath, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_60;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-downloadToFile", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        return [4 /*yield*/, this.download(offset, count, updatedOptions)];
                    case 2:
                        response = _b.sent();
                        if (!response.readableStreamBody) return [3 /*break*/, 4];
                        return [4 /*yield*/, readStreamToLocalFile(response.readableStreamBody, filePath)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        // The stream is no longer accessible so setting it to undefined.
                        response.fileDownloadStream = undefined;
                        return [2 /*return*/, response];
                    case 5:
                        e_60 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_60.message
                        });
                        throw e_60;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    ShareFileClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_61;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-listHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(__assign(__assign({ abortSignal: options.abortSignal, marker: marker }, options), convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_61 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_61.message
                        });
                        throw e_61;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    ShareFileClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function iterateHandleSegments_2() {
            var listHandlesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, __await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    ShareFileClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listHandleItems_2() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_62_1;
            var e_62, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = __asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, __await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_62_1 = _e.sent();
                        e_62 = { error: e_62_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, __await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_62) throw e_62.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    ShareFileClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, __assign({ maxPageSize: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options - Options to force close handles operation.
     */
    ShareFileClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_63;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseHandlesSegment", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.forceCloseHandles("*", __assign({ abortSignal: options.abortSignal, marker: marker }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_63 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_63.message
                        });
                        throw e_63;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options - Options to force close handles operation.
     */
    ShareFileClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, handlesClosed, numberOfHandlesFailedToClose, marker, response, e_64;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseAllHandles", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        numberOfHandlesFailedToClose = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, { tracingOptions: updatedOptions.tracingOptions })];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);
                        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, {
                            closedHandlesCount: handlesClosed,
                            closeFailureCount: numberOfHandlesFailedToClose
                        }];
                    case 6:
                        e_64 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_64.message
                        });
                        throw e_64;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param FileForceCloseHandlesOptions - Options to force close handles operation.
     */
    ShareFileClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, rawResponse, response, e_65;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseHandle", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (handleId === "*") {
                            throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                        }
                        return [4 /*yield*/, this.context.forceCloseHandles(handleId, __assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_65 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_65.message
                        });
                        throw e_65;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a {@link ShareLeaseClient} that manages leases on the file.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new ShareLeaseClient object for managing leases on the file.
     */
    ShareFileClient.prototype.getShareLeaseClient = function (proposeLeaseId) {
        return new ShareLeaseClient(this, proposeLeaseId);
    };
    /**
     * Only available for clients constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    ShareFileClient.prototype.generateSasUrl = function (options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        var sas = generateFileSASQueryParameters(__assign({ shareName: this.shareName, filePath: this.path }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    };
    return ShareFileClient;
}(StorageClient));
export { ShareFileClient };
/**
 * A client that manages leases for a {@link ShareFileClient} or {@link ShareClient}.
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-file
 * and
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-share
 */
var ShareLeaseClient = /** @class */ (function () {
    /**
     * Creates an instance of ShareLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */
    function ShareLeaseClient(client, leaseId) {
        var clientContext = new StorageClientContext(client.url, __assign({ version: SERVICE_VERSION }, client.pipeline.toServiceClientOptions()));
        if (client instanceof ShareClient) {
            this.isShare = true;
            this.fileOrShare = new Share(clientContext);
        }
        else {
            this.isShare = false;
            this.fileOrShare = new File(clientContext);
        }
        this._url = client.url;
        if (!leaseId) {
            leaseId = generateUuid();
        }
        this._leaseId = leaseId;
    }
    Object.defineProperty(ShareLeaseClient.prototype, "leaseId", {
        /**
         * Gets the lease Id.
         *
         * @readonly
         */
        get: function () {
            return this._leaseId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShareLeaseClient.prototype, "url", {
        /**
         * Gets the url.
         *
         * @readonly
         */
        get: function () {
            return this._url;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Establishes and manages a lock on a file, share or share snapshot for write and delete operations.
     *
     * @param duration - Specifies the duration of lease in seconds. For file, the only allowed value is -1 for a lease that never expires. For share, must be -1 or between 15 to 60.
     * @param options - Options for the lease management operation.
     * @returns Response data for acquire lease operation.
     */
    ShareLeaseClient.prototype.acquireLease = function (duration, options) {
        if (duration === void 0) { duration = -1; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_66;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-acquireLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.acquireLease(__assign({ abortSignal: options.abortSignal, duration: duration, proposedLeaseId: this._leaseId }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_66 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_66.message
                        });
                        throw e_66;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To change the ID of an existing lease.
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - Options for the lease management operation.
     * @returns Response data for change lease operation.
     */
    ShareLeaseClient.prototype.changeLease = function (proposedLeaseId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, e_67;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-changeLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.changeLease(this._leaseId, __assign({ proposedLeaseId: proposedLeaseId, abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2:
                        response = _b.sent();
                        this._leaseId = proposedLeaseId;
                        return [2 /*return*/, response];
                    case 3:
                        e_67 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_67.message
                        });
                        throw e_67;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for release lease operation.
     */
    ShareLeaseClient.prototype.releaseLease = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_68;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-releaseLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.releaseLease(this._leaseId, __assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_68 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_68.message
                        });
                        throw e_68;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To force end the lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for break lease operation.
     */
    ShareLeaseClient.prototype.breakLease = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_69;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-breakLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.breakLease(__assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_69 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_69.message
                        });
                        throw e_69;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * To renew the lease. Only available for lease on share or share snapshot.
     * Note that the lease may be renewed even if it has expired as long as the share has not been leased again since the expiration of that lease.
     * When you renew a lease, the lease duration clock resets.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for renew lease operation.
     */
    ShareLeaseClient.prototype.renewLease = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_70;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareLeaseClient-renewLease", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        if (!this.isShare) {
                            throw new RangeError("The renewLease operation is not available for lease on file.");
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.fileOrShare.renewLease(this._leaseId, __assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_70 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_70.message
                        });
                        throw e_70;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ShareLeaseClient;
}());
export { ShareLeaseClient };
//# sourceMappingURL=Clients.js.map